// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/commands.proto

package org.mozc.android.inputmethod.japanese.protobuf;

public final class ProtoCommands {
  private ProtoCommands() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * This enum is used by SessionCommand::input_mode with
   * CHANGE_INPUT_MODE and Output::mode.
   * </pre>
   *
   * Protobuf enum {@code mozc.commands.CompositionMode}
   */
  public enum CompositionMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>DIRECT = 0;</code>
     */
    DIRECT(0),
    /**
     * <code>HIRAGANA = 1;</code>
     */
    HIRAGANA(1),
    /**
     * <code>FULL_KATAKANA = 2;</code>
     */
    FULL_KATAKANA(2),
    /**
     * <code>HALF_ASCII = 3;</code>
     */
    HALF_ASCII(3),
    /**
     * <code>FULL_ASCII = 4;</code>
     */
    FULL_ASCII(4),
    /**
     * <code>HALF_KATAKANA = 5;</code>
     */
    HALF_KATAKANA(5),
    /**
     * <code>NUM_OF_COMPOSITIONS = 6;</code>
     */
    NUM_OF_COMPOSITIONS(6),
    ;

    /**
     * <code>DIRECT = 0;</code>
     */
    public static final int DIRECT_VALUE = 0;
    /**
     * <code>HIRAGANA = 1;</code>
     */
    public static final int HIRAGANA_VALUE = 1;
    /**
     * <code>FULL_KATAKANA = 2;</code>
     */
    public static final int FULL_KATAKANA_VALUE = 2;
    /**
     * <code>HALF_ASCII = 3;</code>
     */
    public static final int HALF_ASCII_VALUE = 3;
    /**
     * <code>FULL_ASCII = 4;</code>
     */
    public static final int FULL_ASCII_VALUE = 4;
    /**
     * <code>HALF_KATAKANA = 5;</code>
     */
    public static final int HALF_KATAKANA_VALUE = 5;
    /**
     * <code>NUM_OF_COMPOSITIONS = 6;</code>
     */
    public static final int NUM_OF_COMPOSITIONS_VALUE = 6;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static CompositionMode valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static CompositionMode forNumber(int value) {
      switch (value) {
        case 0: return DIRECT;
        case 1: return HIRAGANA;
        case 2: return FULL_KATAKANA;
        case 3: return HALF_ASCII;
        case 4: return FULL_ASCII;
        case 5: return HALF_KATAKANA;
        case 6: return NUM_OF_COMPOSITIONS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CompositionMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        CompositionMode> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CompositionMode>() {
            public CompositionMode findValueByNumber(int number) {
              return CompositionMode.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.getDescriptor().getEnumTypes().get(0);
    }

    private static final CompositionMode[] VALUES = values();

    public static CompositionMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private CompositionMode(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mozc.commands.CompositionMode)
  }

  public interface KeyEventOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.KeyEvent)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     * @return Whether the keyCode field is set.
     */
    boolean hasKeyCode();
    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     * @return The keyCode.
     */
    int getKeyCode();

    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     * @return Whether the modifiers field is set.
     */
    boolean hasModifiers();
    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     * @return The modifiers.
     */
    int getModifiers();

    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     * @return Whether the specialKey field is set.
     */
    boolean hasSpecialKey();
    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     * @return The specialKey.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey();

    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @return A list containing the modifierKeys.
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList();
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @return The count of modifierKeys.
     */
    int getModifierKeysCount();
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @param index The index of the element to return.
     * @return The modifierKeys at the given index.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index);

    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return Whether the keyString field is set.
     */
    boolean hasKeyString();
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return The keyString.
     */
    java.lang.String getKeyString();
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return The bytes for keyString.
     */
    com.google.protobuf.ByteString
        getKeyStringBytes();

    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     * @return Whether the inputStyle field is set.
     */
    boolean hasInputStyle();
    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     * @return The inputStyle.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle getInputStyle();

    /**
     * <pre>
     * Input mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     * @return Whether the mode field is set.
     */
    boolean hasMode();
    /**
     * <pre>
     * Input mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     * @return The mode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode();

    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> 
        getProbableKeyEventList();
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getProbableKeyEvent(int index);
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    int getProbableKeyEventCount();
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder> 
        getProbableKeyEventOrBuilderList();
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder getProbableKeyEventOrBuilder(
        int index);

    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     * @return Whether the activated field is set.
     */
    boolean hasActivated();
    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     * @return The activated.
     */
    boolean getActivated();

    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     * @return Whether the timestampMsec field is set.
     */
    boolean hasTimestampMsec();
    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     * @return The timestampMsec.
     */
    long getTimestampMsec();
  }
  /**
   * Protobuf type {@code mozc.commands.KeyEvent}
   */
  public static final class KeyEvent extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.KeyEvent)
      KeyEventOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use KeyEvent.newBuilder() to construct.
    private KeyEvent(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private KeyEvent() {
      specialKey_ = 0;
      modifierKeys_ = java.util.Collections.emptyList();
      keyString_ = "";
      inputStyle_ = 0;
      mode_ = 0;
      probableKeyEvent_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new KeyEvent();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder.class);
    }

    /**
     * <pre>
     * LINT.IfChange
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.KeyEvent.SpecialKey}
     */
    public enum SpecialKey
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NO_SPECIALKEY = 0;</code>
       */
      NO_SPECIALKEY(0),
      /**
       * <code>DIGIT = 1;</code>
       */
      DIGIT(1),
      /**
       * <pre>
       * On Windows, SpecialKey::On and SpecialKey::OFF are obsolete. Use
       * TURN_ON_IME session command should be used instead. See b/10216365.
       * On other platforms, especially on Mac, please note that
       * client/client.cc still relies on SpecialKey::On for session playback.
       * We need to fix b/10250883 first.
       * TODO(team): Unsupport SpecialKey::On and SpecialKey::OFF.
       * </pre>
       *
       * <code>ON = 2;</code>
       */
      ON(2),
      /**
       * <code>OFF = 3;</code>
       */
      OFF(3),
      /**
       * <code>SPACE = 4;</code>
       */
      SPACE(4),
      /**
       * <code>ENTER = 5;</code>
       */
      ENTER(5),
      /**
       * <code>LEFT = 6;</code>
       */
      LEFT(6),
      /**
       * <code>RIGHT = 7;</code>
       */
      RIGHT(7),
      /**
       * <code>UP = 8;</code>
       */
      UP(8),
      /**
       * <code>DOWN = 9;</code>
       */
      DOWN(9),
      /**
       * <code>ESCAPE = 10;</code>
       */
      ESCAPE(10),
      /**
       * <pre>
       * Not DELETE because DELETE is reserved in MSVC.
       * </pre>
       *
       * <code>DEL = 11;</code>
       */
      DEL(11),
      /**
       * <code>BACKSPACE = 12;</code>
       */
      BACKSPACE(12),
      /**
       * <code>HENKAN = 13;</code>
       */
      HENKAN(13),
      /**
       * <code>MUHENKAN = 14;</code>
       */
      MUHENKAN(14),
      /**
       * <pre>
       * VK_DBE_HIRAGANA(Win), kVK_JIS_Kana(Mac)
       * The "Katakana Hiragana Romaji" key (w/o modifiers) returns this key code.
       * </pre>
       *
       * <code>KANA = 15;</code>
       */
      KANA(15),
      /**
       * <code>HOME = 16;</code>
       */
      HOME(16),
      /**
       * <code>END = 17;</code>
       */
      END(17),
      /**
       * <code>TAB = 18;</code>
       */
      TAB(18),
      /**
       * <code>F1 = 19;</code>
       */
      F1(19),
      /**
       * <code>F2 = 20;</code>
       */
      F2(20),
      /**
       * <code>F3 = 21;</code>
       */
      F3(21),
      /**
       * <code>F4 = 22;</code>
       */
      F4(22),
      /**
       * <code>F5 = 23;</code>
       */
      F5(23),
      /**
       * <code>F6 = 24;</code>
       */
      F6(24),
      /**
       * <code>F7 = 25;</code>
       */
      F7(25),
      /**
       * <code>F8 = 26;</code>
       */
      F8(26),
      /**
       * <code>F9 = 27;</code>
       */
      F9(27),
      /**
       * <code>F10 = 28;</code>
       */
      F10(28),
      /**
       * <code>F11 = 29;</code>
       */
      F11(29),
      /**
       * <code>F12 = 30;</code>
       */
      F12(30),
      /**
       * <code>PAGE_UP = 31;</code>
       */
      PAGE_UP(31),
      /**
       * <code>PAGE_DOWN = 32;</code>
       */
      PAGE_DOWN(32),
      /**
       * <code>INSERT = 33;</code>
       */
      INSERT(33),
      /**
       * <code>F13 = 34;</code>
       */
      F13(34),
      /**
       * <code>F14 = 35;</code>
       */
      F14(35),
      /**
       * <code>F15 = 36;</code>
       */
      F15(36),
      /**
       * <code>F16 = 37;</code>
       */
      F16(37),
      /**
       * <code>F17 = 38;</code>
       */
      F17(38),
      /**
       * <code>F18 = 39;</code>
       */
      F18(39),
      /**
       * <code>F19 = 40;</code>
       */
      F19(40),
      /**
       * <code>F20 = 41;</code>
       */
      F20(41),
      /**
       * <code>F21 = 42;</code>
       */
      F21(42),
      /**
       * <code>F22 = 43;</code>
       */
      F22(43),
      /**
       * <code>F23 = 44;</code>
       */
      F23(44),
      /**
       * <code>F24 = 45;</code>
       */
      F24(45),
      /**
       * <pre>
       * alphanumeric  VK_DBE_ALPHANUMERIC(Win), kVK_JIS_Eisu(Mac)
       * </pre>
       *
       * <code>EISU = 46;</code>
       */
      EISU(46),
      /**
       * <code>NUMPAD0 = 47;</code>
       */
      NUMPAD0(47),
      /**
       * <code>NUMPAD1 = 48;</code>
       */
      NUMPAD1(48),
      /**
       * <code>NUMPAD2 = 49;</code>
       */
      NUMPAD2(49),
      /**
       * <code>NUMPAD3 = 50;</code>
       */
      NUMPAD3(50),
      /**
       * <code>NUMPAD4 = 51;</code>
       */
      NUMPAD4(51),
      /**
       * <code>NUMPAD5 = 52;</code>
       */
      NUMPAD5(52),
      /**
       * <code>NUMPAD6 = 53;</code>
       */
      NUMPAD6(53),
      /**
       * <code>NUMPAD7 = 54;</code>
       */
      NUMPAD7(54),
      /**
       * <code>NUMPAD8 = 55;</code>
       */
      NUMPAD8(55),
      /**
       * <code>NUMPAD9 = 56;</code>
       */
      NUMPAD9(56),
      /**
       * <pre>
       * Numpad [*]
       * </pre>
       *
       * <code>MULTIPLY = 57;</code>
       */
      MULTIPLY(57),
      /**
       * <pre>
       * Numpad [+]
       * </pre>
       *
       * <code>ADD = 58;</code>
       */
      ADD(58),
      /**
       * <pre>
       * Numpad [enter]
       * </pre>
       *
       * <code>SEPARATOR = 59;</code>
       */
      SEPARATOR(59),
      /**
       * <pre>
       * Numpad [-]
       * </pre>
       *
       * <code>SUBTRACT = 60;</code>
       */
      SUBTRACT(60),
      /**
       * <pre>
       * Numpad [.]
       * </pre>
       *
       * <code>DECIMAL = 61;</code>
       */
      DECIMAL(61),
      /**
       * <pre>
       * Numpad [/]
       * </pre>
       *
       * <code>DIVIDE = 62;</code>
       */
      DIVIDE(62),
      /**
       * <pre>
       * Numpad [=]
       * </pre>
       *
       * <code>EQUALS = 63;</code>
       */
      EQUALS(63),
      /**
       * <pre>
       * Meta key event representing any text input.
       * </pre>
       *
       * <code>TEXT_INPUT = 64;</code>
       */
      TEXT_INPUT(64),
      /**
       * <pre>
       * GUI label is "Hankaku/Zenkaku".
       * </pre>
       *
       * <code>HANKAKU = 65;</code>
       */
      HANKAKU(65),
      /**
       * <code>KANJI = 66;</code>
       */
      KANJI(66),
      /**
       * <pre>
       * The "Katakana Hiragana Romaji" key with Shift returns this key code.
       * </pre>
       *
       * <code>KATAKANA = 67;</code>
       */
      KATAKANA(67),
      /**
       * <code>CAPS_LOCK = 68;</code>
       */
      CAPS_LOCK(68),
      /**
       * <pre>
       * Unsupported keys (e.g. PrtSc, Pause) fall back to UNDEFINED_KEY.
       * </pre>
       *
       * <code>UNDEFINED_KEY = 69;</code>
       */
      UNDEFINED_KEY(69),
      /**
       * <pre>
       * Numpad [,]
       * </pre>
       *
       * <code>COMMA = 70;</code>
       */
      COMMA(70),
      /**
       * <pre>
       * Numpad [5] without NUMLOCK
       * </pre>
       *
       * <code>CLEAR = 71;</code>
       */
      CLEAR(71),
      /**
       * <pre>
       * Left key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_LEFT = 72;</code>
       */
      VIRTUAL_LEFT(72),
      /**
       * <pre>
       * Right key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_RIGHT = 73;</code>
       */
      VIRTUAL_RIGHT(73),
      /**
       * <pre>
       * Enter key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_ENTER = 74;</code>
       */
      VIRTUAL_ENTER(74),
      /**
       * <pre>
       * Up key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_UP = 75;</code>
       */
      VIRTUAL_UP(75),
      /**
       * <pre>
       * Down key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_DOWN = 76;</code>
       */
      VIRTUAL_DOWN(76),
      /**
       * <code>NUM_SPECIALKEYS = 77;</code>
       */
      NUM_SPECIALKEYS(77),
      ;

      /**
       * <code>NO_SPECIALKEY = 0;</code>
       */
      public static final int NO_SPECIALKEY_VALUE = 0;
      /**
       * <code>DIGIT = 1;</code>
       */
      public static final int DIGIT_VALUE = 1;
      /**
       * <pre>
       * On Windows, SpecialKey::On and SpecialKey::OFF are obsolete. Use
       * TURN_ON_IME session command should be used instead. See b/10216365.
       * On other platforms, especially on Mac, please note that
       * client/client.cc still relies on SpecialKey::On for session playback.
       * We need to fix b/10250883 first.
       * TODO(team): Unsupport SpecialKey::On and SpecialKey::OFF.
       * </pre>
       *
       * <code>ON = 2;</code>
       */
      public static final int ON_VALUE = 2;
      /**
       * <code>OFF = 3;</code>
       */
      public static final int OFF_VALUE = 3;
      /**
       * <code>SPACE = 4;</code>
       */
      public static final int SPACE_VALUE = 4;
      /**
       * <code>ENTER = 5;</code>
       */
      public static final int ENTER_VALUE = 5;
      /**
       * <code>LEFT = 6;</code>
       */
      public static final int LEFT_VALUE = 6;
      /**
       * <code>RIGHT = 7;</code>
       */
      public static final int RIGHT_VALUE = 7;
      /**
       * <code>UP = 8;</code>
       */
      public static final int UP_VALUE = 8;
      /**
       * <code>DOWN = 9;</code>
       */
      public static final int DOWN_VALUE = 9;
      /**
       * <code>ESCAPE = 10;</code>
       */
      public static final int ESCAPE_VALUE = 10;
      /**
       * <pre>
       * Not DELETE because DELETE is reserved in MSVC.
       * </pre>
       *
       * <code>DEL = 11;</code>
       */
      public static final int DEL_VALUE = 11;
      /**
       * <code>BACKSPACE = 12;</code>
       */
      public static final int BACKSPACE_VALUE = 12;
      /**
       * <code>HENKAN = 13;</code>
       */
      public static final int HENKAN_VALUE = 13;
      /**
       * <code>MUHENKAN = 14;</code>
       */
      public static final int MUHENKAN_VALUE = 14;
      /**
       * <pre>
       * VK_DBE_HIRAGANA(Win), kVK_JIS_Kana(Mac)
       * The "Katakana Hiragana Romaji" key (w/o modifiers) returns this key code.
       * </pre>
       *
       * <code>KANA = 15;</code>
       */
      public static final int KANA_VALUE = 15;
      /**
       * <code>HOME = 16;</code>
       */
      public static final int HOME_VALUE = 16;
      /**
       * <code>END = 17;</code>
       */
      public static final int END_VALUE = 17;
      /**
       * <code>TAB = 18;</code>
       */
      public static final int TAB_VALUE = 18;
      /**
       * <code>F1 = 19;</code>
       */
      public static final int F1_VALUE = 19;
      /**
       * <code>F2 = 20;</code>
       */
      public static final int F2_VALUE = 20;
      /**
       * <code>F3 = 21;</code>
       */
      public static final int F3_VALUE = 21;
      /**
       * <code>F4 = 22;</code>
       */
      public static final int F4_VALUE = 22;
      /**
       * <code>F5 = 23;</code>
       */
      public static final int F5_VALUE = 23;
      /**
       * <code>F6 = 24;</code>
       */
      public static final int F6_VALUE = 24;
      /**
       * <code>F7 = 25;</code>
       */
      public static final int F7_VALUE = 25;
      /**
       * <code>F8 = 26;</code>
       */
      public static final int F8_VALUE = 26;
      /**
       * <code>F9 = 27;</code>
       */
      public static final int F9_VALUE = 27;
      /**
       * <code>F10 = 28;</code>
       */
      public static final int F10_VALUE = 28;
      /**
       * <code>F11 = 29;</code>
       */
      public static final int F11_VALUE = 29;
      /**
       * <code>F12 = 30;</code>
       */
      public static final int F12_VALUE = 30;
      /**
       * <code>PAGE_UP = 31;</code>
       */
      public static final int PAGE_UP_VALUE = 31;
      /**
       * <code>PAGE_DOWN = 32;</code>
       */
      public static final int PAGE_DOWN_VALUE = 32;
      /**
       * <code>INSERT = 33;</code>
       */
      public static final int INSERT_VALUE = 33;
      /**
       * <code>F13 = 34;</code>
       */
      public static final int F13_VALUE = 34;
      /**
       * <code>F14 = 35;</code>
       */
      public static final int F14_VALUE = 35;
      /**
       * <code>F15 = 36;</code>
       */
      public static final int F15_VALUE = 36;
      /**
       * <code>F16 = 37;</code>
       */
      public static final int F16_VALUE = 37;
      /**
       * <code>F17 = 38;</code>
       */
      public static final int F17_VALUE = 38;
      /**
       * <code>F18 = 39;</code>
       */
      public static final int F18_VALUE = 39;
      /**
       * <code>F19 = 40;</code>
       */
      public static final int F19_VALUE = 40;
      /**
       * <code>F20 = 41;</code>
       */
      public static final int F20_VALUE = 41;
      /**
       * <code>F21 = 42;</code>
       */
      public static final int F21_VALUE = 42;
      /**
       * <code>F22 = 43;</code>
       */
      public static final int F22_VALUE = 43;
      /**
       * <code>F23 = 44;</code>
       */
      public static final int F23_VALUE = 44;
      /**
       * <code>F24 = 45;</code>
       */
      public static final int F24_VALUE = 45;
      /**
       * <pre>
       * alphanumeric  VK_DBE_ALPHANUMERIC(Win), kVK_JIS_Eisu(Mac)
       * </pre>
       *
       * <code>EISU = 46;</code>
       */
      public static final int EISU_VALUE = 46;
      /**
       * <code>NUMPAD0 = 47;</code>
       */
      public static final int NUMPAD0_VALUE = 47;
      /**
       * <code>NUMPAD1 = 48;</code>
       */
      public static final int NUMPAD1_VALUE = 48;
      /**
       * <code>NUMPAD2 = 49;</code>
       */
      public static final int NUMPAD2_VALUE = 49;
      /**
       * <code>NUMPAD3 = 50;</code>
       */
      public static final int NUMPAD3_VALUE = 50;
      /**
       * <code>NUMPAD4 = 51;</code>
       */
      public static final int NUMPAD4_VALUE = 51;
      /**
       * <code>NUMPAD5 = 52;</code>
       */
      public static final int NUMPAD5_VALUE = 52;
      /**
       * <code>NUMPAD6 = 53;</code>
       */
      public static final int NUMPAD6_VALUE = 53;
      /**
       * <code>NUMPAD7 = 54;</code>
       */
      public static final int NUMPAD7_VALUE = 54;
      /**
       * <code>NUMPAD8 = 55;</code>
       */
      public static final int NUMPAD8_VALUE = 55;
      /**
       * <code>NUMPAD9 = 56;</code>
       */
      public static final int NUMPAD9_VALUE = 56;
      /**
       * <pre>
       * Numpad [*]
       * </pre>
       *
       * <code>MULTIPLY = 57;</code>
       */
      public static final int MULTIPLY_VALUE = 57;
      /**
       * <pre>
       * Numpad [+]
       * </pre>
       *
       * <code>ADD = 58;</code>
       */
      public static final int ADD_VALUE = 58;
      /**
       * <pre>
       * Numpad [enter]
       * </pre>
       *
       * <code>SEPARATOR = 59;</code>
       */
      public static final int SEPARATOR_VALUE = 59;
      /**
       * <pre>
       * Numpad [-]
       * </pre>
       *
       * <code>SUBTRACT = 60;</code>
       */
      public static final int SUBTRACT_VALUE = 60;
      /**
       * <pre>
       * Numpad [.]
       * </pre>
       *
       * <code>DECIMAL = 61;</code>
       */
      public static final int DECIMAL_VALUE = 61;
      /**
       * <pre>
       * Numpad [/]
       * </pre>
       *
       * <code>DIVIDE = 62;</code>
       */
      public static final int DIVIDE_VALUE = 62;
      /**
       * <pre>
       * Numpad [=]
       * </pre>
       *
       * <code>EQUALS = 63;</code>
       */
      public static final int EQUALS_VALUE = 63;
      /**
       * <pre>
       * Meta key event representing any text input.
       * </pre>
       *
       * <code>TEXT_INPUT = 64;</code>
       */
      public static final int TEXT_INPUT_VALUE = 64;
      /**
       * <pre>
       * GUI label is "Hankaku/Zenkaku".
       * </pre>
       *
       * <code>HANKAKU = 65;</code>
       */
      public static final int HANKAKU_VALUE = 65;
      /**
       * <code>KANJI = 66;</code>
       */
      public static final int KANJI_VALUE = 66;
      /**
       * <pre>
       * The "Katakana Hiragana Romaji" key with Shift returns this key code.
       * </pre>
       *
       * <code>KATAKANA = 67;</code>
       */
      public static final int KATAKANA_VALUE = 67;
      /**
       * <code>CAPS_LOCK = 68;</code>
       */
      public static final int CAPS_LOCK_VALUE = 68;
      /**
       * <pre>
       * Unsupported keys (e.g. PrtSc, Pause) fall back to UNDEFINED_KEY.
       * </pre>
       *
       * <code>UNDEFINED_KEY = 69;</code>
       */
      public static final int UNDEFINED_KEY_VALUE = 69;
      /**
       * <pre>
       * Numpad [,]
       * </pre>
       *
       * <code>COMMA = 70;</code>
       */
      public static final int COMMA_VALUE = 70;
      /**
       * <pre>
       * Numpad [5] without NUMLOCK
       * </pre>
       *
       * <code>CLEAR = 71;</code>
       */
      public static final int CLEAR_VALUE = 71;
      /**
       * <pre>
       * Left key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_LEFT = 72;</code>
       */
      public static final int VIRTUAL_LEFT_VALUE = 72;
      /**
       * <pre>
       * Right key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_RIGHT = 73;</code>
       */
      public static final int VIRTUAL_RIGHT_VALUE = 73;
      /**
       * <pre>
       * Enter key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_ENTER = 74;</code>
       */
      public static final int VIRTUAL_ENTER_VALUE = 74;
      /**
       * <pre>
       * Up key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_UP = 75;</code>
       */
      public static final int VIRTUAL_UP_VALUE = 75;
      /**
       * <pre>
       * Down key on virtual (software) keyboard
       * </pre>
       *
       * <code>VIRTUAL_DOWN = 76;</code>
       */
      public static final int VIRTUAL_DOWN_VALUE = 76;
      /**
       * <code>NUM_SPECIALKEYS = 77;</code>
       */
      public static final int NUM_SPECIALKEYS_VALUE = 77;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SpecialKey valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static SpecialKey forNumber(int value) {
        switch (value) {
          case 0: return NO_SPECIALKEY;
          case 1: return DIGIT;
          case 2: return ON;
          case 3: return OFF;
          case 4: return SPACE;
          case 5: return ENTER;
          case 6: return LEFT;
          case 7: return RIGHT;
          case 8: return UP;
          case 9: return DOWN;
          case 10: return ESCAPE;
          case 11: return DEL;
          case 12: return BACKSPACE;
          case 13: return HENKAN;
          case 14: return MUHENKAN;
          case 15: return KANA;
          case 16: return HOME;
          case 17: return END;
          case 18: return TAB;
          case 19: return F1;
          case 20: return F2;
          case 21: return F3;
          case 22: return F4;
          case 23: return F5;
          case 24: return F6;
          case 25: return F7;
          case 26: return F8;
          case 27: return F9;
          case 28: return F10;
          case 29: return F11;
          case 30: return F12;
          case 31: return PAGE_UP;
          case 32: return PAGE_DOWN;
          case 33: return INSERT;
          case 34: return F13;
          case 35: return F14;
          case 36: return F15;
          case 37: return F16;
          case 38: return F17;
          case 39: return F18;
          case 40: return F19;
          case 41: return F20;
          case 42: return F21;
          case 43: return F22;
          case 44: return F23;
          case 45: return F24;
          case 46: return EISU;
          case 47: return NUMPAD0;
          case 48: return NUMPAD1;
          case 49: return NUMPAD2;
          case 50: return NUMPAD3;
          case 51: return NUMPAD4;
          case 52: return NUMPAD5;
          case 53: return NUMPAD6;
          case 54: return NUMPAD7;
          case 55: return NUMPAD8;
          case 56: return NUMPAD9;
          case 57: return MULTIPLY;
          case 58: return ADD;
          case 59: return SEPARATOR;
          case 60: return SUBTRACT;
          case 61: return DECIMAL;
          case 62: return DIVIDE;
          case 63: return EQUALS;
          case 64: return TEXT_INPUT;
          case 65: return HANKAKU;
          case 66: return KANJI;
          case 67: return KATAKANA;
          case 68: return CAPS_LOCK;
          case 69: return UNDEFINED_KEY;
          case 70: return COMMA;
          case 71: return CLEAR;
          case 72: return VIRTUAL_LEFT;
          case 73: return VIRTUAL_RIGHT;
          case 74: return VIRTUAL_ENTER;
          case 75: return VIRTUAL_UP;
          case 76: return VIRTUAL_DOWN;
          case 77: return NUM_SPECIALKEYS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SpecialKey>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SpecialKey> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SpecialKey>() {
              public SpecialKey findValueByNumber(int number) {
                return SpecialKey.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDescriptor().getEnumTypes().get(0);
      }

      private static final SpecialKey[] VALUES = values();

      public static SpecialKey valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SpecialKey(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.KeyEvent.SpecialKey)
    }

    /**
     * Protobuf enum {@code mozc.commands.KeyEvent.ModifierKey}
     */
    public enum ModifierKey
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>CTRL = 1;</code>
       */
      CTRL(1),
      /**
       * <code>ALT = 2;</code>
       */
      ALT(2),
      /**
       * <code>SHIFT = 4;</code>
       */
      SHIFT(4),
      /**
       * <code>KEY_DOWN = 8;</code>
       */
      KEY_DOWN(8),
      /**
       * <code>KEY_UP = 16;</code>
       */
      KEY_UP(16),
      /**
       * <code>LEFT_CTRL = 32;</code>
       */
      LEFT_CTRL(32),
      /**
       * <code>LEFT_ALT = 64;</code>
       */
      LEFT_ALT(64),
      /**
       * <code>LEFT_SHIFT = 128;</code>
       */
      LEFT_SHIFT(128),
      /**
       * <code>RIGHT_CTRL = 256;</code>
       */
      RIGHT_CTRL(256),
      /**
       * <code>RIGHT_ALT = 512;</code>
       */
      RIGHT_ALT(512),
      /**
       * <code>RIGHT_SHIFT = 1024;</code>
       */
      RIGHT_SHIFT(1024),
      /**
       * <code>CAPS = 2048;</code>
       */
      CAPS(2048),
      ;

      /**
       * <code>CTRL = 1;</code>
       */
      public static final int CTRL_VALUE = 1;
      /**
       * <code>ALT = 2;</code>
       */
      public static final int ALT_VALUE = 2;
      /**
       * <code>SHIFT = 4;</code>
       */
      public static final int SHIFT_VALUE = 4;
      /**
       * <code>KEY_DOWN = 8;</code>
       */
      public static final int KEY_DOWN_VALUE = 8;
      /**
       * <code>KEY_UP = 16;</code>
       */
      public static final int KEY_UP_VALUE = 16;
      /**
       * <code>LEFT_CTRL = 32;</code>
       */
      public static final int LEFT_CTRL_VALUE = 32;
      /**
       * <code>LEFT_ALT = 64;</code>
       */
      public static final int LEFT_ALT_VALUE = 64;
      /**
       * <code>LEFT_SHIFT = 128;</code>
       */
      public static final int LEFT_SHIFT_VALUE = 128;
      /**
       * <code>RIGHT_CTRL = 256;</code>
       */
      public static final int RIGHT_CTRL_VALUE = 256;
      /**
       * <code>RIGHT_ALT = 512;</code>
       */
      public static final int RIGHT_ALT_VALUE = 512;
      /**
       * <code>RIGHT_SHIFT = 1024;</code>
       */
      public static final int RIGHT_SHIFT_VALUE = 1024;
      /**
       * <code>CAPS = 2048;</code>
       */
      public static final int CAPS_VALUE = 2048;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ModifierKey valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static ModifierKey forNumber(int value) {
        switch (value) {
          case 1: return CTRL;
          case 2: return ALT;
          case 4: return SHIFT;
          case 8: return KEY_DOWN;
          case 16: return KEY_UP;
          case 32: return LEFT_CTRL;
          case 64: return LEFT_ALT;
          case 128: return LEFT_SHIFT;
          case 256: return RIGHT_CTRL;
          case 512: return RIGHT_ALT;
          case 1024: return RIGHT_SHIFT;
          case 2048: return CAPS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ModifierKey>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ModifierKey> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ModifierKey>() {
              public ModifierKey findValueByNumber(int number) {
                return ModifierKey.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDescriptor().getEnumTypes().get(1);
      }

      private static final ModifierKey[] VALUES = values();

      public static ModifierKey valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private ModifierKey(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.KeyEvent.ModifierKey)
    }

    /**
     * Protobuf enum {@code mozc.commands.KeyEvent.InputStyle}
     */
    public enum InputStyle
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Follow the current input mode (default).
       * </pre>
       *
       * <code>FOLLOW_MODE = 0;</code>
       */
      FOLLOW_MODE(0),
      /**
       * <pre>
       * Do not transliterate key_string and use it as-is.
       * </pre>
       *
       * <code>AS_IS = 1;</code>
       */
      AS_IS(1),
      /**
       * <pre>
       * Immediately output key_string on the precomposition mode.
       * Same with AS_IS on the preedit mode.
       * </pre>
       *
       * <code>DIRECT_INPUT = 2;</code>
       */
      DIRECT_INPUT(2),
      ;

      /**
       * <pre>
       * Follow the current input mode (default).
       * </pre>
       *
       * <code>FOLLOW_MODE = 0;</code>
       */
      public static final int FOLLOW_MODE_VALUE = 0;
      /**
       * <pre>
       * Do not transliterate key_string and use it as-is.
       * </pre>
       *
       * <code>AS_IS = 1;</code>
       */
      public static final int AS_IS_VALUE = 1;
      /**
       * <pre>
       * Immediately output key_string on the precomposition mode.
       * Same with AS_IS on the preedit mode.
       * </pre>
       *
       * <code>DIRECT_INPUT = 2;</code>
       */
      public static final int DIRECT_INPUT_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InputStyle valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static InputStyle forNumber(int value) {
        switch (value) {
          case 0: return FOLLOW_MODE;
          case 1: return AS_IS;
          case 2: return DIRECT_INPUT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<InputStyle>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          InputStyle> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<InputStyle>() {
              public InputStyle findValueByNumber(int number) {
                return InputStyle.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDescriptor().getEnumTypes().get(2);
      }

      private static final InputStyle[] VALUES = values();

      public static InputStyle valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private InputStyle(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.KeyEvent.InputStyle)
    }

    public interface ProbableKeyEventOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.KeyEvent.ProbableKeyEvent)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return Whether the keyCode field is set.
       */
      boolean hasKeyCode();
      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return The keyCode.
       */
      int getKeyCode();

      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return Whether the specialKey field is set.
       */
      boolean hasSpecialKey();
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return The specialKey.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey();

      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return A list containing the modifierKeys.
       */
      java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList();
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return The count of modifierKeys.
       */
      int getModifierKeysCount();
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param index The index of the element to return.
       * @return The modifierKeys at the given index.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index);

      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       * @return Whether the probability field is set.
       */
      boolean hasProbability();
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       * @return The probability.
       */
      double getProbability();
    }
    /**
     * <pre>
     * Probable key event, mainly for touch screen.
     * User's input has ambiguity (e.g. the touch position is merginal)
     * so this message expresses the probable event.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.KeyEvent.ProbableKeyEvent}
     */
    public static final class ProbableKeyEvent extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.commands.KeyEvent.ProbableKeyEvent)
        ProbableKeyEventOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use ProbableKeyEvent.newBuilder() to construct.
      private ProbableKeyEvent(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private ProbableKeyEvent() {
        specialKey_ = 0;
        modifierKeys_ = java.util.Collections.emptyList();
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new ProbableKeyEvent();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder.class);
      }

      private int bitField0_;
      public static final int KEY_CODE_FIELD_NUMBER = 1;
      private int keyCode_ = 0;
      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return Whether the keyCode field is set.
       */
      @java.lang.Override
      public boolean hasKeyCode() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * message ID is the same as Input message.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return The keyCode.
       */
      @java.lang.Override
      public int getKeyCode() {
        return keyCode_;
      }

      public static final int SPECIAL_KEY_FIELD_NUMBER = 3;
      private int specialKey_ = 0;
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return Whether the specialKey field is set.
       */
      @java.lang.Override public boolean hasSpecialKey() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return The specialKey.
       */
      @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.forNumber(specialKey_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.NO_SPECIALKEY : result;
      }

      public static final int MODIFIER_KEYS_FIELD_NUMBER = 4;
      @SuppressWarnings("serial")
      private java.util.List<java.lang.Integer> modifierKeys_;
      private static final com.google.protobuf.Internal.ListAdapter.Converter<
          java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> modifierKeys_converter_ =
              new com.google.protobuf.Internal.ListAdapter.Converter<
                  java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>() {
                public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey convert(java.lang.Integer from) {
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(from);
                  return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.CTRL : result;
                }
              };
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return A list containing the modifierKeys.
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>(modifierKeys_, modifierKeys_converter_);
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return The count of modifierKeys.
       */
      @java.lang.Override
      public int getModifierKeysCount() {
        return modifierKeys_.size();
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param index The index of the element to return.
       * @return The modifierKeys at the given index.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index) {
        return modifierKeys_converter_.convert(modifierKeys_.get(index));
      }

      public static final int PROBABILITY_FIELD_NUMBER = 10;
      private double probability_ = 0D;
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       * @return Whether the probability field is set.
       */
      @java.lang.Override
      public boolean hasProbability() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 10;</code>
       * @return The probability.
       */
      @java.lang.Override
      public double getProbability() {
        return probability_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeUInt32(1, keyCode_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeEnum(3, specialKey_);
        }
        for (int i = 0; i < modifierKeys_.size(); i++) {
          output.writeEnum(4, modifierKeys_.get(i));
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeDouble(10, probability_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, keyCode_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(3, specialKey_);
        }
        {
          int dataSize = 0;
          for (int i = 0; i < modifierKeys_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeEnumSizeNoTag(modifierKeys_.get(i));
          }
          size += dataSize;
          size += 1 * modifierKeys_.size();
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeDoubleSize(10, probability_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent) obj;

        if (hasKeyCode() != other.hasKeyCode()) return false;
        if (hasKeyCode()) {
          if (getKeyCode()
              != other.getKeyCode()) return false;
        }
        if (hasSpecialKey() != other.hasSpecialKey()) return false;
        if (hasSpecialKey()) {
          if (specialKey_ != other.specialKey_) return false;
        }
        if (!modifierKeys_.equals(other.modifierKeys_)) return false;
        if (hasProbability() != other.hasProbability()) return false;
        if (hasProbability()) {
          if (java.lang.Double.doubleToLongBits(getProbability())
              != java.lang.Double.doubleToLongBits(
                  other.getProbability())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasKeyCode()) {
          hash = (37 * hash) + KEY_CODE_FIELD_NUMBER;
          hash = (53 * hash) + getKeyCode();
        }
        if (hasSpecialKey()) {
          hash = (37 * hash) + SPECIAL_KEY_FIELD_NUMBER;
          hash = (53 * hash) + specialKey_;
        }
        if (getModifierKeysCount() > 0) {
          hash = (37 * hash) + MODIFIER_KEYS_FIELD_NUMBER;
          hash = (53 * hash) + modifierKeys_.hashCode();
        }
        if (hasProbability()) {
          hash = (37 * hash) + PROBABILITY_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              java.lang.Double.doubleToLongBits(getProbability()));
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Probable key event, mainly for touch screen.
       * User's input has ambiguity (e.g. the touch position is merginal)
       * so this message expresses the probable event.
       * </pre>
       *
       * Protobuf type {@code mozc.commands.KeyEvent.ProbableKeyEvent}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.KeyEvent.ProbableKeyEvent)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          keyCode_ = 0;
          specialKey_ = 0;
          modifierKeys_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          probability_ = 0D;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_descriptor;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.getDefaultInstance();
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent(this);
          buildPartialRepeatedFields(result);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent result) {
          if (((bitField0_ & 0x00000004) != 0)) {
            modifierKeys_ = java.util.Collections.unmodifiableList(modifierKeys_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.modifierKeys_ = modifierKeys_;
        }

        private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.keyCode_ = keyCode_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.specialKey_ = specialKey_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.probability_ = probability_;
            to_bitField0_ |= 0x00000004;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.getDefaultInstance()) return this;
          if (other.hasKeyCode()) {
            setKeyCode(other.getKeyCode());
          }
          if (other.hasSpecialKey()) {
            setSpecialKey(other.getSpecialKey());
          }
          if (!other.modifierKeys_.isEmpty()) {
            if (modifierKeys_.isEmpty()) {
              modifierKeys_ = other.modifierKeys_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureModifierKeysIsMutable();
              modifierKeys_.addAll(other.modifierKeys_);
            }
            onChanged();
          }
          if (other.hasProbability()) {
            setProbability(other.getProbability());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  keyCode_ = input.readUInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 24: {
                  int tmpRaw = input.readEnum();
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey tmpValue =
                      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(3, tmpRaw);
                  } else {
                    specialKey_ = tmpRaw;
                    bitField0_ |= 0x00000002;
                  }
                  break;
                } // case 24
                case 32: {
                  int tmpRaw = input.readEnum();
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey tmpValue =
                      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(4, tmpRaw);
                  } else {
                    ensureModifierKeysIsMutable();
                    modifierKeys_.add(tmpRaw);
                  }
                  break;
                } // case 32
                case 34: {
                  int length = input.readRawVarint32();
                  int oldLimit = input.pushLimit(length);
                  while(input.getBytesUntilLimit() > 0) {
                    int tmpRaw = input.readEnum();
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey tmpValue =
                        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(tmpRaw);
                    if (tmpValue == null) {
                      mergeUnknownVarintField(4, tmpRaw);
                    } else {
                      ensureModifierKeysIsMutable();
                      modifierKeys_.add(tmpRaw);
                    }
                  }
                  input.popLimit(oldLimit);
                  break;
                } // case 34
                case 81: {
                  probability_ = input.readDouble();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 81
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int keyCode_ ;
        /**
         * <pre>
         * message ID is the same as Input message.
         * </pre>
         *
         * <code>optional uint32 key_code = 1;</code>
         * @return Whether the keyCode field is set.
         */
        @java.lang.Override
        public boolean hasKeyCode() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * message ID is the same as Input message.
         * </pre>
         *
         * <code>optional uint32 key_code = 1;</code>
         * @return The keyCode.
         */
        @java.lang.Override
        public int getKeyCode() {
          return keyCode_;
        }
        /**
         * <pre>
         * message ID is the same as Input message.
         * </pre>
         *
         * <code>optional uint32 key_code = 1;</code>
         * @param value The keyCode to set.
         * @return This builder for chaining.
         */
        public Builder setKeyCode(int value) {
          
          keyCode_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * message ID is the same as Input message.
         * </pre>
         *
         * <code>optional uint32 key_code = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearKeyCode() {
          bitField0_ = (bitField0_ & ~0x00000001);
          keyCode_ = 0;
          onChanged();
          return this;
        }

        private int specialKey_ = 0;
        /**
         * <pre>
         * Unprintable key listed above.
         * </pre>
         *
         * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
         * @return Whether the specialKey field is set.
         */
        @java.lang.Override public boolean hasSpecialKey() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Unprintable key listed above.
         * </pre>
         *
         * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
         * @return The specialKey.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.forNumber(specialKey_);
          return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.NO_SPECIALKEY : result;
        }
        /**
         * <pre>
         * Unprintable key listed above.
         * </pre>
         *
         * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
         * @param value The specialKey to set.
         * @return This builder for chaining.
         */
        public Builder setSpecialKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000002;
          specialKey_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Unprintable key listed above.
         * </pre>
         *
         * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearSpecialKey() {
          bitField0_ = (bitField0_ & ~0x00000002);
          specialKey_ = 0;
          onChanged();
          return this;
        }

        private java.util.List<java.lang.Integer> modifierKeys_ =
          java.util.Collections.emptyList();
        private void ensureModifierKeysIsMutable() {
          if (!((bitField0_ & 0x00000004) != 0)) {
            modifierKeys_ = new java.util.ArrayList<java.lang.Integer>(modifierKeys_);
            bitField0_ |= 0x00000004;
          }
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @return A list containing the modifierKeys.
         */
        public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList() {
          return new com.google.protobuf.Internal.ListAdapter<
              java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>(modifierKeys_, modifierKeys_converter_);
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @return The count of modifierKeys.
         */
        public int getModifierKeysCount() {
          return modifierKeys_.size();
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @param index The index of the element to return.
         * @return The modifierKeys at the given index.
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index) {
          return modifierKeys_converter_.convert(modifierKeys_.get(index));
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @param index The index to set the value at.
         * @param value The modifierKeys to set.
         * @return This builder for chaining.
         */
        public Builder setModifierKeys(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureModifierKeysIsMutable();
          modifierKeys_.set(index, value.getNumber());
          onChanged();
          return this;
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @param value The modifierKeys to add.
         * @return This builder for chaining.
         */
        public Builder addModifierKeys(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureModifierKeysIsMutable();
          modifierKeys_.add(value.getNumber());
          onChanged();
          return this;
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @param values The modifierKeys to add.
         * @return This builder for chaining.
         */
        public Builder addAllModifierKeys(
            java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> values) {
          ensureModifierKeysIsMutable();
          for (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value : values) {
            modifierKeys_.add(value.getNumber());
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * ModifierKeys
         * </pre>
         *
         * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearModifierKeys() {
          modifierKeys_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }

        private double probability_ ;
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 10;</code>
         * @return Whether the probability field is set.
         */
        @java.lang.Override
        public boolean hasProbability() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 10;</code>
         * @return The probability.
         */
        @java.lang.Override
        public double getProbability() {
          return probability_;
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 10;</code>
         * @param value The probability to set.
         * @return This builder for chaining.
         */
        public Builder setProbability(double value) {
          
          probability_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 10;</code>
         * @return This builder for chaining.
         */
        public Builder clearProbability() {
          bitField0_ = (bitField0_ & ~0x00000008);
          probability_ = 0D;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.commands.KeyEvent.ProbableKeyEvent)
      }

      // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent.ProbableKeyEvent)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<ProbableKeyEvent>
          PARSER = new com.google.protobuf.AbstractParser<ProbableKeyEvent>() {
        @java.lang.Override
        public ProbableKeyEvent parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<ProbableKeyEvent> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ProbableKeyEvent> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int KEY_CODE_FIELD_NUMBER = 1;
    private int keyCode_ = 0;
    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     * @return Whether the keyCode field is set.
     */
    @java.lang.Override
    public boolean hasKeyCode() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Printable key in UCS4.  If key_code is empty, key_string is used
     * as a raw input.
     * </pre>
     *
     * <code>optional uint32 key_code = 1;</code>
     * @return The keyCode.
     */
    @java.lang.Override
    public int getKeyCode() {
      return keyCode_;
    }

    public static final int MODIFIERS_FIELD_NUMBER = 2;
    private int modifiers_ = 0;
    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     * @return Whether the modifiers field is set.
     */
    @java.lang.Override
    public boolean hasModifiers() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Going to be obsolete.
     * </pre>
     *
     * <code>optional uint32 modifiers = 2;</code>
     * @return The modifiers.
     */
    @java.lang.Override
    public int getModifiers() {
      return modifiers_;
    }

    public static final int SPECIAL_KEY_FIELD_NUMBER = 3;
    private int specialKey_ = 0;
    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     * @return Whether the specialKey field is set.
     */
    @java.lang.Override public boolean hasSpecialKey() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Unprintable key listed above.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
     * @return The specialKey.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.forNumber(specialKey_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.NO_SPECIALKEY : result;
    }

    public static final int MODIFIER_KEYS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<java.lang.Integer> modifierKeys_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> modifierKeys_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>() {
              public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey convert(java.lang.Integer from) {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(from);
                return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.CTRL : result;
              }
            };
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @return A list containing the modifierKeys.
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>(modifierKeys_, modifierKeys_converter_);
    }
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @return The count of modifierKeys.
     */
    @java.lang.Override
    public int getModifierKeysCount() {
      return modifierKeys_.size();
    }
    /**
     * <pre>
     * ModifierKeys
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
     * @param index The index of the element to return.
     * @return The modifierKeys at the given index.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index) {
      return modifierKeys_converter_.convert(modifierKeys_.get(index));
    }

    public static final int KEY_STRING_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object keyString_ = "";
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return Whether the keyString field is set.
     */
    @java.lang.Override
    public boolean hasKeyString() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return The keyString.
     */
    @java.lang.Override
    public java.lang.String getKeyString() {
      java.lang.Object ref = keyString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          keyString_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * String used for preedit.  Kana characters and strings typed from
     * a software keyboard are supposed to be stored here.  If key_code
     * is also set, key_code is treated as the raw input and key_string is
     * treated as the composition input.  For example, to set Kana value,
     * when key_string is "ち", key_code should be 'a' (97).  If key_code
     * is empty, key_string is also treated as the raw input.
     * </pre>
     *
     * <code>optional string key_string = 5;</code>
     * @return The bytes for keyString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyStringBytes() {
      java.lang.Object ref = keyString_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        keyString_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INPUT_STYLE_FIELD_NUMBER = 6;
    private int inputStyle_ = 0;
    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     * @return Whether the inputStyle field is set.
     */
    @java.lang.Override public boolean hasInputStyle() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
     * @return The inputStyle.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle getInputStyle() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle.forNumber(inputStyle_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle.FOLLOW_MODE : result;
    }

    public static final int MODE_FIELD_NUMBER = 7;
    private int mode_ = 0;
    /**
     * <pre>
     * Input mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     * @return Whether the mode field is set.
     */
    @java.lang.Override public boolean hasMode() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Input mode
     * For histrical reasons, this field expects a temporary conversion
     * mode rather than comeback input mode.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
     * @return The mode.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(mode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }

    public static final int PROBABLE_KEY_EVENT_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> probableKeyEvent_;
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> getProbableKeyEventList() {
      return probableKeyEvent_;
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder> 
        getProbableKeyEventOrBuilderList() {
      return probableKeyEvent_;
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    @java.lang.Override
    public int getProbableKeyEventCount() {
      return probableKeyEvent_.size();
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getProbableKeyEvent(int index) {
      return probableKeyEvent_.get(index);
    }
    /**
     * <pre>
     * Probable key events
     * Even if you can fill this field,
     * don't omit Input.key_code and so on
     * because preedit string is composed based on them.
     * </pre>
     *
     * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder getProbableKeyEventOrBuilder(
        int index) {
      return probableKeyEvent_.get(index);
    }

    public static final int ACTIVATED_FIELD_NUMBER = 9;
    private boolean activated_ = false;
    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     * @return Whether the activated field is set.
     */
    @java.lang.Override
    public boolean hasActivated() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * IME on/off mode
     * You can use this field to change the IME on/off mode indirectly without
     * sending SpecialKey:ON or SpecialKey:OFF events.
     * If the internal ImeContext::State is DIRECT and this field is true, the
     * converter will change the state to PRECONPOSITION and then handles this key
     * event.
     * If the internal ImeContext::State is not DIRECT and this field is false,
     * the converter will change the state to DIRECT and then handles this key
     * event.
     * Implementation note: We need both |mode| and |activated| to support
     * indirect IME off, where |mode| should contain the next mode. If this field
     * is not set, the server will act as if indirect on/off was not supported.
     * </pre>
     *
     * <code>optional bool activated = 9;</code>
     * @return The activated.
     */
    @java.lang.Override
    public boolean getActivated() {
      return activated_;
    }

    public static final int TIMESTAMP_MSEC_FIELD_NUMBER = 10;
    private long timestampMsec_ = 0L;
    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     * @return Whether the timestampMsec field is set.
     */
    @java.lang.Override
    public boolean hasTimestampMsec() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Timestamp of this key event in millisecond.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 10;</code>
     * @return The timestampMsec.
     */
    @java.lang.Override
    public long getTimestampMsec() {
      return timestampMsec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(1, keyCode_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt32(2, modifiers_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeEnum(3, specialKey_);
      }
      for (int i = 0; i < modifierKeys_.size(); i++) {
        output.writeEnum(4, modifierKeys_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, keyString_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeEnum(6, inputStyle_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeEnum(7, mode_);
      }
      for (int i = 0; i < probableKeyEvent_.size(); i++) {
        output.writeMessage(8, probableKeyEvent_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(9, activated_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt64(10, timestampMsec_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, keyCode_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, modifiers_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, specialKey_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < modifierKeys_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(modifierKeys_.get(i));
        }
        size += dataSize;
        size += 1 * modifierKeys_.size();
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, keyString_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, inputStyle_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(7, mode_);
      }
      for (int i = 0; i < probableKeyEvent_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, probableKeyEvent_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, activated_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(10, timestampMsec_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent) obj;

      if (hasKeyCode() != other.hasKeyCode()) return false;
      if (hasKeyCode()) {
        if (getKeyCode()
            != other.getKeyCode()) return false;
      }
      if (hasModifiers() != other.hasModifiers()) return false;
      if (hasModifiers()) {
        if (getModifiers()
            != other.getModifiers()) return false;
      }
      if (hasSpecialKey() != other.hasSpecialKey()) return false;
      if (hasSpecialKey()) {
        if (specialKey_ != other.specialKey_) return false;
      }
      if (!modifierKeys_.equals(other.modifierKeys_)) return false;
      if (hasKeyString() != other.hasKeyString()) return false;
      if (hasKeyString()) {
        if (!getKeyString()
            .equals(other.getKeyString())) return false;
      }
      if (hasInputStyle() != other.hasInputStyle()) return false;
      if (hasInputStyle()) {
        if (inputStyle_ != other.inputStyle_) return false;
      }
      if (hasMode() != other.hasMode()) return false;
      if (hasMode()) {
        if (mode_ != other.mode_) return false;
      }
      if (!getProbableKeyEventList()
          .equals(other.getProbableKeyEventList())) return false;
      if (hasActivated() != other.hasActivated()) return false;
      if (hasActivated()) {
        if (getActivated()
            != other.getActivated()) return false;
      }
      if (hasTimestampMsec() != other.hasTimestampMsec()) return false;
      if (hasTimestampMsec()) {
        if (getTimestampMsec()
            != other.getTimestampMsec()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKeyCode()) {
        hash = (37 * hash) + KEY_CODE_FIELD_NUMBER;
        hash = (53 * hash) + getKeyCode();
      }
      if (hasModifiers()) {
        hash = (37 * hash) + MODIFIERS_FIELD_NUMBER;
        hash = (53 * hash) + getModifiers();
      }
      if (hasSpecialKey()) {
        hash = (37 * hash) + SPECIAL_KEY_FIELD_NUMBER;
        hash = (53 * hash) + specialKey_;
      }
      if (getModifierKeysCount() > 0) {
        hash = (37 * hash) + MODIFIER_KEYS_FIELD_NUMBER;
        hash = (53 * hash) + modifierKeys_.hashCode();
      }
      if (hasKeyString()) {
        hash = (37 * hash) + KEY_STRING_FIELD_NUMBER;
        hash = (53 * hash) + getKeyString().hashCode();
      }
      if (hasInputStyle()) {
        hash = (37 * hash) + INPUT_STYLE_FIELD_NUMBER;
        hash = (53 * hash) + inputStyle_;
      }
      if (hasMode()) {
        hash = (37 * hash) + MODE_FIELD_NUMBER;
        hash = (53 * hash) + mode_;
      }
      if (getProbableKeyEventCount() > 0) {
        hash = (37 * hash) + PROBABLE_KEY_EVENT_FIELD_NUMBER;
        hash = (53 * hash) + getProbableKeyEventList().hashCode();
      }
      if (hasActivated()) {
        hash = (37 * hash) + ACTIVATED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getActivated());
      }
      if (hasTimestampMsec()) {
        hash = (37 * hash) + TIMESTAMP_MSEC_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getTimestampMsec());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.commands.KeyEvent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.KeyEvent)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        keyCode_ = 0;
        modifiers_ = 0;
        specialKey_ = 0;
        modifierKeys_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        keyString_ = "";
        inputStyle_ = 0;
        mode_ = 0;
        if (probableKeyEventBuilder_ == null) {
          probableKeyEvent_ = java.util.Collections.emptyList();
        } else {
          probableKeyEvent_ = null;
          probableKeyEventBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        activated_ = false;
        timestampMsec_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_KeyEvent_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent result) {
        if (((bitField0_ & 0x00000008) != 0)) {
          modifierKeys_ = java.util.Collections.unmodifiableList(modifierKeys_);
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.modifierKeys_ = modifierKeys_;
        if (probableKeyEventBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            probableKeyEvent_ = java.util.Collections.unmodifiableList(probableKeyEvent_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.probableKeyEvent_ = probableKeyEvent_;
        } else {
          result.probableKeyEvent_ = probableKeyEventBuilder_.build();
        }
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.keyCode_ = keyCode_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.modifiers_ = modifiers_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.specialKey_ = specialKey_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.keyString_ = keyString_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.inputStyle_ = inputStyle_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.mode_ = mode_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.activated_ = activated_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.timestampMsec_ = timestampMsec_;
          to_bitField0_ |= 0x00000080;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance()) return this;
        if (other.hasKeyCode()) {
          setKeyCode(other.getKeyCode());
        }
        if (other.hasModifiers()) {
          setModifiers(other.getModifiers());
        }
        if (other.hasSpecialKey()) {
          setSpecialKey(other.getSpecialKey());
        }
        if (!other.modifierKeys_.isEmpty()) {
          if (modifierKeys_.isEmpty()) {
            modifierKeys_ = other.modifierKeys_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureModifierKeysIsMutable();
            modifierKeys_.addAll(other.modifierKeys_);
          }
          onChanged();
        }
        if (other.hasKeyString()) {
          keyString_ = other.keyString_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasInputStyle()) {
          setInputStyle(other.getInputStyle());
        }
        if (other.hasMode()) {
          setMode(other.getMode());
        }
        if (probableKeyEventBuilder_ == null) {
          if (!other.probableKeyEvent_.isEmpty()) {
            if (probableKeyEvent_.isEmpty()) {
              probableKeyEvent_ = other.probableKeyEvent_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureProbableKeyEventIsMutable();
              probableKeyEvent_.addAll(other.probableKeyEvent_);
            }
            onChanged();
          }
        } else {
          if (!other.probableKeyEvent_.isEmpty()) {
            if (probableKeyEventBuilder_.isEmpty()) {
              probableKeyEventBuilder_.dispose();
              probableKeyEventBuilder_ = null;
              probableKeyEvent_ = other.probableKeyEvent_;
              bitField0_ = (bitField0_ & ~0x00000080);
              probableKeyEventBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getProbableKeyEventFieldBuilder() : null;
            } else {
              probableKeyEventBuilder_.addAllMessages(other.probableKeyEvent_);
            }
          }
        }
        if (other.hasActivated()) {
          setActivated(other.getActivated());
        }
        if (other.hasTimestampMsec()) {
          setTimestampMsec(other.getTimestampMsec());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                keyCode_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                modifiers_ = input.readUInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(3, tmpRaw);
                } else {
                  specialKey_ = tmpRaw;
                  bitField0_ |= 0x00000004;
                }
                break;
              } // case 24
              case 32: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(4, tmpRaw);
                } else {
                  ensureModifierKeysIsMutable();
                  modifierKeys_.add(tmpRaw);
                }
                break;
              } // case 32
              case 34: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey tmpValue =
                      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(4, tmpRaw);
                  } else {
                    ensureModifierKeysIsMutable();
                    modifierKeys_.add(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 34
              case 42: {
                keyString_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 48: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(6, tmpRaw);
                } else {
                  inputStyle_ = tmpRaw;
                  bitField0_ |= 0x00000020;
                }
                break;
              } // case 48
              case 56: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(7, tmpRaw);
                } else {
                  mode_ = tmpRaw;
                  bitField0_ |= 0x00000040;
                }
                break;
              } // case 56
              case 66: {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent m =
                    input.readMessage(
                        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.PARSER,
                        extensionRegistry);
                if (probableKeyEventBuilder_ == null) {
                  ensureProbableKeyEventIsMutable();
                  probableKeyEvent_.add(m);
                } else {
                  probableKeyEventBuilder_.addMessage(m);
                }
                break;
              } // case 66
              case 72: {
                activated_ = input.readBool();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              case 80: {
                timestampMsec_ = input.readInt64();
                bitField0_ |= 0x00000200;
                break;
              } // case 80
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int keyCode_ ;
      /**
       * <pre>
       * Printable key in UCS4.  If key_code is empty, key_string is used
       * as a raw input.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return Whether the keyCode field is set.
       */
      @java.lang.Override
      public boolean hasKeyCode() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Printable key in UCS4.  If key_code is empty, key_string is used
       * as a raw input.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return The keyCode.
       */
      @java.lang.Override
      public int getKeyCode() {
        return keyCode_;
      }
      /**
       * <pre>
       * Printable key in UCS4.  If key_code is empty, key_string is used
       * as a raw input.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @param value The keyCode to set.
       * @return This builder for chaining.
       */
      public Builder setKeyCode(int value) {
        
        keyCode_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Printable key in UCS4.  If key_code is empty, key_string is used
       * as a raw input.
       * </pre>
       *
       * <code>optional uint32 key_code = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyCode() {
        bitField0_ = (bitField0_ & ~0x00000001);
        keyCode_ = 0;
        onChanged();
        return this;
      }

      private int modifiers_ ;
      /**
       * <pre>
       * Going to be obsolete.
       * </pre>
       *
       * <code>optional uint32 modifiers = 2;</code>
       * @return Whether the modifiers field is set.
       */
      @java.lang.Override
      public boolean hasModifiers() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Going to be obsolete.
       * </pre>
       *
       * <code>optional uint32 modifiers = 2;</code>
       * @return The modifiers.
       */
      @java.lang.Override
      public int getModifiers() {
        return modifiers_;
      }
      /**
       * <pre>
       * Going to be obsolete.
       * </pre>
       *
       * <code>optional uint32 modifiers = 2;</code>
       * @param value The modifiers to set.
       * @return This builder for chaining.
       */
      public Builder setModifiers(int value) {
        
        modifiers_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Going to be obsolete.
       * </pre>
       *
       * <code>optional uint32 modifiers = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearModifiers() {
        bitField0_ = (bitField0_ & ~0x00000002);
        modifiers_ = 0;
        onChanged();
        return this;
      }

      private int specialKey_ = 0;
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return Whether the specialKey field is set.
       */
      @java.lang.Override public boolean hasSpecialKey() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return The specialKey.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey getSpecialKey() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.forNumber(specialKey_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey.NO_SPECIALKEY : result;
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @param value The specialKey to set.
       * @return This builder for chaining.
       */
      public Builder setSpecialKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.SpecialKey value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        specialKey_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Unprintable key listed above.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpecialKey() {
        bitField0_ = (bitField0_ & ~0x00000004);
        specialKey_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> modifierKeys_ =
        java.util.Collections.emptyList();
      private void ensureModifierKeysIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          modifierKeys_ = new java.util.ArrayList<java.lang.Integer>(modifierKeys_);
          bitField0_ |= 0x00000008;
        }
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return A list containing the modifierKeys.
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> getModifierKeysList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey>(modifierKeys_, modifierKeys_converter_);
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return The count of modifierKeys.
       */
      public int getModifierKeysCount() {
        return modifierKeys_.size();
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param index The index of the element to return.
       * @return The modifierKeys at the given index.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey getModifierKeys(int index) {
        return modifierKeys_converter_.convert(modifierKeys_.get(index));
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param index The index to set the value at.
       * @param value The modifierKeys to set.
       * @return This builder for chaining.
       */
      public Builder setModifierKeys(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureModifierKeysIsMutable();
        modifierKeys_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param value The modifierKeys to add.
       * @return This builder for chaining.
       */
      public Builder addModifierKeys(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureModifierKeysIsMutable();
        modifierKeys_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @param values The modifierKeys to add.
       * @return This builder for chaining.
       */
      public Builder addAllModifierKeys(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey> values) {
        ensureModifierKeysIsMutable();
        for (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ModifierKey value : values) {
          modifierKeys_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ModifierKeys
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearModifierKeys() {
        modifierKeys_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }

      private java.lang.Object keyString_ = "";
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @return Whether the keyString field is set.
       */
      public boolean hasKeyString() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @return The keyString.
       */
      public java.lang.String getKeyString() {
        java.lang.Object ref = keyString_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            keyString_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @return The bytes for keyString.
       */
      public com.google.protobuf.ByteString
          getKeyStringBytes() {
        java.lang.Object ref = keyString_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          keyString_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @param value The keyString to set.
       * @return This builder for chaining.
       */
      public Builder setKeyString(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        keyString_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyString() {
        keyString_ = getDefaultInstance().getKeyString();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * String used for preedit.  Kana characters and strings typed from
       * a software keyboard are supposed to be stored here.  If key_code
       * is also set, key_code is treated as the raw input and key_string is
       * treated as the composition input.  For example, to set Kana value,
       * when key_string is "ち", key_code should be 'a' (97).  If key_code
       * is empty, key_string is also treated as the raw input.
       * </pre>
       *
       * <code>optional string key_string = 5;</code>
       * @param value The bytes for keyString to set.
       * @return This builder for chaining.
       */
      public Builder setKeyStringBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        keyString_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private int inputStyle_ = 0;
      /**
       * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
       * @return Whether the inputStyle field is set.
       */
      @java.lang.Override public boolean hasInputStyle() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
       * @return The inputStyle.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle getInputStyle() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle.forNumber(inputStyle_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle.FOLLOW_MODE : result;
      }
      /**
       * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
       * @param value The inputStyle to set.
       * @return This builder for chaining.
       */
      public Builder setInputStyle(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.InputStyle value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        inputStyle_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];</code>
       * @return This builder for chaining.
       */
      public Builder clearInputStyle() {
        bitField0_ = (bitField0_ & ~0x00000020);
        inputStyle_ = 0;
        onChanged();
        return this;
      }

      private int mode_ = 0;
      /**
       * <pre>
       * Input mode
       * For histrical reasons, this field expects a temporary conversion
       * mode rather than comeback input mode.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
       * @return Whether the mode field is set.
       */
      @java.lang.Override public boolean hasMode() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Input mode
       * For histrical reasons, this field expects a temporary conversion
       * mode rather than comeback input mode.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
       * @return The mode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(mode_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
      }
      /**
       * <pre>
       * Input mode
       * For histrical reasons, this field expects a temporary conversion
       * mode rather than comeback input mode.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
       * @param value The mode to set.
       * @return This builder for chaining.
       */
      public Builder setMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000040;
        mode_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Input mode
       * For histrical reasons, this field expects a temporary conversion
       * mode rather than comeback input mode.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearMode() {
        bitField0_ = (bitField0_ & ~0x00000040);
        mode_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> probableKeyEvent_ =
        java.util.Collections.emptyList();
      private void ensureProbableKeyEventIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          probableKeyEvent_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent>(probableKeyEvent_);
          bitField0_ |= 0x00000080;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder> probableKeyEventBuilder_;

      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> getProbableKeyEventList() {
        if (probableKeyEventBuilder_ == null) {
          return java.util.Collections.unmodifiableList(probableKeyEvent_);
        } else {
          return probableKeyEventBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public int getProbableKeyEventCount() {
        if (probableKeyEventBuilder_ == null) {
          return probableKeyEvent_.size();
        } else {
          return probableKeyEventBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent getProbableKeyEvent(int index) {
        if (probableKeyEventBuilder_ == null) {
          return probableKeyEvent_.get(index);
        } else {
          return probableKeyEventBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder setProbableKeyEvent(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent value) {
        if (probableKeyEventBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureProbableKeyEventIsMutable();
          probableKeyEvent_.set(index, value);
          onChanged();
        } else {
          probableKeyEventBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder setProbableKeyEvent(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder builderForValue) {
        if (probableKeyEventBuilder_ == null) {
          ensureProbableKeyEventIsMutable();
          probableKeyEvent_.set(index, builderForValue.build());
          onChanged();
        } else {
          probableKeyEventBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addProbableKeyEvent(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent value) {
        if (probableKeyEventBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureProbableKeyEventIsMutable();
          probableKeyEvent_.add(value);
          onChanged();
        } else {
          probableKeyEventBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addProbableKeyEvent(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent value) {
        if (probableKeyEventBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureProbableKeyEventIsMutable();
          probableKeyEvent_.add(index, value);
          onChanged();
        } else {
          probableKeyEventBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addProbableKeyEvent(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder builderForValue) {
        if (probableKeyEventBuilder_ == null) {
          ensureProbableKeyEventIsMutable();
          probableKeyEvent_.add(builderForValue.build());
          onChanged();
        } else {
          probableKeyEventBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addProbableKeyEvent(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder builderForValue) {
        if (probableKeyEventBuilder_ == null) {
          ensureProbableKeyEventIsMutable();
          probableKeyEvent_.add(index, builderForValue.build());
          onChanged();
        } else {
          probableKeyEventBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder addAllProbableKeyEvent(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent> values) {
        if (probableKeyEventBuilder_ == null) {
          ensureProbableKeyEventIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, probableKeyEvent_);
          onChanged();
        } else {
          probableKeyEventBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder clearProbableKeyEvent() {
        if (probableKeyEventBuilder_ == null) {
          probableKeyEvent_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          probableKeyEventBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public Builder removeProbableKeyEvent(int index) {
        if (probableKeyEventBuilder_ == null) {
          ensureProbableKeyEventIsMutable();
          probableKeyEvent_.remove(index);
          onChanged();
        } else {
          probableKeyEventBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder getProbableKeyEventBuilder(
          int index) {
        return getProbableKeyEventFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder getProbableKeyEventOrBuilder(
          int index) {
        if (probableKeyEventBuilder_ == null) {
          return probableKeyEvent_.get(index);  } else {
          return probableKeyEventBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder> 
           getProbableKeyEventOrBuilderList() {
        if (probableKeyEventBuilder_ != null) {
          return probableKeyEventBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(probableKeyEvent_);
        }
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder addProbableKeyEventBuilder() {
        return getProbableKeyEventFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.getDefaultInstance());
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder addProbableKeyEventBuilder(
          int index) {
        return getProbableKeyEventFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.getDefaultInstance());
      }
      /**
       * <pre>
       * Probable key events
       * Even if you can fill this field,
       * don't omit Input.key_code and so on
       * because preedit string is composed based on them.
       * </pre>
       *
       * <code>repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder> 
           getProbableKeyEventBuilderList() {
        return getProbableKeyEventFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder> 
          getProbableKeyEventFieldBuilder() {
        if (probableKeyEventBuilder_ == null) {
          probableKeyEventBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.ProbableKeyEventOrBuilder>(
                  probableKeyEvent_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          probableKeyEvent_ = null;
        }
        return probableKeyEventBuilder_;
      }

      private boolean activated_ ;
      /**
       * <pre>
       * IME on/off mode
       * You can use this field to change the IME on/off mode indirectly without
       * sending SpecialKey:ON or SpecialKey:OFF events.
       * If the internal ImeContext::State is DIRECT and this field is true, the
       * converter will change the state to PRECONPOSITION and then handles this key
       * event.
       * If the internal ImeContext::State is not DIRECT and this field is false,
       * the converter will change the state to DIRECT and then handles this key
       * event.
       * Implementation note: We need both |mode| and |activated| to support
       * indirect IME off, where |mode| should contain the next mode. If this field
       * is not set, the server will act as if indirect on/off was not supported.
       * </pre>
       *
       * <code>optional bool activated = 9;</code>
       * @return Whether the activated field is set.
       */
      @java.lang.Override
      public boolean hasActivated() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * IME on/off mode
       * You can use this field to change the IME on/off mode indirectly without
       * sending SpecialKey:ON or SpecialKey:OFF events.
       * If the internal ImeContext::State is DIRECT and this field is true, the
       * converter will change the state to PRECONPOSITION and then handles this key
       * event.
       * If the internal ImeContext::State is not DIRECT and this field is false,
       * the converter will change the state to DIRECT and then handles this key
       * event.
       * Implementation note: We need both |mode| and |activated| to support
       * indirect IME off, where |mode| should contain the next mode. If this field
       * is not set, the server will act as if indirect on/off was not supported.
       * </pre>
       *
       * <code>optional bool activated = 9;</code>
       * @return The activated.
       */
      @java.lang.Override
      public boolean getActivated() {
        return activated_;
      }
      /**
       * <pre>
       * IME on/off mode
       * You can use this field to change the IME on/off mode indirectly without
       * sending SpecialKey:ON or SpecialKey:OFF events.
       * If the internal ImeContext::State is DIRECT and this field is true, the
       * converter will change the state to PRECONPOSITION and then handles this key
       * event.
       * If the internal ImeContext::State is not DIRECT and this field is false,
       * the converter will change the state to DIRECT and then handles this key
       * event.
       * Implementation note: We need both |mode| and |activated| to support
       * indirect IME off, where |mode| should contain the next mode. If this field
       * is not set, the server will act as if indirect on/off was not supported.
       * </pre>
       *
       * <code>optional bool activated = 9;</code>
       * @param value The activated to set.
       * @return This builder for chaining.
       */
      public Builder setActivated(boolean value) {
        
        activated_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * IME on/off mode
       * You can use this field to change the IME on/off mode indirectly without
       * sending SpecialKey:ON or SpecialKey:OFF events.
       * If the internal ImeContext::State is DIRECT and this field is true, the
       * converter will change the state to PRECONPOSITION and then handles this key
       * event.
       * If the internal ImeContext::State is not DIRECT and this field is false,
       * the converter will change the state to DIRECT and then handles this key
       * event.
       * Implementation note: We need both |mode| and |activated| to support
       * indirect IME off, where |mode| should contain the next mode. If this field
       * is not set, the server will act as if indirect on/off was not supported.
       * </pre>
       *
       * <code>optional bool activated = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearActivated() {
        bitField0_ = (bitField0_ & ~0x00000100);
        activated_ = false;
        onChanged();
        return this;
      }

      private long timestampMsec_ ;
      /**
       * <pre>
       * Timestamp of this key event in millisecond.
       * </pre>
       *
       * <code>optional int64 timestamp_msec = 10;</code>
       * @return Whether the timestampMsec field is set.
       */
      @java.lang.Override
      public boolean hasTimestampMsec() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Timestamp of this key event in millisecond.
       * </pre>
       *
       * <code>optional int64 timestamp_msec = 10;</code>
       * @return The timestampMsec.
       */
      @java.lang.Override
      public long getTimestampMsec() {
        return timestampMsec_;
      }
      /**
       * <pre>
       * Timestamp of this key event in millisecond.
       * </pre>
       *
       * <code>optional int64 timestamp_msec = 10;</code>
       * @param value The timestampMsec to set.
       * @return This builder for chaining.
       */
      public Builder setTimestampMsec(long value) {
        
        timestampMsec_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timestamp of this key event in millisecond.
       * </pre>
       *
       * <code>optional int64 timestamp_msec = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimestampMsec() {
        bitField0_ = (bitField0_ & ~0x00000200);
        timestampMsec_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.KeyEvent)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<KeyEvent>
        PARSER = new com.google.protobuf.AbstractParser<KeyEvent>() {
      @java.lang.Override
      public KeyEvent parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<KeyEvent> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<KeyEvent> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SessionCommandOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.SessionCommand)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     * @return The type.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType getType();

    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     * @return The id.
     */
    int getId();

    /**
     * <pre>
     * This is used with SWITCH_INPUT_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     * @return Whether the compositionMode field is set.
     */
    boolean hasCompositionMode();
    /**
     * <pre>
     * This is used with SWITCH_INPUT_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     * @return The compositionMode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getCompositionMode();

    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return Whether the text field is set.
     */
    boolean hasText();
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return The text.
     */
    java.lang.String getText();
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return The bytes for text.
     */
    com.google.protobuf.ByteString
        getTextBytes();

    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     * @return Whether the cursorPosition field is set.
     */
    boolean hasCursorPosition();
    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     * @return The cursorPosition.
     */
    int getCursorPosition();

    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> 
        getCompositionEventsList();
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getCompositionEvents(int index);
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    int getCompositionEventsCount();
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder> 
        getCompositionEventsOrBuilderList();
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder getCompositionEventsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code mozc.commands.SessionCommand}
   */
  public static final class SessionCommand extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.SessionCommand)
      SessionCommandOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SessionCommand.newBuilder() to construct.
    private SessionCommand(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SessionCommand() {
      type_ = 0;
      compositionMode_ = 0;
      text_ = "";
      compositionEvents_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SessionCommand();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder.class);
    }

    /**
     * Protobuf enum {@code mozc.commands.SessionCommand.CommandType}
     */
    public enum CommandType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Do nothing.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      NONE(0),
      /**
       * <pre>
       * Revert the session, this is usually similar to type ESC several times.
       * </pre>
       *
       * <code>REVERT = 1;</code>
       */
      REVERT(1),
      /**
       * <pre>
       * Commit the session, this is usually similar to type Enter.
       * SUBMIT session command is accepted in any status.
       * Pre-condition:
       * - Any states of IME are acceptable.
       * Post-condition:
       * - Preedit text becomes empty.
       * </pre>
       *
       * <code>SUBMIT = 2;</code>
       */
      SUBMIT(2),
      /**
       * <pre>
       * Select the specified candidate word by id. This command is
       * usually used with mouse clicking.
       * </pre>
       *
       * <code>SELECT_CANDIDATE = 3;</code>
       */
      SELECT_CANDIDATE(3),
      /**
       * <pre>
       * Set the focus to the candidate by id. This is usually used
       * with mouse dragging or selection of word usage dictionary.
       * The difference from SELECT_CANDIDATE is that
       * HIGHLIGHT_CANDIDATE does not close the candidate window
       * while SELECT_CANDIDATE closes the candidate window.
       * </pre>
       *
       * <code>HIGHLIGHT_CANDIDATE = 4;</code>
       */
      HIGHLIGHT_CANDIDATE(4),
      /**
       * <pre>
       * Specify the input mode.  This command should be used with
       * composition_mode.
       * </pre>
       *
       * <code>SWITCH_INPUT_MODE = 5;</code>
       */
      SWITCH_INPUT_MODE(5),
      /**
       * <pre>
       * Return the current status such as composition mode, preedit method, etc.
       * </pre>
       *
       * <code>GET_STATUS = 6;</code>
       */
      GET_STATUS(6),
      /**
       * <pre>
       * This command is typically used for mobile IME's partial conversion,
       * but currently it is on the way. This description is for current spec.
       * This command requires that candidates exist.
       * If there is a focused candidate (Conversion or Prediction state),
       * the candidate matched with the given id in the first segment is
       * submitted, even though the selected segment is not the first segment
       * (Important thing is whether focused candidate exists
       * or not. Focused index itself is ignored).
       * This behavior should be updated because current cursor position and
       * position of focused segment affects nothing.
       * We should fix this non-intuitive behavior. Intuitive behavior might be
       * submitting segments from first one to focused one (inclusive).
       * If no focused candidate (Suggestion, including ZeroQuery suggestion),
       * first (and only) segment's candidate of which id is equal to id field of
       * Input message is submitted.
       * This behavior should be fixed because current cursor position affects
       * nothing. In future, the characters after the cursor should be kept
       * as preedit.
       * This command's pre- and post- conditions are differenct from
       * SUBMIT command's. Following conditions will be kept after updating
       * the behavior.
       * Pre-condition:
       * - There should be candidate.
       * Post-condition:
       * - No guarantee on preedit text.
       * TODO(yamaguchi): Update corresponding implementation please.
       * </pre>
       *
       * <code>SUBMIT_CANDIDATE = 7;</code>
       */
      SUBMIT_CANDIDATE(7),
      /**
       * <pre>
       * Perform reverse conversion.
       * </pre>
       *
       * <code>CONVERT_REVERSE = 8;</code>
       */
      CONVERT_REVERSE(8),
      /**
       * <pre>
       * Perform Undo.
       * </pre>
       *
       * <code>UNDO = 9;</code>
       */
      UNDO(9),
      /**
       * <pre>
       * Reset convert history and revert current composition.
       * This is usually used by moving cursor with mouse clicking.
       * </pre>
       *
       * <code>RESET_CONTEXT = 10;</code>
       */
      RESET_CONTEXT(10),
      /**
       * <pre>
       * Change cursor position in preedit.
       * </pre>
       *
       * <code>MOVE_CURSOR = 11;</code>
       */
      MOVE_CURSOR(11),
      /**
       * <pre>
       * Specify the input field type.
       * </pre>
       *
       * <code>SWITCH_INPUT_FIELD_TYPE = 12;</code>
       */
      SWITCH_INPUT_FIELD_TYPE(12),
      /**
       * <pre>
       * This command is used in only Android.
       * Works UNDO or rewind HIRAGANA characters based on the state.
       * </pre>
       *
       * <code>UNDO_OR_REWIND = 14;</code>
       */
      UNDO_OR_REWIND(14),
      /**
       * <pre>
       * Commit the raw text of the composed string.
       * </pre>
       *
       * <code>COMMIT_RAW_TEXT = 19;</code>
       */
      COMMIT_RAW_TEXT(19),
      /**
       * <pre>
       * Call ConvertPrevPage session command to show the previous page of
       * candidates.
       * </pre>
       *
       * <code>CONVERT_PREV_PAGE = 20;</code>
       */
      CONVERT_PREV_PAGE(20),
      /**
       * <pre>
       * Call ConvertNextPage session command to show the next page of
       * candidates.
       * </pre>
       *
       * <code>CONVERT_NEXT_PAGE = 21;</code>
       */
      CONVERT_NEXT_PAGE(21),
      /**
       * <pre>
       * Make sure IME is turned on. Optionally you can also provide new input
       * mode in |composition_mode| (but you must not set DIRECT to it).
       * |composition_mode| is honored even when IME is already turned on.
       * </pre>
       *
       * <code>TURN_ON_IME = 22;</code>
       */
      TURN_ON_IME(22),
      /**
       * <pre>
       * Make sure IME is turned off. Optionally you can also provide new input
       * mode in |composition_mode| (but you must not set DIRECT to it). If IME
       * |composition_mode| is honored even when IME is already turned off.
       * </pre>
       *
       * <code>TURN_OFF_IME = 23;</code>
       */
      TURN_OFF_IME(23),
      /**
       * <pre>
       * Delete the candidate specified with |id = 2| from the user history.
       * </pre>
       *
       * <code>DELETE_CANDIDATE_FROM_HISTORY = 24;</code>
       */
      DELETE_CANDIDATE_FROM_HISTORY(24),
      /**
       * <pre>
       * Stops key toggling of the composer if its table is a toggle-supported
       * layout (e.g., 12-key toggle flick.)
       * </pre>
       *
       * <code>STOP_KEY_TOGGLING = 25;</code>
       */
      STOP_KEY_TOGGLING(25),
      /**
       * <pre>
       * Update composition with |compoisition_events|.
       * Unlike SEND_KEY command, this command completely replaces the composition
       * rather than appending to the existing composition.
       * The command will be used for supporting handwriting.
       * </pre>
       *
       * <code>UPDATE_COMPOSITION = 26;</code>
       */
      UPDATE_COMPOSITION(26),
      ;

      /**
       * <pre>
       * Do nothing.
       * </pre>
       *
       * <code>NONE = 0;</code>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <pre>
       * Revert the session, this is usually similar to type ESC several times.
       * </pre>
       *
       * <code>REVERT = 1;</code>
       */
      public static final int REVERT_VALUE = 1;
      /**
       * <pre>
       * Commit the session, this is usually similar to type Enter.
       * SUBMIT session command is accepted in any status.
       * Pre-condition:
       * - Any states of IME are acceptable.
       * Post-condition:
       * - Preedit text becomes empty.
       * </pre>
       *
       * <code>SUBMIT = 2;</code>
       */
      public static final int SUBMIT_VALUE = 2;
      /**
       * <pre>
       * Select the specified candidate word by id. This command is
       * usually used with mouse clicking.
       * </pre>
       *
       * <code>SELECT_CANDIDATE = 3;</code>
       */
      public static final int SELECT_CANDIDATE_VALUE = 3;
      /**
       * <pre>
       * Set the focus to the candidate by id. This is usually used
       * with mouse dragging or selection of word usage dictionary.
       * The difference from SELECT_CANDIDATE is that
       * HIGHLIGHT_CANDIDATE does not close the candidate window
       * while SELECT_CANDIDATE closes the candidate window.
       * </pre>
       *
       * <code>HIGHLIGHT_CANDIDATE = 4;</code>
       */
      public static final int HIGHLIGHT_CANDIDATE_VALUE = 4;
      /**
       * <pre>
       * Specify the input mode.  This command should be used with
       * composition_mode.
       * </pre>
       *
       * <code>SWITCH_INPUT_MODE = 5;</code>
       */
      public static final int SWITCH_INPUT_MODE_VALUE = 5;
      /**
       * <pre>
       * Return the current status such as composition mode, preedit method, etc.
       * </pre>
       *
       * <code>GET_STATUS = 6;</code>
       */
      public static final int GET_STATUS_VALUE = 6;
      /**
       * <pre>
       * This command is typically used for mobile IME's partial conversion,
       * but currently it is on the way. This description is for current spec.
       * This command requires that candidates exist.
       * If there is a focused candidate (Conversion or Prediction state),
       * the candidate matched with the given id in the first segment is
       * submitted, even though the selected segment is not the first segment
       * (Important thing is whether focused candidate exists
       * or not. Focused index itself is ignored).
       * This behavior should be updated because current cursor position and
       * position of focused segment affects nothing.
       * We should fix this non-intuitive behavior. Intuitive behavior might be
       * submitting segments from first one to focused one (inclusive).
       * If no focused candidate (Suggestion, including ZeroQuery suggestion),
       * first (and only) segment's candidate of which id is equal to id field of
       * Input message is submitted.
       * This behavior should be fixed because current cursor position affects
       * nothing. In future, the characters after the cursor should be kept
       * as preedit.
       * This command's pre- and post- conditions are differenct from
       * SUBMIT command's. Following conditions will be kept after updating
       * the behavior.
       * Pre-condition:
       * - There should be candidate.
       * Post-condition:
       * - No guarantee on preedit text.
       * TODO(yamaguchi): Update corresponding implementation please.
       * </pre>
       *
       * <code>SUBMIT_CANDIDATE = 7;</code>
       */
      public static final int SUBMIT_CANDIDATE_VALUE = 7;
      /**
       * <pre>
       * Perform reverse conversion.
       * </pre>
       *
       * <code>CONVERT_REVERSE = 8;</code>
       */
      public static final int CONVERT_REVERSE_VALUE = 8;
      /**
       * <pre>
       * Perform Undo.
       * </pre>
       *
       * <code>UNDO = 9;</code>
       */
      public static final int UNDO_VALUE = 9;
      /**
       * <pre>
       * Reset convert history and revert current composition.
       * This is usually used by moving cursor with mouse clicking.
       * </pre>
       *
       * <code>RESET_CONTEXT = 10;</code>
       */
      public static final int RESET_CONTEXT_VALUE = 10;
      /**
       * <pre>
       * Change cursor position in preedit.
       * </pre>
       *
       * <code>MOVE_CURSOR = 11;</code>
       */
      public static final int MOVE_CURSOR_VALUE = 11;
      /**
       * <pre>
       * Specify the input field type.
       * </pre>
       *
       * <code>SWITCH_INPUT_FIELD_TYPE = 12;</code>
       */
      public static final int SWITCH_INPUT_FIELD_TYPE_VALUE = 12;
      /**
       * <pre>
       * This command is used in only Android.
       * Works UNDO or rewind HIRAGANA characters based on the state.
       * </pre>
       *
       * <code>UNDO_OR_REWIND = 14;</code>
       */
      public static final int UNDO_OR_REWIND_VALUE = 14;
      /**
       * <pre>
       * Commit the raw text of the composed string.
       * </pre>
       *
       * <code>COMMIT_RAW_TEXT = 19;</code>
       */
      public static final int COMMIT_RAW_TEXT_VALUE = 19;
      /**
       * <pre>
       * Call ConvertPrevPage session command to show the previous page of
       * candidates.
       * </pre>
       *
       * <code>CONVERT_PREV_PAGE = 20;</code>
       */
      public static final int CONVERT_PREV_PAGE_VALUE = 20;
      /**
       * <pre>
       * Call ConvertNextPage session command to show the next page of
       * candidates.
       * </pre>
       *
       * <code>CONVERT_NEXT_PAGE = 21;</code>
       */
      public static final int CONVERT_NEXT_PAGE_VALUE = 21;
      /**
       * <pre>
       * Make sure IME is turned on. Optionally you can also provide new input
       * mode in |composition_mode| (but you must not set DIRECT to it).
       * |composition_mode| is honored even when IME is already turned on.
       * </pre>
       *
       * <code>TURN_ON_IME = 22;</code>
       */
      public static final int TURN_ON_IME_VALUE = 22;
      /**
       * <pre>
       * Make sure IME is turned off. Optionally you can also provide new input
       * mode in |composition_mode| (but you must not set DIRECT to it). If IME
       * |composition_mode| is honored even when IME is already turned off.
       * </pre>
       *
       * <code>TURN_OFF_IME = 23;</code>
       */
      public static final int TURN_OFF_IME_VALUE = 23;
      /**
       * <pre>
       * Delete the candidate specified with |id = 2| from the user history.
       * </pre>
       *
       * <code>DELETE_CANDIDATE_FROM_HISTORY = 24;</code>
       */
      public static final int DELETE_CANDIDATE_FROM_HISTORY_VALUE = 24;
      /**
       * <pre>
       * Stops key toggling of the composer if its table is a toggle-supported
       * layout (e.g., 12-key toggle flick.)
       * </pre>
       *
       * <code>STOP_KEY_TOGGLING = 25;</code>
       */
      public static final int STOP_KEY_TOGGLING_VALUE = 25;
      /**
       * <pre>
       * Update composition with |compoisition_events|.
       * Unlike SEND_KEY command, this command completely replaces the composition
       * rather than appending to the existing composition.
       * The command will be used for supporting handwriting.
       * </pre>
       *
       * <code>UPDATE_COMPOSITION = 26;</code>
       */
      public static final int UPDATE_COMPOSITION_VALUE = 26;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CommandType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static CommandType forNumber(int value) {
        switch (value) {
          case 0: return NONE;
          case 1: return REVERT;
          case 2: return SUBMIT;
          case 3: return SELECT_CANDIDATE;
          case 4: return HIGHLIGHT_CANDIDATE;
          case 5: return SWITCH_INPUT_MODE;
          case 6: return GET_STATUS;
          case 7: return SUBMIT_CANDIDATE;
          case 8: return CONVERT_REVERSE;
          case 9: return UNDO;
          case 10: return RESET_CONTEXT;
          case 11: return MOVE_CURSOR;
          case 12: return SWITCH_INPUT_FIELD_TYPE;
          case 14: return UNDO_OR_REWIND;
          case 19: return COMMIT_RAW_TEXT;
          case 20: return CONVERT_PREV_PAGE;
          case 21: return CONVERT_NEXT_PAGE;
          case 22: return TURN_ON_IME;
          case 23: return TURN_OFF_IME;
          case 24: return DELETE_CANDIDATE_FROM_HISTORY;
          case 25: return STOP_KEY_TOGGLING;
          case 26: return UPDATE_COMPOSITION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CommandType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CommandType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CommandType>() {
              public CommandType findValueByNumber(int number) {
                return CommandType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDescriptor().getEnumTypes().get(0);
      }

      private static final CommandType[] VALUES = values();

      public static CommandType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private CommandType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.SessionCommand.CommandType)
    }

    public interface CompositionEventOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.SessionCommand.CompositionEvent)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional string composition_string = 1;</code>
       * @return Whether the compositionString field is set.
       */
      boolean hasCompositionString();
      /**
       * <code>optional string composition_string = 1;</code>
       * @return The compositionString.
       */
      java.lang.String getCompositionString();
      /**
       * <code>optional string composition_string = 1;</code>
       * @return The bytes for compositionString.
       */
      com.google.protobuf.ByteString
          getCompositionStringBytes();

      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       * @return Whether the probability field is set.
       */
      boolean hasProbability();
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       * @return The probability.
       */
      double getProbability();
    }
    /**
     * <pre>
     * Used by UPDATE_COMPOSITION event
     * </pre>
     *
     * Protobuf type {@code mozc.commands.SessionCommand.CompositionEvent}
     */
    public static final class CompositionEvent extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.commands.SessionCommand.CompositionEvent)
        CompositionEventOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use CompositionEvent.newBuilder() to construct.
      private CompositionEvent(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private CompositionEvent() {
        compositionString_ = "";
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new CompositionEvent();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_CompositionEvent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_CompositionEvent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder.class);
      }

      private int bitField0_;
      public static final int COMPOSITION_STRING_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private volatile java.lang.Object compositionString_ = "";
      /**
       * <code>optional string composition_string = 1;</code>
       * @return Whether the compositionString field is set.
       */
      @java.lang.Override
      public boolean hasCompositionString() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string composition_string = 1;</code>
       * @return The compositionString.
       */
      @java.lang.Override
      public java.lang.String getCompositionString() {
        java.lang.Object ref = compositionString_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            compositionString_ = s;
          }
          return s;
        }
      }
      /**
       * <code>optional string composition_string = 1;</code>
       * @return The bytes for compositionString.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getCompositionStringBytes() {
        java.lang.Object ref = compositionString_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          compositionString_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int PROBABILITY_FIELD_NUMBER = 2;
      private double probability_ = 0D;
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       * @return Whether the probability field is set.
       */
      @java.lang.Override
      public boolean hasProbability() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Sum of probabilities must be lesser or equal than 1.
       * 0&lt;= probability &lt;= 1
       * </pre>
       *
       * <code>optional double probability = 2;</code>
       * @return The probability.
       */
      @java.lang.Override
      public double getProbability() {
        return probability_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, compositionString_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeDouble(2, probability_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, compositionString_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeDoubleSize(2, probability_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent) obj;

        if (hasCompositionString() != other.hasCompositionString()) return false;
        if (hasCompositionString()) {
          if (!getCompositionString()
              .equals(other.getCompositionString())) return false;
        }
        if (hasProbability() != other.hasProbability()) return false;
        if (hasProbability()) {
          if (java.lang.Double.doubleToLongBits(getProbability())
              != java.lang.Double.doubleToLongBits(
                  other.getProbability())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasCompositionString()) {
          hash = (37 * hash) + COMPOSITION_STRING_FIELD_NUMBER;
          hash = (53 * hash) + getCompositionString().hashCode();
        }
        if (hasProbability()) {
          hash = (37 * hash) + PROBABILITY_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              java.lang.Double.doubleToLongBits(getProbability()));
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Used by UPDATE_COMPOSITION event
       * </pre>
       *
       * Protobuf type {@code mozc.commands.SessionCommand.CompositionEvent}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.SessionCommand.CompositionEvent)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_CompositionEvent_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_CompositionEvent_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          compositionString_ = "";
          probability_ = 0D;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_CompositionEvent_descriptor;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.getDefaultInstance();
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.compositionString_ = compositionString_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.probability_ = probability_;
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.getDefaultInstance()) return this;
          if (other.hasCompositionString()) {
            compositionString_ = other.compositionString_;
            bitField0_ |= 0x00000001;
            onChanged();
          }
          if (other.hasProbability()) {
            setProbability(other.getProbability());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  compositionString_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 17: {
                  probability_ = input.readDouble();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 17
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.lang.Object compositionString_ = "";
        /**
         * <code>optional string composition_string = 1;</code>
         * @return Whether the compositionString field is set.
         */
        public boolean hasCompositionString() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @return The compositionString.
         */
        public java.lang.String getCompositionString() {
          java.lang.Object ref = compositionString_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              compositionString_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @return The bytes for compositionString.
         */
        public com.google.protobuf.ByteString
            getCompositionStringBytes() {
          java.lang.Object ref = compositionString_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            compositionString_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @param value The compositionString to set.
         * @return This builder for chaining.
         */
        public Builder setCompositionString(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          compositionString_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearCompositionString() {
          compositionString_ = getDefaultInstance().getCompositionString();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <code>optional string composition_string = 1;</code>
         * @param value The bytes for compositionString to set.
         * @return This builder for chaining.
         */
        public Builder setCompositionStringBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          compositionString_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        private double probability_ ;
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 2;</code>
         * @return Whether the probability field is set.
         */
        @java.lang.Override
        public boolean hasProbability() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 2;</code>
         * @return The probability.
         */
        @java.lang.Override
        public double getProbability() {
          return probability_;
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 2;</code>
         * @param value The probability to set.
         * @return This builder for chaining.
         */
        public Builder setProbability(double value) {
          
          probability_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Sum of probabilities must be lesser or equal than 1.
         * 0&lt;= probability &lt;= 1
         * </pre>
         *
         * <code>optional double probability = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearProbability() {
          bitField0_ = (bitField0_ & ~0x00000002);
          probability_ = 0D;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.commands.SessionCommand.CompositionEvent)
      }

      // @@protoc_insertion_point(class_scope:mozc.commands.SessionCommand.CompositionEvent)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<CompositionEvent>
          PARSER = new com.google.protobuf.AbstractParser<CompositionEvent>() {
        @java.lang.Override
        public CompositionEvent parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<CompositionEvent> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<CompositionEvent> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 0;
    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType getType() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType.forNumber(type_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType.NONE : result;
    }

    public static final int ID_FIELD_NUMBER = 2;
    private int id_ = 0;
    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Unique number specifying a candidate word.
     * Note: This value is NOT an index of the candidate window or the candidate
     * list. This value is a return value of CandidateWord::id().
     * </pre>
     *
     * <code>optional int32 id = 2;</code>
     * @return The id.
     */
    @java.lang.Override
    public int getId() {
      return id_;
    }

    public static final int COMPOSITION_MODE_FIELD_NUMBER = 3;
    private int compositionMode_ = 0;
    /**
     * <pre>
     * This is used with SWITCH_INPUT_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     * @return Whether the compositionMode field is set.
     */
    @java.lang.Override public boolean hasCompositionMode() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * This is used with SWITCH_INPUT_MODE, TURN_ON_IME and TURN_OFF_IME.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
     * @return The compositionMode.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getCompositionMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(compositionMode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }

    public static final int TEXT_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object text_ = "";
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return Whether the text field is set.
     */
    @java.lang.Override
    public boolean hasText() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return The text.
     */
    @java.lang.Override
    public java.lang.String getText() {
      java.lang.Object ref = text_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          text_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Text argument.  This is used by CONVERT_REVERSE at this moment.
     * </pre>
     *
     * <code>optional string text = 4;</code>
     * @return The bytes for text.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTextBytes() {
      java.lang.Object ref = text_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        text_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CURSOR_POSITION_FIELD_NUMBER = 5;
    private int cursorPosition_ = 0;
    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     * @return Whether the cursorPosition field is set.
     */
    @java.lang.Override
    public boolean hasCursorPosition() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * New cursor position in preedit. Used with MOVE_CURSOR.
     * </pre>
     *
     * <code>optional uint32 cursor_position = 5;</code>
     * @return The cursorPosition.
     */
    @java.lang.Override
    public int getCursorPosition() {
      return cursorPosition_;
    }

    public static final int COMPOSITION_EVENTS_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> compositionEvents_;
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> getCompositionEventsList() {
      return compositionEvents_;
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder> 
        getCompositionEventsOrBuilderList() {
      return compositionEvents_;
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    @java.lang.Override
    public int getCompositionEventsCount() {
      return compositionEvents_.size();
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getCompositionEvents(int index) {
      return compositionEvents_.get(index);
    }
    /**
     * <pre>
     * Assumes that the entries are sorted by the probability.
     * The most probable event should be at the top.
     * </pre>
     *
     * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder getCompositionEventsOrBuilder(
        int index) {
      return compositionEvents_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, id_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeEnum(3, compositionMode_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, text_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt32(5, cursorPosition_);
      }
      for (int i = 0; i < compositionEvents_.size(); i++) {
        output.writeMessage(11, compositionEvents_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, id_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, compositionMode_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, text_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, cursorPosition_);
      }
      for (int i = 0; i < compositionEvents_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, compositionEvents_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasId() != other.hasId()) return false;
      if (hasId()) {
        if (getId()
            != other.getId()) return false;
      }
      if (hasCompositionMode() != other.hasCompositionMode()) return false;
      if (hasCompositionMode()) {
        if (compositionMode_ != other.compositionMode_) return false;
      }
      if (hasText() != other.hasText()) return false;
      if (hasText()) {
        if (!getText()
            .equals(other.getText())) return false;
      }
      if (hasCursorPosition() != other.hasCursorPosition()) return false;
      if (hasCursorPosition()) {
        if (getCursorPosition()
            != other.getCursorPosition()) return false;
      }
      if (!getCompositionEventsList()
          .equals(other.getCompositionEventsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasId()) {
        hash = (37 * hash) + ID_FIELD_NUMBER;
        hash = (53 * hash) + getId();
      }
      if (hasCompositionMode()) {
        hash = (37 * hash) + COMPOSITION_MODE_FIELD_NUMBER;
        hash = (53 * hash) + compositionMode_;
      }
      if (hasText()) {
        hash = (37 * hash) + TEXT_FIELD_NUMBER;
        hash = (53 * hash) + getText().hashCode();
      }
      if (hasCursorPosition()) {
        hash = (37 * hash) + CURSOR_POSITION_FIELD_NUMBER;
        hash = (53 * hash) + getCursorPosition();
      }
      if (getCompositionEventsCount() > 0) {
        hash = (37 * hash) + COMPOSITION_EVENTS_FIELD_NUMBER;
        hash = (53 * hash) + getCompositionEventsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.commands.SessionCommand}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.SessionCommand)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 0;
        id_ = 0;
        compositionMode_ = 0;
        text_ = "";
        cursorPosition_ = 0;
        if (compositionEventsBuilder_ == null) {
          compositionEvents_ = java.util.Collections.emptyList();
        } else {
          compositionEvents_ = null;
          compositionEventsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_SessionCommand_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand result) {
        if (compositionEventsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            compositionEvents_ = java.util.Collections.unmodifiableList(compositionEvents_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.compositionEvents_ = compositionEvents_;
        } else {
          result.compositionEvents_ = compositionEventsBuilder_.build();
        }
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.id_ = id_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.compositionMode_ = compositionMode_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.text_ = text_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.cursorPosition_ = cursorPosition_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasId()) {
          setId(other.getId());
        }
        if (other.hasCompositionMode()) {
          setCompositionMode(other.getCompositionMode());
        }
        if (other.hasText()) {
          text_ = other.text_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasCursorPosition()) {
          setCursorPosition(other.getCursorPosition());
        }
        if (compositionEventsBuilder_ == null) {
          if (!other.compositionEvents_.isEmpty()) {
            if (compositionEvents_.isEmpty()) {
              compositionEvents_ = other.compositionEvents_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureCompositionEventsIsMutable();
              compositionEvents_.addAll(other.compositionEvents_);
            }
            onChanged();
          }
        } else {
          if (!other.compositionEvents_.isEmpty()) {
            if (compositionEventsBuilder_.isEmpty()) {
              compositionEventsBuilder_.dispose();
              compositionEventsBuilder_ = null;
              compositionEvents_ = other.compositionEvents_;
              bitField0_ = (bitField0_ & ~0x00000020);
              compositionEventsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCompositionEventsFieldBuilder() : null;
            } else {
              compositionEventsBuilder_.addAllMessages(other.compositionEvents_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasType()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  type_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 16: {
                id_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(3, tmpRaw);
                } else {
                  compositionMode_ = tmpRaw;
                  bitField0_ |= 0x00000004;
                }
                break;
              } // case 24
              case 34: {
                text_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 40: {
                cursorPosition_ = input.readUInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 90: {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent m =
                    input.readMessage(
                        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.PARSER,
                        extensionRegistry);
                if (compositionEventsBuilder_ == null) {
                  ensureCompositionEventsIsMutable();
                  compositionEvents_.add(m);
                } else {
                  compositionEventsBuilder_.addMessage(m);
                }
                break;
              } // case 90
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int type_ = 0;
      /**
       * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType getType() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType.forNumber(type_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType.NONE : result;
      }
      /**
       * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CommandType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .mozc.commands.SessionCommand.CommandType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private int id_ ;
      /**
       * <pre>
       * Unique number specifying a candidate word.
       * Note: This value is NOT an index of the candidate window or the candidate
       * list. This value is a return value of CandidateWord::id().
       * </pre>
       *
       * <code>optional int32 id = 2;</code>
       * @return Whether the id field is set.
       */
      @java.lang.Override
      public boolean hasId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Unique number specifying a candidate word.
       * Note: This value is NOT an index of the candidate window or the candidate
       * list. This value is a return value of CandidateWord::id().
       * </pre>
       *
       * <code>optional int32 id = 2;</code>
       * @return The id.
       */
      @java.lang.Override
      public int getId() {
        return id_;
      }
      /**
       * <pre>
       * Unique number specifying a candidate word.
       * Note: This value is NOT an index of the candidate window or the candidate
       * list. This value is a return value of CandidateWord::id().
       * </pre>
       *
       * <code>optional int32 id = 2;</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(int value) {
        
        id_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Unique number specifying a candidate word.
       * Note: This value is NOT an index of the candidate window or the candidate
       * list. This value is a return value of CandidateWord::id().
       * </pre>
       *
       * <code>optional int32 id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        bitField0_ = (bitField0_ & ~0x00000002);
        id_ = 0;
        onChanged();
        return this;
      }

      private int compositionMode_ = 0;
      /**
       * <pre>
       * This is used with SWITCH_INPUT_MODE, TURN_ON_IME and TURN_OFF_IME.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
       * @return Whether the compositionMode field is set.
       */
      @java.lang.Override public boolean hasCompositionMode() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * This is used with SWITCH_INPUT_MODE, TURN_ON_IME and TURN_OFF_IME.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
       * @return The compositionMode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getCompositionMode() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(compositionMode_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
      }
      /**
       * <pre>
       * This is used with SWITCH_INPUT_MODE, TURN_ON_IME and TURN_OFF_IME.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
       * @param value The compositionMode to set.
       * @return This builder for chaining.
       */
      public Builder setCompositionMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        compositionMode_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is used with SWITCH_INPUT_MODE, TURN_ON_IME and TURN_OFF_IME.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode composition_mode = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearCompositionMode() {
        bitField0_ = (bitField0_ & ~0x00000004);
        compositionMode_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object text_ = "";
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @return Whether the text field is set.
       */
      public boolean hasText() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @return The text.
       */
      public java.lang.String getText() {
        java.lang.Object ref = text_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            text_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @return The bytes for text.
       */
      public com.google.protobuf.ByteString
          getTextBytes() {
        java.lang.Object ref = text_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          text_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @param value The text to set.
       * @return This builder for chaining.
       */
      public Builder setText(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        text_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearText() {
        text_ = getDefaultInstance().getText();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Text argument.  This is used by CONVERT_REVERSE at this moment.
       * </pre>
       *
       * <code>optional string text = 4;</code>
       * @param value The bytes for text to set.
       * @return This builder for chaining.
       */
      public Builder setTextBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        text_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private int cursorPosition_ ;
      /**
       * <pre>
       * New cursor position in preedit. Used with MOVE_CURSOR.
       * </pre>
       *
       * <code>optional uint32 cursor_position = 5;</code>
       * @return Whether the cursorPosition field is set.
       */
      @java.lang.Override
      public boolean hasCursorPosition() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * New cursor position in preedit. Used with MOVE_CURSOR.
       * </pre>
       *
       * <code>optional uint32 cursor_position = 5;</code>
       * @return The cursorPosition.
       */
      @java.lang.Override
      public int getCursorPosition() {
        return cursorPosition_;
      }
      /**
       * <pre>
       * New cursor position in preedit. Used with MOVE_CURSOR.
       * </pre>
       *
       * <code>optional uint32 cursor_position = 5;</code>
       * @param value The cursorPosition to set.
       * @return This builder for chaining.
       */
      public Builder setCursorPosition(int value) {
        
        cursorPosition_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * New cursor position in preedit. Used with MOVE_CURSOR.
       * </pre>
       *
       * <code>optional uint32 cursor_position = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCursorPosition() {
        bitField0_ = (bitField0_ & ~0x00000010);
        cursorPosition_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> compositionEvents_ =
        java.util.Collections.emptyList();
      private void ensureCompositionEventsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          compositionEvents_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent>(compositionEvents_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder> compositionEventsBuilder_;

      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> getCompositionEventsList() {
        if (compositionEventsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(compositionEvents_);
        } else {
          return compositionEventsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public int getCompositionEventsCount() {
        if (compositionEventsBuilder_ == null) {
          return compositionEvents_.size();
        } else {
          return compositionEventsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent getCompositionEvents(int index) {
        if (compositionEventsBuilder_ == null) {
          return compositionEvents_.get(index);
        } else {
          return compositionEventsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder setCompositionEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent value) {
        if (compositionEventsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCompositionEventsIsMutable();
          compositionEvents_.set(index, value);
          onChanged();
        } else {
          compositionEventsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder setCompositionEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder builderForValue) {
        if (compositionEventsBuilder_ == null) {
          ensureCompositionEventsIsMutable();
          compositionEvents_.set(index, builderForValue.build());
          onChanged();
        } else {
          compositionEventsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addCompositionEvents(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent value) {
        if (compositionEventsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCompositionEventsIsMutable();
          compositionEvents_.add(value);
          onChanged();
        } else {
          compositionEventsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addCompositionEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent value) {
        if (compositionEventsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCompositionEventsIsMutable();
          compositionEvents_.add(index, value);
          onChanged();
        } else {
          compositionEventsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addCompositionEvents(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder builderForValue) {
        if (compositionEventsBuilder_ == null) {
          ensureCompositionEventsIsMutable();
          compositionEvents_.add(builderForValue.build());
          onChanged();
        } else {
          compositionEventsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addCompositionEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder builderForValue) {
        if (compositionEventsBuilder_ == null) {
          ensureCompositionEventsIsMutable();
          compositionEvents_.add(index, builderForValue.build());
          onChanged();
        } else {
          compositionEventsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder addAllCompositionEvents(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent> values) {
        if (compositionEventsBuilder_ == null) {
          ensureCompositionEventsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, compositionEvents_);
          onChanged();
        } else {
          compositionEventsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder clearCompositionEvents() {
        if (compositionEventsBuilder_ == null) {
          compositionEvents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          compositionEventsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public Builder removeCompositionEvents(int index) {
        if (compositionEventsBuilder_ == null) {
          ensureCompositionEventsIsMutable();
          compositionEvents_.remove(index);
          onChanged();
        } else {
          compositionEventsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder getCompositionEventsBuilder(
          int index) {
        return getCompositionEventsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder getCompositionEventsOrBuilder(
          int index) {
        if (compositionEventsBuilder_ == null) {
          return compositionEvents_.get(index);  } else {
          return compositionEventsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder> 
           getCompositionEventsOrBuilderList() {
        if (compositionEventsBuilder_ != null) {
          return compositionEventsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(compositionEvents_);
        }
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder addCompositionEventsBuilder() {
        return getCompositionEventsFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.getDefaultInstance());
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder addCompositionEventsBuilder(
          int index) {
        return getCompositionEventsFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.getDefaultInstance());
      }
      /**
       * <pre>
       * Assumes that the entries are sorted by the probability.
       * The most probable event should be at the top.
       * </pre>
       *
       * <code>repeated .mozc.commands.SessionCommand.CompositionEvent composition_events = 11;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder> 
           getCompositionEventsBuilderList() {
        return getCompositionEventsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder> 
          getCompositionEventsFieldBuilder() {
        if (compositionEventsBuilder_ == null) {
          compositionEventsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.CompositionEventOrBuilder>(
                  compositionEvents_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          compositionEvents_ = null;
        }
        return compositionEventsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.SessionCommand)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.SessionCommand)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<SessionCommand>
        PARSER = new com.google.protobuf.AbstractParser<SessionCommand>() {
      @java.lang.Override
      public SessionCommand parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SessionCommand> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SessionCommand> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ContextOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Context)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return Whether the precedingText field is set.
     */
    boolean hasPrecedingText();
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return The precedingText.
     */
    java.lang.String getPrecedingText();
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return The bytes for precedingText.
     */
    com.google.protobuf.ByteString
        getPrecedingTextBytes();

    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return Whether the followingText field is set.
     */
    boolean hasFollowingText();
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return The followingText.
     */
    java.lang.String getFollowingText();
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return The bytes for followingText.
     */
    com.google.protobuf.ByteString
        getFollowingTextBytes();

    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     * @return Whether the suppressSuggestion field is set.
     */
    boolean hasSuppressSuggestion();
    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     * @return The suppressSuggestion.
     */
    boolean getSuppressSuggestion();

    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     * @return Whether the inputFieldType field is set.
     */
    boolean hasInputFieldType();
    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     * @return The inputFieldType.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType getInputFieldType();

    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     * @return Whether the revision field is set.
     */
    boolean hasRevision();
    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     * @return The revision.
     */
    int getRevision();

    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @return A list containing the experimentalFeatures.
     */
    java.util.List<java.lang.String>
        getExperimentalFeaturesList();
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @return The count of experimentalFeatures.
     */
    int getExperimentalFeaturesCount();
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param index The index of the element to return.
     * @return The experimentalFeatures at the given index.
     */
    java.lang.String getExperimentalFeatures(int index);
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param index The index of the value to return.
     * @return The bytes of the experimentalFeatures at the given index.
     */
    com.google.protobuf.ByteString
        getExperimentalFeaturesBytes(int index);
  }
  /**
   * Protobuf type {@code mozc.commands.Context}
   */
  public static final class Context extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Context)
      ContextOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Context.newBuilder() to construct.
    private Context(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Context() {
      precedingText_ = "";
      followingText_ = "";
      inputFieldType_ = 1;
      experimentalFeatures_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Context();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Context_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Context_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.Builder.class);
    }

    /**
     * <pre>
     * Input field type.
     * The types are based on the input types defined in HTML5.
     * http://dev.w3.org/html5/spec/Overview.html#attr-input-type
     * Other types are to be added later.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Context.InputFieldType}
     */
    public enum InputFieldType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * No restrictions nor special functions. The IME operates as usual.
       * </pre>
       *
       * <code>NORMAL = 1;</code>
       */
      NORMAL(1),
      /**
       * <pre>
       * Password field. Text is hidden after input.
       * For Android,
       * In order to make the last character visible to the user,
       * the IME must not hold more than 2 characters in preedit.
       * </pre>
       *
       * <code>PASSWORD = 2;</code>
       */
      PASSWORD(2),
      /**
       * <pre>
       * Telephone number
       * </pre>
       *
       * <code>TEL = 3;</code>
       */
      TEL(3),
      /**
       * <pre>
       * Number
       * </pre>
       *
       * <code>NUMBER = 4;</code>
       */
      NUMBER(4),
      ;

      /**
       * <pre>
       * No restrictions nor special functions. The IME operates as usual.
       * </pre>
       *
       * <code>NORMAL = 1;</code>
       */
      public static final int NORMAL_VALUE = 1;
      /**
       * <pre>
       * Password field. Text is hidden after input.
       * For Android,
       * In order to make the last character visible to the user,
       * the IME must not hold more than 2 characters in preedit.
       * </pre>
       *
       * <code>PASSWORD = 2;</code>
       */
      public static final int PASSWORD_VALUE = 2;
      /**
       * <pre>
       * Telephone number
       * </pre>
       *
       * <code>TEL = 3;</code>
       */
      public static final int TEL_VALUE = 3;
      /**
       * <pre>
       * Number
       * </pre>
       *
       * <code>NUMBER = 4;</code>
       */
      public static final int NUMBER_VALUE = 4;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InputFieldType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static InputFieldType forNumber(int value) {
        switch (value) {
          case 1: return NORMAL;
          case 2: return PASSWORD;
          case 3: return TEL;
          case 4: return NUMBER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<InputFieldType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          InputFieldType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<InputFieldType>() {
              public InputFieldType findValueByNumber(int number) {
                return InputFieldType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDescriptor().getEnumTypes().get(0);
      }

      private static final InputFieldType[] VALUES = values();

      public static InputFieldType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private InputFieldType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Context.InputFieldType)
    }

    private int bitField0_;
    public static final int PRECEDING_TEXT_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object precedingText_ = "";
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return Whether the precedingText field is set.
     */
    @java.lang.Override
    public boolean hasPrecedingText() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return The precedingText.
     */
    @java.lang.Override
    public java.lang.String getPrecedingText() {
      java.lang.Object ref = precedingText_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          precedingText_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Former part of surrounding text.
     * </pre>
     *
     * <code>optional string preceding_text = 1;</code>
     * @return The bytes for precedingText.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPrecedingTextBytes() {
      java.lang.Object ref = precedingText_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        precedingText_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FOLLOWING_TEXT_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object followingText_ = "";
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return Whether the followingText field is set.
     */
    @java.lang.Override
    public boolean hasFollowingText() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return The followingText.
     */
    @java.lang.Override
    public java.lang.String getFollowingText() {
      java.lang.Object ref = followingText_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          followingText_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Latter part of surrounding text.
     * </pre>
     *
     * <code>optional string following_text = 2;</code>
     * @return The bytes for followingText.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFollowingTextBytes() {
      java.lang.Object ref = followingText_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        followingText_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SUPPRESS_SUGGESTION_FIELD_NUMBER = 3;
    private boolean suppressSuggestion_ = false;
    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     * @return Whether the suppressSuggestion field is set.
     */
    @java.lang.Override
    public boolean hasSuppressSuggestion() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If this is true, suggestion feature is disabled regardless the
     * configuration.  If this is false, suggestion feature is followed
     * by the user's configuration.  If you want to omit interim
     * suggestions during the key typing, you might want to use
     * request_suggestion.
     * </pre>
     *
     * <code>optional bool suppress_suggestion = 3 [default = false];</code>
     * @return The suppressSuggestion.
     */
    @java.lang.Override
    public boolean getSuppressSuggestion() {
      return suppressSuggestion_;
    }

    public static final int INPUT_FIELD_TYPE_FIELD_NUMBER = 4;
    private int inputFieldType_ = 1;
    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     * @return Whether the inputFieldType field is set.
     */
    @java.lang.Override public boolean hasInputFieldType() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Type of the input field being focused.
     * </pre>
     *
     * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
     * @return The inputFieldType.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType getInputFieldType() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType.forNumber(inputFieldType_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType.NORMAL : result;
    }

    public static final int REVISION_FIELD_NUMBER = 5;
    private int revision_ = 0;
    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     * @return Whether the revision field is set.
     */
    @java.lang.Override
    public boolean hasRevision() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * An unique revision ID to specify one specific typing session. A client can
     * use arbitrary value for this field. The converter is expected to clear its
     * internal history segments whenever this value is changed. A client should
     * use the same revision ID whenever the converter should keep it internal
     * history segments. In order to avoid unexpected history learnings, a client
     * should update the revision whenever the input focus is changed.
     * </pre>
     *
     * <code>optional int32 revision = 5 [default = 0];</code>
     * @return The revision.
     */
    @java.lang.Override
    public int getRevision() {
      return revision_;
    }

    public static final int EXPERIMENTAL_FEATURES_FIELD_NUMBER = 100;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList experimentalFeatures_;
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @return A list containing the experimentalFeatures.
     */
    public com.google.protobuf.ProtocolStringList
        getExperimentalFeaturesList() {
      return experimentalFeatures_;
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @return The count of experimentalFeatures.
     */
    public int getExperimentalFeaturesCount() {
      return experimentalFeatures_.size();
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param index The index of the element to return.
     * @return The experimentalFeatures at the given index.
     */
    public java.lang.String getExperimentalFeatures(int index) {
      return experimentalFeatures_.get(index);
    }
    /**
     * <pre>
     * Repeated fields to be used for experimental features.
     * </pre>
     *
     * <code>repeated string experimental_features = 100;</code>
     * @param index The index of the value to return.
     * @return The bytes of the experimentalFeatures at the given index.
     */
    public com.google.protobuf.ByteString
        getExperimentalFeaturesBytes(int index) {
      return experimentalFeatures_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, precedingText_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, followingText_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(3, suppressSuggestion_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeEnum(4, inputFieldType_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt32(5, revision_);
      }
      for (int i = 0; i < experimentalFeatures_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 100, experimentalFeatures_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, precedingText_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, followingText_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, suppressSuggestion_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, inputFieldType_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, revision_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < experimentalFeatures_.size(); i++) {
          dataSize += computeStringSizeNoTag(experimentalFeatures_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getExperimentalFeaturesList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context) obj;

      if (hasPrecedingText() != other.hasPrecedingText()) return false;
      if (hasPrecedingText()) {
        if (!getPrecedingText()
            .equals(other.getPrecedingText())) return false;
      }
      if (hasFollowingText() != other.hasFollowingText()) return false;
      if (hasFollowingText()) {
        if (!getFollowingText()
            .equals(other.getFollowingText())) return false;
      }
      if (hasSuppressSuggestion() != other.hasSuppressSuggestion()) return false;
      if (hasSuppressSuggestion()) {
        if (getSuppressSuggestion()
            != other.getSuppressSuggestion()) return false;
      }
      if (hasInputFieldType() != other.hasInputFieldType()) return false;
      if (hasInputFieldType()) {
        if (inputFieldType_ != other.inputFieldType_) return false;
      }
      if (hasRevision() != other.hasRevision()) return false;
      if (hasRevision()) {
        if (getRevision()
            != other.getRevision()) return false;
      }
      if (!getExperimentalFeaturesList()
          .equals(other.getExperimentalFeaturesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPrecedingText()) {
        hash = (37 * hash) + PRECEDING_TEXT_FIELD_NUMBER;
        hash = (53 * hash) + getPrecedingText().hashCode();
      }
      if (hasFollowingText()) {
        hash = (37 * hash) + FOLLOWING_TEXT_FIELD_NUMBER;
        hash = (53 * hash) + getFollowingText().hashCode();
      }
      if (hasSuppressSuggestion()) {
        hash = (37 * hash) + SUPPRESS_SUGGESTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSuppressSuggestion());
      }
      if (hasInputFieldType()) {
        hash = (37 * hash) + INPUT_FIELD_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + inputFieldType_;
      }
      if (hasRevision()) {
        hash = (37 * hash) + REVISION_FIELD_NUMBER;
        hash = (53 * hash) + getRevision();
      }
      if (getExperimentalFeaturesCount() > 0) {
        hash = (37 * hash) + EXPERIMENTAL_FEATURES_FIELD_NUMBER;
        hash = (53 * hash) + getExperimentalFeaturesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.commands.Context}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Context)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ContextOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Context_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Context_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        precedingText_ = "";
        followingText_ = "";
        suppressSuggestion_ = false;
        inputFieldType_ = 1;
        revision_ = 0;
        experimentalFeatures_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Context_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context result) {
        if (((bitField0_ & 0x00000020) != 0)) {
          experimentalFeatures_ = experimentalFeatures_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000020);
        }
        result.experimentalFeatures_ = experimentalFeatures_;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.precedingText_ = precedingText_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.followingText_ = followingText_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.suppressSuggestion_ = suppressSuggestion_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.inputFieldType_ = inputFieldType_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.revision_ = revision_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDefaultInstance()) return this;
        if (other.hasPrecedingText()) {
          precedingText_ = other.precedingText_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasFollowingText()) {
          followingText_ = other.followingText_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasSuppressSuggestion()) {
          setSuppressSuggestion(other.getSuppressSuggestion());
        }
        if (other.hasInputFieldType()) {
          setInputFieldType(other.getInputFieldType());
        }
        if (other.hasRevision()) {
          setRevision(other.getRevision());
        }
        if (!other.experimentalFeatures_.isEmpty()) {
          if (experimentalFeatures_.isEmpty()) {
            experimentalFeatures_ = other.experimentalFeatures_;
            bitField0_ = (bitField0_ & ~0x00000020);
          } else {
            ensureExperimentalFeaturesIsMutable();
            experimentalFeatures_.addAll(other.experimentalFeatures_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                precedingText_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                followingText_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                suppressSuggestion_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(4, tmpRaw);
                } else {
                  inputFieldType_ = tmpRaw;
                  bitField0_ |= 0x00000008;
                }
                break;
              } // case 32
              case 40: {
                revision_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 802: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureExperimentalFeaturesIsMutable();
                experimentalFeatures_.add(bs);
                break;
              } // case 802
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object precedingText_ = "";
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @return Whether the precedingText field is set.
       */
      public boolean hasPrecedingText() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @return The precedingText.
       */
      public java.lang.String getPrecedingText() {
        java.lang.Object ref = precedingText_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            precedingText_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @return The bytes for precedingText.
       */
      public com.google.protobuf.ByteString
          getPrecedingTextBytes() {
        java.lang.Object ref = precedingText_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          precedingText_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @param value The precedingText to set.
       * @return This builder for chaining.
       */
      public Builder setPrecedingText(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        precedingText_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPrecedingText() {
        precedingText_ = getDefaultInstance().getPrecedingText();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Former part of surrounding text.
       * </pre>
       *
       * <code>optional string preceding_text = 1;</code>
       * @param value The bytes for precedingText to set.
       * @return This builder for chaining.
       */
      public Builder setPrecedingTextBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        precedingText_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object followingText_ = "";
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @return Whether the followingText field is set.
       */
      public boolean hasFollowingText() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @return The followingText.
       */
      public java.lang.String getFollowingText() {
        java.lang.Object ref = followingText_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            followingText_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @return The bytes for followingText.
       */
      public com.google.protobuf.ByteString
          getFollowingTextBytes() {
        java.lang.Object ref = followingText_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          followingText_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @param value The followingText to set.
       * @return This builder for chaining.
       */
      public Builder setFollowingText(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        followingText_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFollowingText() {
        followingText_ = getDefaultInstance().getFollowingText();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Latter part of surrounding text.
       * </pre>
       *
       * <code>optional string following_text = 2;</code>
       * @param value The bytes for followingText to set.
       * @return This builder for chaining.
       */
      public Builder setFollowingTextBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        followingText_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private boolean suppressSuggestion_ ;
      /**
       * <pre>
       * If this is true, suggestion feature is disabled regardless the
       * configuration.  If this is false, suggestion feature is followed
       * by the user's configuration.  If you want to omit interim
       * suggestions during the key typing, you might want to use
       * request_suggestion.
       * </pre>
       *
       * <code>optional bool suppress_suggestion = 3 [default = false];</code>
       * @return Whether the suppressSuggestion field is set.
       */
      @java.lang.Override
      public boolean hasSuppressSuggestion() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * If this is true, suggestion feature is disabled regardless the
       * configuration.  If this is false, suggestion feature is followed
       * by the user's configuration.  If you want to omit interim
       * suggestions during the key typing, you might want to use
       * request_suggestion.
       * </pre>
       *
       * <code>optional bool suppress_suggestion = 3 [default = false];</code>
       * @return The suppressSuggestion.
       */
      @java.lang.Override
      public boolean getSuppressSuggestion() {
        return suppressSuggestion_;
      }
      /**
       * <pre>
       * If this is true, suggestion feature is disabled regardless the
       * configuration.  If this is false, suggestion feature is followed
       * by the user's configuration.  If you want to omit interim
       * suggestions during the key typing, you might want to use
       * request_suggestion.
       * </pre>
       *
       * <code>optional bool suppress_suggestion = 3 [default = false];</code>
       * @param value The suppressSuggestion to set.
       * @return This builder for chaining.
       */
      public Builder setSuppressSuggestion(boolean value) {
        
        suppressSuggestion_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If this is true, suggestion feature is disabled regardless the
       * configuration.  If this is false, suggestion feature is followed
       * by the user's configuration.  If you want to omit interim
       * suggestions during the key typing, you might want to use
       * request_suggestion.
       * </pre>
       *
       * <code>optional bool suppress_suggestion = 3 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearSuppressSuggestion() {
        bitField0_ = (bitField0_ & ~0x00000004);
        suppressSuggestion_ = false;
        onChanged();
        return this;
      }

      private int inputFieldType_ = 1;
      /**
       * <pre>
       * Type of the input field being focused.
       * </pre>
       *
       * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
       * @return Whether the inputFieldType field is set.
       */
      @java.lang.Override public boolean hasInputFieldType() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Type of the input field being focused.
       * </pre>
       *
       * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
       * @return The inputFieldType.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType getInputFieldType() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType.forNumber(inputFieldType_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType.NORMAL : result;
      }
      /**
       * <pre>
       * Type of the input field being focused.
       * </pre>
       *
       * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
       * @param value The inputFieldType to set.
       * @return This builder for chaining.
       */
      public Builder setInputFieldType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.InputFieldType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        inputFieldType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of the input field being focused.
       * </pre>
       *
       * <code>optional .mozc.commands.Context.InputFieldType input_field_type = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearInputFieldType() {
        bitField0_ = (bitField0_ & ~0x00000008);
        inputFieldType_ = 1;
        onChanged();
        return this;
      }

      private int revision_ ;
      /**
       * <pre>
       * An unique revision ID to specify one specific typing session. A client can
       * use arbitrary value for this field. The converter is expected to clear its
       * internal history segments whenever this value is changed. A client should
       * use the same revision ID whenever the converter should keep it internal
       * history segments. In order to avoid unexpected history learnings, a client
       * should update the revision whenever the input focus is changed.
       * </pre>
       *
       * <code>optional int32 revision = 5 [default = 0];</code>
       * @return Whether the revision field is set.
       */
      @java.lang.Override
      public boolean hasRevision() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * An unique revision ID to specify one specific typing session. A client can
       * use arbitrary value for this field. The converter is expected to clear its
       * internal history segments whenever this value is changed. A client should
       * use the same revision ID whenever the converter should keep it internal
       * history segments. In order to avoid unexpected history learnings, a client
       * should update the revision whenever the input focus is changed.
       * </pre>
       *
       * <code>optional int32 revision = 5 [default = 0];</code>
       * @return The revision.
       */
      @java.lang.Override
      public int getRevision() {
        return revision_;
      }
      /**
       * <pre>
       * An unique revision ID to specify one specific typing session. A client can
       * use arbitrary value for this field. The converter is expected to clear its
       * internal history segments whenever this value is changed. A client should
       * use the same revision ID whenever the converter should keep it internal
       * history segments. In order to avoid unexpected history learnings, a client
       * should update the revision whenever the input focus is changed.
       * </pre>
       *
       * <code>optional int32 revision = 5 [default = 0];</code>
       * @param value The revision to set.
       * @return This builder for chaining.
       */
      public Builder setRevision(int value) {
        
        revision_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An unique revision ID to specify one specific typing session. A client can
       * use arbitrary value for this field. The converter is expected to clear its
       * internal history segments whenever this value is changed. A client should
       * use the same revision ID whenever the converter should keep it internal
       * history segments. In order to avoid unexpected history learnings, a client
       * should update the revision whenever the input focus is changed.
       * </pre>
       *
       * <code>optional int32 revision = 5 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearRevision() {
        bitField0_ = (bitField0_ & ~0x00000010);
        revision_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList experimentalFeatures_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureExperimentalFeaturesIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          experimentalFeatures_ = new com.google.protobuf.LazyStringArrayList(experimentalFeatures_);
          bitField0_ |= 0x00000020;
         }
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @return A list containing the experimentalFeatures.
       */
      public com.google.protobuf.ProtocolStringList
          getExperimentalFeaturesList() {
        return experimentalFeatures_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @return The count of experimentalFeatures.
       */
      public int getExperimentalFeaturesCount() {
        return experimentalFeatures_.size();
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param index The index of the element to return.
       * @return The experimentalFeatures at the given index.
       */
      public java.lang.String getExperimentalFeatures(int index) {
        return experimentalFeatures_.get(index);
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param index The index of the value to return.
       * @return The bytes of the experimentalFeatures at the given index.
       */
      public com.google.protobuf.ByteString
          getExperimentalFeaturesBytes(int index) {
        return experimentalFeatures_.getByteString(index);
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param index The index to set the value at.
       * @param value The experimentalFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setExperimentalFeatures(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureExperimentalFeaturesIsMutable();
        experimentalFeatures_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param value The experimentalFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addExperimentalFeatures(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureExperimentalFeaturesIsMutable();
        experimentalFeatures_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param values The experimentalFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addAllExperimentalFeatures(
          java.lang.Iterable<java.lang.String> values) {
        ensureExperimentalFeaturesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, experimentalFeatures_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @return This builder for chaining.
       */
      public Builder clearExperimentalFeatures() {
        experimentalFeatures_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Repeated fields to be used for experimental features.
       * </pre>
       *
       * <code>repeated string experimental_features = 100;</code>
       * @param value The bytes of the experimentalFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addExperimentalFeaturesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureExperimentalFeaturesIsMutable();
        experimentalFeatures_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.Context)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.Context)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Context>
        PARSER = new com.google.protobuf.AbstractParser<Context>() {
      @java.lang.Override
      public Context parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Context> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Context> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Capability)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     * @return Whether the textDeletion field is set.
     */
    boolean hasTextDeletion();
    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     * @return The textDeletion.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType getTextDeletion();
  }
  /**
   * <pre>
   * Clients' capability.
   * Users cannot modify this.
   * The server has to obey this capability.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Capability}
   */
  public static final class Capability extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Capability)
      CapabilityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Capability.newBuilder() to construct.
    private Capability(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Capability() {
      textDeletion_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Capability();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Capability_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Capability_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.Builder.class);
    }

    /**
     * <pre>
     * Bit fields to notify what the client can do.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Capability.TextDeletionCapabilityType}
     */
    public enum TextDeletionCapabilityType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NO_TEXT_DELETION_CAPABILITY = 0;</code>
       */
      NO_TEXT_DELETION_CAPABILITY(0),
      /**
       * <pre>
       * Can delete preceding text which is adjacent to preedit.
       * </pre>
       *
       * <code>DELETE_PRECEDING_TEXT = 1;</code>
       */
      DELETE_PRECEDING_TEXT(1),
      ;

      /**
       * <code>NO_TEXT_DELETION_CAPABILITY = 0;</code>
       */
      public static final int NO_TEXT_DELETION_CAPABILITY_VALUE = 0;
      /**
       * <pre>
       * Can delete preceding text which is adjacent to preedit.
       * </pre>
       *
       * <code>DELETE_PRECEDING_TEXT = 1;</code>
       */
      public static final int DELETE_PRECEDING_TEXT_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TextDeletionCapabilityType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static TextDeletionCapabilityType forNumber(int value) {
        switch (value) {
          case 0: return NO_TEXT_DELETION_CAPABILITY;
          case 1: return DELETE_PRECEDING_TEXT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<TextDeletionCapabilityType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          TextDeletionCapabilityType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<TextDeletionCapabilityType>() {
              public TextDeletionCapabilityType findValueByNumber(int number) {
                return TextDeletionCapabilityType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDescriptor().getEnumTypes().get(0);
      }

      private static final TextDeletionCapabilityType[] VALUES = values();

      public static TextDeletionCapabilityType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private TextDeletionCapabilityType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Capability.TextDeletionCapabilityType)
    }

    private int bitField0_;
    public static final int TEXT_DELETION_FIELD_NUMBER = 1;
    private int textDeletion_ = 0;
    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     * @return Whether the textDeletion field is set.
     */
    @java.lang.Override public boolean hasTextDeletion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
     * @return The textDeletion.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType getTextDeletion() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType.forNumber(textDeletion_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType.NO_TEXT_DELETION_CAPABILITY : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, textDeletion_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, textDeletion_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability) obj;

      if (hasTextDeletion() != other.hasTextDeletion()) return false;
      if (hasTextDeletion()) {
        if (textDeletion_ != other.textDeletion_) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTextDeletion()) {
        hash = (37 * hash) + TEXT_DELETION_FIELD_NUMBER;
        hash = (53 * hash) + textDeletion_;
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Clients' capability.
     * Users cannot modify this.
     * The server has to obey this capability.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Capability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Capability)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CapabilityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Capability_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Capability_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        textDeletion_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Capability_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.textDeletion_ = textDeletion_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDefaultInstance()) return this;
        if (other.hasTextDeletion()) {
          setTextDeletion(other.getTextDeletion());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  textDeletion_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int textDeletion_ = 0;
      /**
       * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
       * @return Whether the textDeletion field is set.
       */
      @java.lang.Override public boolean hasTextDeletion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
       * @return The textDeletion.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType getTextDeletion() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType.forNumber(textDeletion_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType.NO_TEXT_DELETION_CAPABILITY : result;
      }
      /**
       * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
       * @param value The textDeletion to set.
       * @return This builder for chaining.
       */
      public Builder setTextDeletion(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.TextDeletionCapabilityType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        textDeletion_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];</code>
       * @return This builder for chaining.
       */
      public Builder clearTextDeletion() {
        bitField0_ = (bitField0_ & ~0x00000001);
        textDeletion_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.Capability)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.Capability)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Capability>
        PARSER = new com.google.protobuf.AbstractParser<Capability>() {
      @java.lang.Override
      public Capability parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Capability> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Capability> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DecoderExperimentParamsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.DecoderExperimentParams)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     * @return Whether the variationCharacterTypes field is set.
     */
    boolean hasVariationCharacterTypes();
    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     * @return The variationCharacterTypes.
     */
    int getVariationCharacterTypes();

    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerMode field is set.
     */
    boolean hasTypingCorrectionResultRerankerMode();
    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     * @return The typingCorrectionResultRerankerMode.
     */
    int getTypingCorrectionResultRerankerMode();

    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerInterpolationWeight field is set.
     */
    boolean hasTypingCorrectionResultRerankerInterpolationWeight();
    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     * @return The typingCorrectionResultRerankerInterpolationWeight.
     */
    float getTypingCorrectionResultRerankerInterpolationWeight();

    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerLiteralOnTopWeight field is set.
     */
    boolean hasTypingCorrectionResultRerankerLiteralOnTopWeight();
    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     * @return The typingCorrectionResultRerankerLiteralOnTopWeight.
     */
    float getTypingCorrectionResultRerankerLiteralOnTopWeight();

    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     * @return Whether the typingCorrectionApplyUserHistorySize field is set.
     */
    boolean hasTypingCorrectionApplyUserHistorySize();
    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     * @return The typingCorrectionApplyUserHistorySize.
     */
    int getTypingCorrectionApplyUserHistorySize();

    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     * @return Whether the disableZeroQuerySuffixPrediction field is set.
     */
    boolean hasDisableZeroQuerySuffixPrediction();
    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     * @return The disableZeroQuerySuffixPrediction.
     */
    boolean getDisableZeroQuerySuffixPrediction();

    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     * @return Whether the userHistoryPredictionMaxCharCoverage field is set.
     */
    boolean hasUserHistoryPredictionMaxCharCoverage();
    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     * @return The userHistoryPredictionMaxCharCoverage.
     */
    int getUserHistoryPredictionMaxCharCoverage();

    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     * @return Whether the englishVariationSpaceInsertionMode field is set.
     */
    boolean hasEnglishVariationSpaceInsertionMode();
    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     * @return The englishVariationSpaceInsertionMode.
     */
    int getEnglishVariationSpaceInsertionMode();

    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     * @return Whether the candidateConsistencyCostMaxDiff field is set.
     */
    boolean hasCandidateConsistencyCostMaxDiff();
    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     * @return The candidateConsistencyCostMaxDiff.
     */
    int getCandidateConsistencyCostMaxDiff();

    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     * @return Whether the maxCompositionEventToProcess field is set.
     */
    boolean hasMaxCompositionEventToProcess();
    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     * @return The maxCompositionEventToProcess.
     */
    int getMaxCompositionEventToProcess();

    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     * @return Whether the katakanaPromotionOffset field is set.
     */
    boolean hasKatakanaPromotionOffset();
    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     * @return The katakanaPromotionOffset.
     */
    int getKatakanaPromotionOffset();

    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     * @return Whether the handwritingConversionCandidateCostOffset field is set.
     */
    boolean hasHandwritingConversionCandidateCostOffset();
    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     * @return The handwritingConversionCandidateCostOffset.
     */
    int getHandwritingConversionCandidateCostOffset();

    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     * @return Whether the suffixNwpTransitionCostThreshold field is set.
     */
    boolean hasSuffixNwpTransitionCostThreshold();
    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     * @return The suffixNwpTransitionCostThreshold.
     */
    int getSuffixNwpTransitionCostThreshold();

    /**
     * <pre>
     * How many initial LRU entries to look up.
     * We use a simple linear-search on LRU.
     * When zero, default value (3000) is used.
     * </pre>
     *
     * <code>optional int32 user_history_max_suggestion_trial = 108 [default = 0];</code>
     * @return Whether the userHistoryMaxSuggestionTrial field is set.
     */
    boolean hasUserHistoryMaxSuggestionTrial();
    /**
     * <pre>
     * How many initial LRU entries to look up.
     * We use a simple linear-search on LRU.
     * When zero, default value (3000) is used.
     * </pre>
     *
     * <code>optional int32 user_history_max_suggestion_trial = 108 [default = 0];</code>
     * @return The userHistoryMaxSuggestionTrial.
     */
    int getUserHistoryMaxSuggestionTrial();

    /**
     * <pre>
     * The maximum lifetime of the entries.
     * When zero, default value (62) is used.
     * </pre>
     *
     * <code>optional int32 user_history_entry_lifetime_days = 109 [default = 0];</code>
     * @return Whether the userHistoryEntryLifetimeDays field is set.
     */
    boolean hasUserHistoryEntryLifetimeDays();
    /**
     * <pre>
     * The maximum lifetime of the entries.
     * When zero, default value (62) is used.
     * </pre>
     *
     * <code>optional int32 user_history_entry_lifetime_days = 109 [default = 0];</code>
     * @return The userHistoryEntryLifetimeDays.
     */
    int getUserHistoryEntryLifetimeDays();

    /**
     * <pre>
     * The maximum size of entries actually saved to disk.
     * When zero, store all entries in the on-memory LRU.
     * </pre>
     *
     * <code>optional int32 user_history_cache_store_size = 110 [default = 0];</code>
     * @return Whether the userHistoryCacheStoreSize field is set.
     */
    boolean hasUserHistoryCacheStoreSize();
    /**
     * <pre>
     * The maximum size of entries actually saved to disk.
     * When zero, store all entries in the on-memory LRU.
     * </pre>
     *
     * <code>optional int32 user_history_cache_store_size = 110 [default = 0];</code>
     * @return The userHistoryCacheStoreSize.
     */
    int getUserHistoryCacheStoreSize();

    /**
     * <pre>
     * The mode of partial revert. When zero, partial revert is not enabled.
     * </pre>
     *
     * <code>optional int32 user_history_partial_revert_mode = 125 [default = 0];</code>
     * @return Whether the userHistoryPartialRevertMode field is set.
     */
    boolean hasUserHistoryPartialRevertMode();
    /**
     * <pre>
     * The mode of partial revert. When zero, partial revert is not enabled.
     * </pre>
     *
     * <code>optional int32 user_history_partial_revert_mode = 125 [default = 0];</code>
     * @return The userHistoryPartialRevertMode.
     */
    int getUserHistoryPartialRevertMode();
  }
  /**
   * <pre>
   * Next ID: 126
   * Bundles together some Android experiment flags so that they can be easily
   * retrieved throughout the native code.  These flags are generally specific to
   * the decoder, and are made available when the decoder is initialized.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.DecoderExperimentParams}
   */
  public static final class DecoderExperimentParams extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.DecoderExperimentParams)
      DecoderExperimentParamsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DecoderExperimentParams.newBuilder() to construct.
    private DecoderExperimentParams(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DecoderExperimentParams() {
      maxCompositionEventToProcess_ = 2;
      katakanaPromotionOffset_ = 5;
      handwritingConversionCandidateCostOffset_ = 1151;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DecoderExperimentParams();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DecoderExperimentParams_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DecoderExperimentParams_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.Builder.class);
    }

    /**
     * Protobuf enum {@code mozc.commands.DecoderExperimentParams.VariationCharacterType}
     */
    public enum VariationCharacterType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NO_VARIATION = 0;</code>
       */
      NO_VARIATION(0),
      /**
       * <pre>
       * Standardized variation sequences for Japanese.
       * https://unicode.org/Public/UNIDATA/StandardizedVariants.txt
       * It specifies to use SVS characters instead of CJK compatibility
       * ideographs for Japanese.
       * </pre>
       *
       * <code>SVS_JAPANESE = 1;</code>
       */
      SVS_JAPANESE(1),
      ;

      /**
       * <code>NO_VARIATION = 0;</code>
       */
      public static final int NO_VARIATION_VALUE = 0;
      /**
       * <pre>
       * Standardized variation sequences for Japanese.
       * https://unicode.org/Public/UNIDATA/StandardizedVariants.txt
       * It specifies to use SVS characters instead of CJK compatibility
       * ideographs for Japanese.
       * </pre>
       *
       * <code>SVS_JAPANESE = 1;</code>
       */
      public static final int SVS_JAPANESE_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static VariationCharacterType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static VariationCharacterType forNumber(int value) {
        switch (value) {
          case 0: return NO_VARIATION;
          case 1: return SVS_JAPANESE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<VariationCharacterType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          VariationCharacterType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<VariationCharacterType>() {
              public VariationCharacterType findValueByNumber(int number) {
                return VariationCharacterType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDescriptor().getEnumTypes().get(0);
      }

      private static final VariationCharacterType[] VALUES = values();

      public static VariationCharacterType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private VariationCharacterType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.DecoderExperimentParams.VariationCharacterType)
    }

    /**
     * Protobuf enum {@code mozc.commands.DecoderExperimentParams.BigramNwpFilteringMode}
     */
    public enum BigramNwpFilteringMode
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Control implementation is used. For example,
       * - Kanji + Katakana will not be filtered.
       * - If cost(prefix) &gt; cost(original_entry), the candidate will be filtered.
       * - The reading of the target candidate should be in the dictionary.
       * - ,etc
       * </pre>
       *
       * <code>DEFAULT = 0;</code>
       */
      DEFAULT(0),
      /**
       * <pre>
       * In addition to the default filtering, filter entry if the character
       * script type does not change from the prefix.
       * </pre>
       *
       * <code>FILTER_SAME_CTYPE = 1;</code>
       */
      FILTER_SAME_CTYPE(1),
      /**
       * <pre>
       * Filter all bigram candidates.
       * </pre>
       *
       * <code>FILTER_ALL = 2;</code>
       */
      FILTER_ALL(2),
      ;

      /**
       * <pre>
       * Control implementation is used. For example,
       * - Kanji + Katakana will not be filtered.
       * - If cost(prefix) &gt; cost(original_entry), the candidate will be filtered.
       * - The reading of the target candidate should be in the dictionary.
       * - ,etc
       * </pre>
       *
       * <code>DEFAULT = 0;</code>
       */
      public static final int DEFAULT_VALUE = 0;
      /**
       * <pre>
       * In addition to the default filtering, filter entry if the character
       * script type does not change from the prefix.
       * </pre>
       *
       * <code>FILTER_SAME_CTYPE = 1;</code>
       */
      public static final int FILTER_SAME_CTYPE_VALUE = 1;
      /**
       * <pre>
       * Filter all bigram candidates.
       * </pre>
       *
       * <code>FILTER_ALL = 2;</code>
       */
      public static final int FILTER_ALL_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static BigramNwpFilteringMode valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static BigramNwpFilteringMode forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT;
          case 1: return FILTER_SAME_CTYPE;
          case 2: return FILTER_ALL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<BigramNwpFilteringMode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          BigramNwpFilteringMode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<BigramNwpFilteringMode>() {
              public BigramNwpFilteringMode findValueByNumber(int number) {
                return BigramNwpFilteringMode.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDescriptor().getEnumTypes().get(1);
      }

      private static final BigramNwpFilteringMode[] VALUES = values();

      public static BigramNwpFilteringMode valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private BigramNwpFilteringMode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.DecoderExperimentParams.BigramNwpFilteringMode)
    }

    private int bitField0_;
    public static final int VARIATION_CHARACTER_TYPES_FIELD_NUMBER = 8;
    private int variationCharacterTypes_ = 0;
    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     * @return Whether the variationCharacterTypes field is set.
     */
    @java.lang.Override
    public boolean hasVariationCharacterTypes() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Bitmap of enabled variation character types.
     * </pre>
     *
     * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
     * @return The variationCharacterTypes.
     */
    @java.lang.Override
    public int getVariationCharacterTypes() {
      return variationCharacterTypes_;
    }

    public static final int TYPING_CORRECTION_RESULT_RERANKER_MODE_FIELD_NUMBER = 95;
    private int typingCorrectionResultRerankerMode_ = 0;
    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerMode field is set.
     */
    @java.lang.Override
    public boolean hasTypingCorrectionResultRerankerMode() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Enables final results reranking against literal results.
     * If zero, the previous implementation is used.
     * </pre>
     *
     * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
     * @return The typingCorrectionResultRerankerMode.
     */
    @java.lang.Override
    public int getTypingCorrectionResultRerankerMode() {
      return typingCorrectionResultRerankerMode_;
    }

    public static final int TYPING_CORRECTION_RESULT_RERANKER_INTERPOLATION_WEIGHT_FIELD_NUMBER = 100;
    private float typingCorrectionResultRerankerInterpolationWeight_ = 0F;
    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerInterpolationWeight field is set.
     */
    @java.lang.Override
    public boolean hasTypingCorrectionResultRerankerInterpolationWeight() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
     * @return The typingCorrectionResultRerankerInterpolationWeight.
     */
    @java.lang.Override
    public float getTypingCorrectionResultRerankerInterpolationWeight() {
      return typingCorrectionResultRerankerInterpolationWeight_;
    }

    public static final int TYPING_CORRECTION_RESULT_RERANKER_LITERAL_ON_TOP_WEIGHT_FIELD_NUMBER = 101;
    private float typingCorrectionResultRerankerLiteralOnTopWeight_ = 0F;
    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     * @return Whether the typingCorrectionResultRerankerLiteralOnTopWeight field is set.
     */
    @java.lang.Override
    public boolean hasTypingCorrectionResultRerankerLiteralOnTopWeight() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
     * &gt; 0.0. otherwise, runs literal-on-top.
     * </pre>
     *
     * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
     * @return The typingCorrectionResultRerankerLiteralOnTopWeight.
     */
    @java.lang.Override
    public float getTypingCorrectionResultRerankerLiteralOnTopWeight() {
      return typingCorrectionResultRerankerLiteralOnTopWeight_;
    }

    public static final int TYPING_CORRECTION_APPLY_USER_HISTORY_SIZE_FIELD_NUMBER = 85;
    private int typingCorrectionApplyUserHistorySize_ = 0;
    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     * @return Whether the typingCorrectionApplyUserHistorySize field is set.
     */
    @java.lang.Override
    public boolean hasTypingCorrectionApplyUserHistorySize() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Uses the typing correction in user history predictor. The size specifies
     * the maximum number of typing corrections used for query lookup.
     * When zero, typing_correction is not used.
     * </pre>
     *
     * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
     * @return The typingCorrectionApplyUserHistorySize.
     */
    @java.lang.Override
    public int getTypingCorrectionApplyUserHistorySize() {
      return typingCorrectionApplyUserHistorySize_;
    }

    public static final int DISABLE_ZERO_QUERY_SUFFIX_PREDICTION_FIELD_NUMBER = 36;
    private boolean disableZeroQuerySuffixPrediction_ = false;
    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     * @return Whether the disableZeroQuerySuffixPrediction field is set.
     */
    @java.lang.Override
    public boolean hasDisableZeroQuerySuffixPrediction() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
     * @return The disableZeroQuerySuffixPrediction.
     */
    @java.lang.Override
    public boolean getDisableZeroQuerySuffixPrediction() {
      return disableZeroQuerySuffixPrediction_;
    }

    public static final int USER_HISTORY_PREDICTION_MAX_CHAR_COVERAGE_FIELD_NUMBER = 82;
    private int userHistoryPredictionMaxCharCoverage_ = 0;
    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     * @return Whether the userHistoryPredictionMaxCharCoverage field is set.
     */
    @java.lang.Override
    public boolean hasUserHistoryPredictionMaxCharCoverage() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Changes the size of history with character coverage.
     * </pre>
     *
     * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
     * @return The userHistoryPredictionMaxCharCoverage.
     */
    @java.lang.Override
    public int getUserHistoryPredictionMaxCharCoverage() {
      return userHistoryPredictionMaxCharCoverage_;
    }

    public static final int ENGLISH_VARIATION_SPACE_INSERTION_MODE_FIELD_NUMBER = 55;
    private int englishVariationSpaceInsertionMode_ = 0;
    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     * @return Whether the englishVariationSpaceInsertionMode field is set.
     */
    @java.lang.Override
    public boolean hasEnglishVariationSpaceInsertionMode() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Parameter for space-insertion for English compounds
     * value 0: no insertion. Candidates will be like this.
     * - "Google"
     * - "GOOGLE"
     * - "google"
     * value 1: expand for all English candidates
     * This mode adds space-prefixed candidates for three style, like this.
     * - "Google"
     * - " Google"
     * - "GOOGLE"
     * - " GOOGLE"
     * - "google"
     * - " google"
     * </pre>
     *
     * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
     * @return The englishVariationSpaceInsertionMode.
     */
    @java.lang.Override
    public int getEnglishVariationSpaceInsertionMode() {
      return englishVariationSpaceInsertionMode_;
    }

    public static final int CANDIDATE_CONSISTENCY_COST_MAX_DIFF_FIELD_NUMBER = 63;
    private int candidateConsistencyCostMaxDiff_ = 0;
    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     * @return Whether the candidateConsistencyCostMaxDiff field is set.
     */
    @java.lang.Override
    public boolean hasCandidateConsistencyCostMaxDiff() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
     * @return The candidateConsistencyCostMaxDiff.
     */
    @java.lang.Override
    public int getCandidateConsistencyCostMaxDiff() {
      return candidateConsistencyCostMaxDiff_;
    }

    public static final int MAX_COMPOSITION_EVENT_TO_PROCESS_FIELD_NUMBER = 64;
    private int maxCompositionEventToProcess_ = 2;
    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     * @return Whether the maxCompositionEventToProcess field is set.
     */
    @java.lang.Override
    public boolean hasMaxCompositionEventToProcess() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
     * @return The maxCompositionEventToProcess.
     */
    @java.lang.Override
    public int getMaxCompositionEventToProcess() {
      return maxCompositionEventToProcess_;
    }

    public static final int KATAKANA_PROMOTION_OFFSET_FIELD_NUMBER = 83;
    private int katakanaPromotionOffset_ = 5;
    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     * @return Whether the katakanaPromotionOffset field is set.
     */
    @java.lang.Override
    public boolean hasKatakanaPromotionOffset() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Offset to promote Katakana candidates in rewriter.
     * The promotion will be disabled if the value is negative.
     * </pre>
     *
     * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
     * @return The katakanaPromotionOffset.
     */
    @java.lang.Override
    public int getKatakanaPromotionOffset() {
      return katakanaPromotionOffset_;
    }

    public static final int HANDWRITING_CONVERSION_CANDIDATE_COST_OFFSET_FIELD_NUMBER = 102;
    private int handwritingConversionCandidateCostOffset_ = 1151;
    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     * @return Whether the handwritingConversionCandidateCostOffset field is set.
     */
    @java.lang.Override
    public boolean hasHandwritingConversionCandidateCostOffset() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Cost offset for handwriting conversion candidate.
     * default_value: 10*log(500)
     * </pre>
     *
     * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
     * @return The handwritingConversionCandidateCostOffset.
     */
    @java.lang.Override
    public int getHandwritingConversionCandidateCostOffset() {
      return handwritingConversionCandidateCostOffset_;
    }

    public static final int SUFFIX_NWP_TRANSITION_COST_THRESHOLD_FIELD_NUMBER = 107;
    private int suffixNwpTransitionCostThreshold_ = 0;
    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     * @return Whether the suffixNwpTransitionCostThreshold field is set.
     */
    @java.lang.Override
    public boolean hasSuffixNwpTransitionCostThreshold() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Threshold for suffix NWP transition cost.
     * If the transition cost is greater than this value, the candidate will be
     * filtered.
     * The candidate will not be filtered if this value is zero.
     * </pre>
     *
     * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
     * @return The suffixNwpTransitionCostThreshold.
     */
    @java.lang.Override
    public int getSuffixNwpTransitionCostThreshold() {
      return suffixNwpTransitionCostThreshold_;
    }

    public static final int USER_HISTORY_MAX_SUGGESTION_TRIAL_FIELD_NUMBER = 108;
    private int userHistoryMaxSuggestionTrial_ = 0;
    /**
     * <pre>
     * How many initial LRU entries to look up.
     * We use a simple linear-search on LRU.
     * When zero, default value (3000) is used.
     * </pre>
     *
     * <code>optional int32 user_history_max_suggestion_trial = 108 [default = 0];</code>
     * @return Whether the userHistoryMaxSuggestionTrial field is set.
     */
    @java.lang.Override
    public boolean hasUserHistoryMaxSuggestionTrial() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * How many initial LRU entries to look up.
     * We use a simple linear-search on LRU.
     * When zero, default value (3000) is used.
     * </pre>
     *
     * <code>optional int32 user_history_max_suggestion_trial = 108 [default = 0];</code>
     * @return The userHistoryMaxSuggestionTrial.
     */
    @java.lang.Override
    public int getUserHistoryMaxSuggestionTrial() {
      return userHistoryMaxSuggestionTrial_;
    }

    public static final int USER_HISTORY_ENTRY_LIFETIME_DAYS_FIELD_NUMBER = 109;
    private int userHistoryEntryLifetimeDays_ = 0;
    /**
     * <pre>
     * The maximum lifetime of the entries.
     * When zero, default value (62) is used.
     * </pre>
     *
     * <code>optional int32 user_history_entry_lifetime_days = 109 [default = 0];</code>
     * @return Whether the userHistoryEntryLifetimeDays field is set.
     */
    @java.lang.Override
    public boolean hasUserHistoryEntryLifetimeDays() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * The maximum lifetime of the entries.
     * When zero, default value (62) is used.
     * </pre>
     *
     * <code>optional int32 user_history_entry_lifetime_days = 109 [default = 0];</code>
     * @return The userHistoryEntryLifetimeDays.
     */
    @java.lang.Override
    public int getUserHistoryEntryLifetimeDays() {
      return userHistoryEntryLifetimeDays_;
    }

    public static final int USER_HISTORY_CACHE_STORE_SIZE_FIELD_NUMBER = 110;
    private int userHistoryCacheStoreSize_ = 0;
    /**
     * <pre>
     * The maximum size of entries actually saved to disk.
     * When zero, store all entries in the on-memory LRU.
     * </pre>
     *
     * <code>optional int32 user_history_cache_store_size = 110 [default = 0];</code>
     * @return Whether the userHistoryCacheStoreSize field is set.
     */
    @java.lang.Override
    public boolean hasUserHistoryCacheStoreSize() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * The maximum size of entries actually saved to disk.
     * When zero, store all entries in the on-memory LRU.
     * </pre>
     *
     * <code>optional int32 user_history_cache_store_size = 110 [default = 0];</code>
     * @return The userHistoryCacheStoreSize.
     */
    @java.lang.Override
    public int getUserHistoryCacheStoreSize() {
      return userHistoryCacheStoreSize_;
    }

    public static final int USER_HISTORY_PARTIAL_REVERT_MODE_FIELD_NUMBER = 125;
    private int userHistoryPartialRevertMode_ = 0;
    /**
     * <pre>
     * The mode of partial revert. When zero, partial revert is not enabled.
     * </pre>
     *
     * <code>optional int32 user_history_partial_revert_mode = 125 [default = 0];</code>
     * @return Whether the userHistoryPartialRevertMode field is set.
     */
    @java.lang.Override
    public boolean hasUserHistoryPartialRevertMode() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * The mode of partial revert. When zero, partial revert is not enabled.
     * </pre>
     *
     * <code>optional int32 user_history_partial_revert_mode = 125 [default = 0];</code>
     * @return The userHistoryPartialRevertMode.
     */
    @java.lang.Override
    public int getUserHistoryPartialRevertMode() {
      return userHistoryPartialRevertMode_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(8, variationCharacterTypes_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(36, disableZeroQuerySuffixPrediction_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt32(55, englishVariationSpaceInsertionMode_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeInt32(63, candidateConsistencyCostMaxDiff_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeInt32(64, maxCompositionEventToProcess_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeInt32(82, userHistoryPredictionMaxCharCoverage_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeInt32(83, katakanaPromotionOffset_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt32(85, typingCorrectionApplyUserHistorySize_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(95, typingCorrectionResultRerankerMode_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeFloat(100, typingCorrectionResultRerankerInterpolationWeight_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeFloat(101, typingCorrectionResultRerankerLiteralOnTopWeight_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeInt32(102, handwritingConversionCandidateCostOffset_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeInt32(107, suffixNwpTransitionCostThreshold_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeInt32(108, userHistoryMaxSuggestionTrial_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeInt32(109, userHistoryEntryLifetimeDays_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeInt32(110, userHistoryCacheStoreSize_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeInt32(125, userHistoryPartialRevertMode_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(8, variationCharacterTypes_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(36, disableZeroQuerySuffixPrediction_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(55, englishVariationSpaceInsertionMode_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(63, candidateConsistencyCostMaxDiff_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(64, maxCompositionEventToProcess_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(82, userHistoryPredictionMaxCharCoverage_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(83, katakanaPromotionOffset_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(85, typingCorrectionApplyUserHistorySize_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(95, typingCorrectionResultRerankerMode_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(100, typingCorrectionResultRerankerInterpolationWeight_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(101, typingCorrectionResultRerankerLiteralOnTopWeight_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(102, handwritingConversionCandidateCostOffset_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(107, suffixNwpTransitionCostThreshold_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(108, userHistoryMaxSuggestionTrial_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(109, userHistoryEntryLifetimeDays_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(110, userHistoryCacheStoreSize_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(125, userHistoryPartialRevertMode_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams) obj;

      if (hasVariationCharacterTypes() != other.hasVariationCharacterTypes()) return false;
      if (hasVariationCharacterTypes()) {
        if (getVariationCharacterTypes()
            != other.getVariationCharacterTypes()) return false;
      }
      if (hasTypingCorrectionResultRerankerMode() != other.hasTypingCorrectionResultRerankerMode()) return false;
      if (hasTypingCorrectionResultRerankerMode()) {
        if (getTypingCorrectionResultRerankerMode()
            != other.getTypingCorrectionResultRerankerMode()) return false;
      }
      if (hasTypingCorrectionResultRerankerInterpolationWeight() != other.hasTypingCorrectionResultRerankerInterpolationWeight()) return false;
      if (hasTypingCorrectionResultRerankerInterpolationWeight()) {
        if (java.lang.Float.floatToIntBits(getTypingCorrectionResultRerankerInterpolationWeight())
            != java.lang.Float.floatToIntBits(
                other.getTypingCorrectionResultRerankerInterpolationWeight())) return false;
      }
      if (hasTypingCorrectionResultRerankerLiteralOnTopWeight() != other.hasTypingCorrectionResultRerankerLiteralOnTopWeight()) return false;
      if (hasTypingCorrectionResultRerankerLiteralOnTopWeight()) {
        if (java.lang.Float.floatToIntBits(getTypingCorrectionResultRerankerLiteralOnTopWeight())
            != java.lang.Float.floatToIntBits(
                other.getTypingCorrectionResultRerankerLiteralOnTopWeight())) return false;
      }
      if (hasTypingCorrectionApplyUserHistorySize() != other.hasTypingCorrectionApplyUserHistorySize()) return false;
      if (hasTypingCorrectionApplyUserHistorySize()) {
        if (getTypingCorrectionApplyUserHistorySize()
            != other.getTypingCorrectionApplyUserHistorySize()) return false;
      }
      if (hasDisableZeroQuerySuffixPrediction() != other.hasDisableZeroQuerySuffixPrediction()) return false;
      if (hasDisableZeroQuerySuffixPrediction()) {
        if (getDisableZeroQuerySuffixPrediction()
            != other.getDisableZeroQuerySuffixPrediction()) return false;
      }
      if (hasUserHistoryPredictionMaxCharCoverage() != other.hasUserHistoryPredictionMaxCharCoverage()) return false;
      if (hasUserHistoryPredictionMaxCharCoverage()) {
        if (getUserHistoryPredictionMaxCharCoverage()
            != other.getUserHistoryPredictionMaxCharCoverage()) return false;
      }
      if (hasEnglishVariationSpaceInsertionMode() != other.hasEnglishVariationSpaceInsertionMode()) return false;
      if (hasEnglishVariationSpaceInsertionMode()) {
        if (getEnglishVariationSpaceInsertionMode()
            != other.getEnglishVariationSpaceInsertionMode()) return false;
      }
      if (hasCandidateConsistencyCostMaxDiff() != other.hasCandidateConsistencyCostMaxDiff()) return false;
      if (hasCandidateConsistencyCostMaxDiff()) {
        if (getCandidateConsistencyCostMaxDiff()
            != other.getCandidateConsistencyCostMaxDiff()) return false;
      }
      if (hasMaxCompositionEventToProcess() != other.hasMaxCompositionEventToProcess()) return false;
      if (hasMaxCompositionEventToProcess()) {
        if (getMaxCompositionEventToProcess()
            != other.getMaxCompositionEventToProcess()) return false;
      }
      if (hasKatakanaPromotionOffset() != other.hasKatakanaPromotionOffset()) return false;
      if (hasKatakanaPromotionOffset()) {
        if (getKatakanaPromotionOffset()
            != other.getKatakanaPromotionOffset()) return false;
      }
      if (hasHandwritingConversionCandidateCostOffset() != other.hasHandwritingConversionCandidateCostOffset()) return false;
      if (hasHandwritingConversionCandidateCostOffset()) {
        if (getHandwritingConversionCandidateCostOffset()
            != other.getHandwritingConversionCandidateCostOffset()) return false;
      }
      if (hasSuffixNwpTransitionCostThreshold() != other.hasSuffixNwpTransitionCostThreshold()) return false;
      if (hasSuffixNwpTransitionCostThreshold()) {
        if (getSuffixNwpTransitionCostThreshold()
            != other.getSuffixNwpTransitionCostThreshold()) return false;
      }
      if (hasUserHistoryMaxSuggestionTrial() != other.hasUserHistoryMaxSuggestionTrial()) return false;
      if (hasUserHistoryMaxSuggestionTrial()) {
        if (getUserHistoryMaxSuggestionTrial()
            != other.getUserHistoryMaxSuggestionTrial()) return false;
      }
      if (hasUserHistoryEntryLifetimeDays() != other.hasUserHistoryEntryLifetimeDays()) return false;
      if (hasUserHistoryEntryLifetimeDays()) {
        if (getUserHistoryEntryLifetimeDays()
            != other.getUserHistoryEntryLifetimeDays()) return false;
      }
      if (hasUserHistoryCacheStoreSize() != other.hasUserHistoryCacheStoreSize()) return false;
      if (hasUserHistoryCacheStoreSize()) {
        if (getUserHistoryCacheStoreSize()
            != other.getUserHistoryCacheStoreSize()) return false;
      }
      if (hasUserHistoryPartialRevertMode() != other.hasUserHistoryPartialRevertMode()) return false;
      if (hasUserHistoryPartialRevertMode()) {
        if (getUserHistoryPartialRevertMode()
            != other.getUserHistoryPartialRevertMode()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasVariationCharacterTypes()) {
        hash = (37 * hash) + VARIATION_CHARACTER_TYPES_FIELD_NUMBER;
        hash = (53 * hash) + getVariationCharacterTypes();
      }
      if (hasTypingCorrectionResultRerankerMode()) {
        hash = (37 * hash) + TYPING_CORRECTION_RESULT_RERANKER_MODE_FIELD_NUMBER;
        hash = (53 * hash) + getTypingCorrectionResultRerankerMode();
      }
      if (hasTypingCorrectionResultRerankerInterpolationWeight()) {
        hash = (37 * hash) + TYPING_CORRECTION_RESULT_RERANKER_INTERPOLATION_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getTypingCorrectionResultRerankerInterpolationWeight());
      }
      if (hasTypingCorrectionResultRerankerLiteralOnTopWeight()) {
        hash = (37 * hash) + TYPING_CORRECTION_RESULT_RERANKER_LITERAL_ON_TOP_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getTypingCorrectionResultRerankerLiteralOnTopWeight());
      }
      if (hasTypingCorrectionApplyUserHistorySize()) {
        hash = (37 * hash) + TYPING_CORRECTION_APPLY_USER_HISTORY_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getTypingCorrectionApplyUserHistorySize();
      }
      if (hasDisableZeroQuerySuffixPrediction()) {
        hash = (37 * hash) + DISABLE_ZERO_QUERY_SUFFIX_PREDICTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getDisableZeroQuerySuffixPrediction());
      }
      if (hasUserHistoryPredictionMaxCharCoverage()) {
        hash = (37 * hash) + USER_HISTORY_PREDICTION_MAX_CHAR_COVERAGE_FIELD_NUMBER;
        hash = (53 * hash) + getUserHistoryPredictionMaxCharCoverage();
      }
      if (hasEnglishVariationSpaceInsertionMode()) {
        hash = (37 * hash) + ENGLISH_VARIATION_SPACE_INSERTION_MODE_FIELD_NUMBER;
        hash = (53 * hash) + getEnglishVariationSpaceInsertionMode();
      }
      if (hasCandidateConsistencyCostMaxDiff()) {
        hash = (37 * hash) + CANDIDATE_CONSISTENCY_COST_MAX_DIFF_FIELD_NUMBER;
        hash = (53 * hash) + getCandidateConsistencyCostMaxDiff();
      }
      if (hasMaxCompositionEventToProcess()) {
        hash = (37 * hash) + MAX_COMPOSITION_EVENT_TO_PROCESS_FIELD_NUMBER;
        hash = (53 * hash) + getMaxCompositionEventToProcess();
      }
      if (hasKatakanaPromotionOffset()) {
        hash = (37 * hash) + KATAKANA_PROMOTION_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + getKatakanaPromotionOffset();
      }
      if (hasHandwritingConversionCandidateCostOffset()) {
        hash = (37 * hash) + HANDWRITING_CONVERSION_CANDIDATE_COST_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + getHandwritingConversionCandidateCostOffset();
      }
      if (hasSuffixNwpTransitionCostThreshold()) {
        hash = (37 * hash) + SUFFIX_NWP_TRANSITION_COST_THRESHOLD_FIELD_NUMBER;
        hash = (53 * hash) + getSuffixNwpTransitionCostThreshold();
      }
      if (hasUserHistoryMaxSuggestionTrial()) {
        hash = (37 * hash) + USER_HISTORY_MAX_SUGGESTION_TRIAL_FIELD_NUMBER;
        hash = (53 * hash) + getUserHistoryMaxSuggestionTrial();
      }
      if (hasUserHistoryEntryLifetimeDays()) {
        hash = (37 * hash) + USER_HISTORY_ENTRY_LIFETIME_DAYS_FIELD_NUMBER;
        hash = (53 * hash) + getUserHistoryEntryLifetimeDays();
      }
      if (hasUserHistoryCacheStoreSize()) {
        hash = (37 * hash) + USER_HISTORY_CACHE_STORE_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getUserHistoryCacheStoreSize();
      }
      if (hasUserHistoryPartialRevertMode()) {
        hash = (37 * hash) + USER_HISTORY_PARTIAL_REVERT_MODE_FIELD_NUMBER;
        hash = (53 * hash) + getUserHistoryPartialRevertMode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Next ID: 126
     * Bundles together some Android experiment flags so that they can be easily
     * retrieved throughout the native code.  These flags are generally specific to
     * the decoder, and are made available when the decoder is initialized.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.DecoderExperimentParams}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.DecoderExperimentParams)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParamsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DecoderExperimentParams_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DecoderExperimentParams_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        variationCharacterTypes_ = 0;
        typingCorrectionResultRerankerMode_ = 0;
        typingCorrectionResultRerankerInterpolationWeight_ = 0F;
        typingCorrectionResultRerankerLiteralOnTopWeight_ = 0F;
        typingCorrectionApplyUserHistorySize_ = 0;
        disableZeroQuerySuffixPrediction_ = false;
        userHistoryPredictionMaxCharCoverage_ = 0;
        englishVariationSpaceInsertionMode_ = 0;
        candidateConsistencyCostMaxDiff_ = 0;
        maxCompositionEventToProcess_ = 2;
        katakanaPromotionOffset_ = 5;
        handwritingConversionCandidateCostOffset_ = 1151;
        suffixNwpTransitionCostThreshold_ = 0;
        userHistoryMaxSuggestionTrial_ = 0;
        userHistoryEntryLifetimeDays_ = 0;
        userHistoryCacheStoreSize_ = 0;
        userHistoryPartialRevertMode_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DecoderExperimentParams_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.variationCharacterTypes_ = variationCharacterTypes_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.typingCorrectionResultRerankerMode_ = typingCorrectionResultRerankerMode_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.typingCorrectionResultRerankerInterpolationWeight_ = typingCorrectionResultRerankerInterpolationWeight_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.typingCorrectionResultRerankerLiteralOnTopWeight_ = typingCorrectionResultRerankerLiteralOnTopWeight_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.typingCorrectionApplyUserHistorySize_ = typingCorrectionApplyUserHistorySize_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.disableZeroQuerySuffixPrediction_ = disableZeroQuerySuffixPrediction_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.userHistoryPredictionMaxCharCoverage_ = userHistoryPredictionMaxCharCoverage_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.englishVariationSpaceInsertionMode_ = englishVariationSpaceInsertionMode_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.candidateConsistencyCostMaxDiff_ = candidateConsistencyCostMaxDiff_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.maxCompositionEventToProcess_ = maxCompositionEventToProcess_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.katakanaPromotionOffset_ = katakanaPromotionOffset_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.handwritingConversionCandidateCostOffset_ = handwritingConversionCandidateCostOffset_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.suffixNwpTransitionCostThreshold_ = suffixNwpTransitionCostThreshold_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.userHistoryMaxSuggestionTrial_ = userHistoryMaxSuggestionTrial_;
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.userHistoryEntryLifetimeDays_ = userHistoryEntryLifetimeDays_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.userHistoryCacheStoreSize_ = userHistoryCacheStoreSize_;
          to_bitField0_ |= 0x00008000;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.userHistoryPartialRevertMode_ = userHistoryPartialRevertMode_;
          to_bitField0_ |= 0x00010000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDefaultInstance()) return this;
        if (other.hasVariationCharacterTypes()) {
          setVariationCharacterTypes(other.getVariationCharacterTypes());
        }
        if (other.hasTypingCorrectionResultRerankerMode()) {
          setTypingCorrectionResultRerankerMode(other.getTypingCorrectionResultRerankerMode());
        }
        if (other.hasTypingCorrectionResultRerankerInterpolationWeight()) {
          setTypingCorrectionResultRerankerInterpolationWeight(other.getTypingCorrectionResultRerankerInterpolationWeight());
        }
        if (other.hasTypingCorrectionResultRerankerLiteralOnTopWeight()) {
          setTypingCorrectionResultRerankerLiteralOnTopWeight(other.getTypingCorrectionResultRerankerLiteralOnTopWeight());
        }
        if (other.hasTypingCorrectionApplyUserHistorySize()) {
          setTypingCorrectionApplyUserHistorySize(other.getTypingCorrectionApplyUserHistorySize());
        }
        if (other.hasDisableZeroQuerySuffixPrediction()) {
          setDisableZeroQuerySuffixPrediction(other.getDisableZeroQuerySuffixPrediction());
        }
        if (other.hasUserHistoryPredictionMaxCharCoverage()) {
          setUserHistoryPredictionMaxCharCoverage(other.getUserHistoryPredictionMaxCharCoverage());
        }
        if (other.hasEnglishVariationSpaceInsertionMode()) {
          setEnglishVariationSpaceInsertionMode(other.getEnglishVariationSpaceInsertionMode());
        }
        if (other.hasCandidateConsistencyCostMaxDiff()) {
          setCandidateConsistencyCostMaxDiff(other.getCandidateConsistencyCostMaxDiff());
        }
        if (other.hasMaxCompositionEventToProcess()) {
          setMaxCompositionEventToProcess(other.getMaxCompositionEventToProcess());
        }
        if (other.hasKatakanaPromotionOffset()) {
          setKatakanaPromotionOffset(other.getKatakanaPromotionOffset());
        }
        if (other.hasHandwritingConversionCandidateCostOffset()) {
          setHandwritingConversionCandidateCostOffset(other.getHandwritingConversionCandidateCostOffset());
        }
        if (other.hasSuffixNwpTransitionCostThreshold()) {
          setSuffixNwpTransitionCostThreshold(other.getSuffixNwpTransitionCostThreshold());
        }
        if (other.hasUserHistoryMaxSuggestionTrial()) {
          setUserHistoryMaxSuggestionTrial(other.getUserHistoryMaxSuggestionTrial());
        }
        if (other.hasUserHistoryEntryLifetimeDays()) {
          setUserHistoryEntryLifetimeDays(other.getUserHistoryEntryLifetimeDays());
        }
        if (other.hasUserHistoryCacheStoreSize()) {
          setUserHistoryCacheStoreSize(other.getUserHistoryCacheStoreSize());
        }
        if (other.hasUserHistoryPartialRevertMode()) {
          setUserHistoryPartialRevertMode(other.getUserHistoryPartialRevertMode());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 64: {
                variationCharacterTypes_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 64
              case 288: {
                disableZeroQuerySuffixPrediction_ = input.readBool();
                bitField0_ |= 0x00000020;
                break;
              } // case 288
              case 440: {
                englishVariationSpaceInsertionMode_ = input.readInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 440
              case 504: {
                candidateConsistencyCostMaxDiff_ = input.readInt32();
                bitField0_ |= 0x00000100;
                break;
              } // case 504
              case 512: {
                maxCompositionEventToProcess_ = input.readInt32();
                bitField0_ |= 0x00000200;
                break;
              } // case 512
              case 656: {
                userHistoryPredictionMaxCharCoverage_ = input.readInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 656
              case 664: {
                katakanaPromotionOffset_ = input.readInt32();
                bitField0_ |= 0x00000400;
                break;
              } // case 664
              case 680: {
                typingCorrectionApplyUserHistorySize_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 680
              case 760: {
                typingCorrectionResultRerankerMode_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 760
              case 805: {
                typingCorrectionResultRerankerInterpolationWeight_ = input.readFloat();
                bitField0_ |= 0x00000004;
                break;
              } // case 805
              case 813: {
                typingCorrectionResultRerankerLiteralOnTopWeight_ = input.readFloat();
                bitField0_ |= 0x00000008;
                break;
              } // case 813
              case 816: {
                handwritingConversionCandidateCostOffset_ = input.readInt32();
                bitField0_ |= 0x00000800;
                break;
              } // case 816
              case 856: {
                suffixNwpTransitionCostThreshold_ = input.readInt32();
                bitField0_ |= 0x00001000;
                break;
              } // case 856
              case 864: {
                userHistoryMaxSuggestionTrial_ = input.readInt32();
                bitField0_ |= 0x00002000;
                break;
              } // case 864
              case 872: {
                userHistoryEntryLifetimeDays_ = input.readInt32();
                bitField0_ |= 0x00004000;
                break;
              } // case 872
              case 880: {
                userHistoryCacheStoreSize_ = input.readInt32();
                bitField0_ |= 0x00008000;
                break;
              } // case 880
              case 1000: {
                userHistoryPartialRevertMode_ = input.readInt32();
                bitField0_ |= 0x00010000;
                break;
              } // case 1000
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int variationCharacterTypes_ ;
      /**
       * <pre>
       * Bitmap of enabled variation character types.
       * </pre>
       *
       * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
       * @return Whether the variationCharacterTypes field is set.
       */
      @java.lang.Override
      public boolean hasVariationCharacterTypes() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Bitmap of enabled variation character types.
       * </pre>
       *
       * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
       * @return The variationCharacterTypes.
       */
      @java.lang.Override
      public int getVariationCharacterTypes() {
        return variationCharacterTypes_;
      }
      /**
       * <pre>
       * Bitmap of enabled variation character types.
       * </pre>
       *
       * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
       * @param value The variationCharacterTypes to set.
       * @return This builder for chaining.
       */
      public Builder setVariationCharacterTypes(int value) {
        
        variationCharacterTypes_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Bitmap of enabled variation character types.
       * </pre>
       *
       * <code>optional uint32 variation_character_types = 8 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearVariationCharacterTypes() {
        bitField0_ = (bitField0_ & ~0x00000001);
        variationCharacterTypes_ = 0;
        onChanged();
        return this;
      }

      private int typingCorrectionResultRerankerMode_ ;
      /**
       * <pre>
       * Enables final results reranking against literal results.
       * If zero, the previous implementation is used.
       * </pre>
       *
       * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
       * @return Whether the typingCorrectionResultRerankerMode field is set.
       */
      @java.lang.Override
      public boolean hasTypingCorrectionResultRerankerMode() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Enables final results reranking against literal results.
       * If zero, the previous implementation is used.
       * </pre>
       *
       * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
       * @return The typingCorrectionResultRerankerMode.
       */
      @java.lang.Override
      public int getTypingCorrectionResultRerankerMode() {
        return typingCorrectionResultRerankerMode_;
      }
      /**
       * <pre>
       * Enables final results reranking against literal results.
       * If zero, the previous implementation is used.
       * </pre>
       *
       * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
       * @param value The typingCorrectionResultRerankerMode to set.
       * @return This builder for chaining.
       */
      public Builder setTypingCorrectionResultRerankerMode(int value) {
        
        typingCorrectionResultRerankerMode_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Enables final results reranking against literal results.
       * If zero, the previous implementation is used.
       * </pre>
       *
       * <code>optional int32 typing_correction_result_reranker_mode = 95 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearTypingCorrectionResultRerankerMode() {
        bitField0_ = (bitField0_ & ~0x00000002);
        typingCorrectionResultRerankerMode_ = 0;
        onChanged();
        return this;
      }

      private float typingCorrectionResultRerankerInterpolationWeight_ ;
      /**
       * <pre>
       * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
       * @return Whether the typingCorrectionResultRerankerInterpolationWeight field is set.
       */
      @java.lang.Override
      public boolean hasTypingCorrectionResultRerankerInterpolationWeight() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
       * @return The typingCorrectionResultRerankerInterpolationWeight.
       */
      @java.lang.Override
      public float getTypingCorrectionResultRerankerInterpolationWeight() {
        return typingCorrectionResultRerankerInterpolationWeight_;
      }
      /**
       * <pre>
       * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
       * @param value The typingCorrectionResultRerankerInterpolationWeight to set.
       * @return This builder for chaining.
       */
      public Builder setTypingCorrectionResultRerankerInterpolationWeight(float value) {
        
        typingCorrectionResultRerankerInterpolationWeight_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff &gt; 0.0.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_interpolation_weight = 100 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearTypingCorrectionResultRerankerInterpolationWeight() {
        bitField0_ = (bitField0_ & ~0x00000004);
        typingCorrectionResultRerankerInterpolationWeight_ = 0F;
        onChanged();
        return this;
      }

      private float typingCorrectionResultRerankerLiteralOnTopWeight_ ;
      /**
       * <pre>
       * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
       * &gt; 0.0. otherwise, runs literal-on-top.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
       * @return Whether the typingCorrectionResultRerankerLiteralOnTopWeight field is set.
       */
      @java.lang.Override
      public boolean hasTypingCorrectionResultRerankerLiteralOnTopWeight() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
       * &gt; 0.0. otherwise, runs literal-on-top.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
       * @return The typingCorrectionResultRerankerLiteralOnTopWeight.
       */
      @java.lang.Override
      public float getTypingCorrectionResultRerankerLiteralOnTopWeight() {
        return typingCorrectionResultRerankerLiteralOnTopWeight_;
      }
      /**
       * <pre>
       * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
       * &gt; 0.0. otherwise, runs literal-on-top.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
       * @param value The typingCorrectionResultRerankerLiteralOnTopWeight to set.
       * @return This builder for chaining.
       */
      public Builder setTypingCorrectionResultRerankerLiteralOnTopWeight(float value) {
        
        typingCorrectionResultRerankerLiteralOnTopWeight_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
       * &gt; 0.0. otherwise, runs literal-on-top.
       * </pre>
       *
       * <code>optional float typing_correction_result_reranker_literal_on_top_weight = 101 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearTypingCorrectionResultRerankerLiteralOnTopWeight() {
        bitField0_ = (bitField0_ & ~0x00000008);
        typingCorrectionResultRerankerLiteralOnTopWeight_ = 0F;
        onChanged();
        return this;
      }

      private int typingCorrectionApplyUserHistorySize_ ;
      /**
       * <pre>
       * Uses the typing correction in user history predictor. The size specifies
       * the maximum number of typing corrections used for query lookup.
       * When zero, typing_correction is not used.
       * </pre>
       *
       * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
       * @return Whether the typingCorrectionApplyUserHistorySize field is set.
       */
      @java.lang.Override
      public boolean hasTypingCorrectionApplyUserHistorySize() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Uses the typing correction in user history predictor. The size specifies
       * the maximum number of typing corrections used for query lookup.
       * When zero, typing_correction is not used.
       * </pre>
       *
       * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
       * @return The typingCorrectionApplyUserHistorySize.
       */
      @java.lang.Override
      public int getTypingCorrectionApplyUserHistorySize() {
        return typingCorrectionApplyUserHistorySize_;
      }
      /**
       * <pre>
       * Uses the typing correction in user history predictor. The size specifies
       * the maximum number of typing corrections used for query lookup.
       * When zero, typing_correction is not used.
       * </pre>
       *
       * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
       * @param value The typingCorrectionApplyUserHistorySize to set.
       * @return This builder for chaining.
       */
      public Builder setTypingCorrectionApplyUserHistorySize(int value) {
        
        typingCorrectionApplyUserHistorySize_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Uses the typing correction in user history predictor. The size specifies
       * the maximum number of typing corrections used for query lookup.
       * When zero, typing_correction is not used.
       * </pre>
       *
       * <code>optional int32 typing_correction_apply_user_history_size = 85 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearTypingCorrectionApplyUserHistorySize() {
        bitField0_ = (bitField0_ & ~0x00000010);
        typingCorrectionApplyUserHistorySize_ = 0;
        onChanged();
        return this;
      }

      private boolean disableZeroQuerySuffixPrediction_ ;
      /**
       * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
       * @return Whether the disableZeroQuerySuffixPrediction field is set.
       */
      @java.lang.Override
      public boolean hasDisableZeroQuerySuffixPrediction() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
       * @return The disableZeroQuerySuffixPrediction.
       */
      @java.lang.Override
      public boolean getDisableZeroQuerySuffixPrediction() {
        return disableZeroQuerySuffixPrediction_;
      }
      /**
       * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
       * @param value The disableZeroQuerySuffixPrediction to set.
       * @return This builder for chaining.
       */
      public Builder setDisableZeroQuerySuffixPrediction(boolean value) {
        
        disableZeroQuerySuffixPrediction_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool disable_zero_query_suffix_prediction = 36 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDisableZeroQuerySuffixPrediction() {
        bitField0_ = (bitField0_ & ~0x00000020);
        disableZeroQuerySuffixPrediction_ = false;
        onChanged();
        return this;
      }

      private int userHistoryPredictionMaxCharCoverage_ ;
      /**
       * <pre>
       * Changes the size of history with character coverage.
       * </pre>
       *
       * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
       * @return Whether the userHistoryPredictionMaxCharCoverage field is set.
       */
      @java.lang.Override
      public boolean hasUserHistoryPredictionMaxCharCoverage() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Changes the size of history with character coverage.
       * </pre>
       *
       * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
       * @return The userHistoryPredictionMaxCharCoverage.
       */
      @java.lang.Override
      public int getUserHistoryPredictionMaxCharCoverage() {
        return userHistoryPredictionMaxCharCoverage_;
      }
      /**
       * <pre>
       * Changes the size of history with character coverage.
       * </pre>
       *
       * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
       * @param value The userHistoryPredictionMaxCharCoverage to set.
       * @return This builder for chaining.
       */
      public Builder setUserHistoryPredictionMaxCharCoverage(int value) {
        
        userHistoryPredictionMaxCharCoverage_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Changes the size of history with character coverage.
       * </pre>
       *
       * <code>optional int32 user_history_prediction_max_char_coverage = 82 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearUserHistoryPredictionMaxCharCoverage() {
        bitField0_ = (bitField0_ & ~0x00000040);
        userHistoryPredictionMaxCharCoverage_ = 0;
        onChanged();
        return this;
      }

      private int englishVariationSpaceInsertionMode_ ;
      /**
       * <pre>
       * Parameter for space-insertion for English compounds
       * value 0: no insertion. Candidates will be like this.
       * - "Google"
       * - "GOOGLE"
       * - "google"
       * value 1: expand for all English candidates
       * This mode adds space-prefixed candidates for three style, like this.
       * - "Google"
       * - " Google"
       * - "GOOGLE"
       * - " GOOGLE"
       * - "google"
       * - " google"
       * </pre>
       *
       * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
       * @return Whether the englishVariationSpaceInsertionMode field is set.
       */
      @java.lang.Override
      public boolean hasEnglishVariationSpaceInsertionMode() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Parameter for space-insertion for English compounds
       * value 0: no insertion. Candidates will be like this.
       * - "Google"
       * - "GOOGLE"
       * - "google"
       * value 1: expand for all English candidates
       * This mode adds space-prefixed candidates for three style, like this.
       * - "Google"
       * - " Google"
       * - "GOOGLE"
       * - " GOOGLE"
       * - "google"
       * - " google"
       * </pre>
       *
       * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
       * @return The englishVariationSpaceInsertionMode.
       */
      @java.lang.Override
      public int getEnglishVariationSpaceInsertionMode() {
        return englishVariationSpaceInsertionMode_;
      }
      /**
       * <pre>
       * Parameter for space-insertion for English compounds
       * value 0: no insertion. Candidates will be like this.
       * - "Google"
       * - "GOOGLE"
       * - "google"
       * value 1: expand for all English candidates
       * This mode adds space-prefixed candidates for three style, like this.
       * - "Google"
       * - " Google"
       * - "GOOGLE"
       * - " GOOGLE"
       * - "google"
       * - " google"
       * </pre>
       *
       * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
       * @param value The englishVariationSpaceInsertionMode to set.
       * @return This builder for chaining.
       */
      public Builder setEnglishVariationSpaceInsertionMode(int value) {
        
        englishVariationSpaceInsertionMode_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Parameter for space-insertion for English compounds
       * value 0: no insertion. Candidates will be like this.
       * - "Google"
       * - "GOOGLE"
       * - "google"
       * value 1: expand for all English candidates
       * This mode adds space-prefixed candidates for three style, like this.
       * - "Google"
       * - " Google"
       * - "GOOGLE"
       * - " GOOGLE"
       * - "google"
       * - " google"
       * </pre>
       *
       * <code>optional int32 english_variation_space_insertion_mode = 55 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearEnglishVariationSpaceInsertionMode() {
        bitField0_ = (bitField0_ & ~0x00000080);
        englishVariationSpaceInsertionMode_ = 0;
        onChanged();
        return this;
      }

      private int candidateConsistencyCostMaxDiff_ ;
      /**
       * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
       * @return Whether the candidateConsistencyCostMaxDiff field is set.
       */
      @java.lang.Override
      public boolean hasCandidateConsistencyCostMaxDiff() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
       * @return The candidateConsistencyCostMaxDiff.
       */
      @java.lang.Override
      public int getCandidateConsistencyCostMaxDiff() {
        return candidateConsistencyCostMaxDiff_;
      }
      /**
       * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
       * @param value The candidateConsistencyCostMaxDiff to set.
       * @return This builder for chaining.
       */
      public Builder setCandidateConsistencyCostMaxDiff(int value) {
        
        candidateConsistencyCostMaxDiff_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 candidate_consistency_cost_max_diff = 63 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearCandidateConsistencyCostMaxDiff() {
        bitField0_ = (bitField0_ & ~0x00000100);
        candidateConsistencyCostMaxDiff_ = 0;
        onChanged();
        return this;
      }

      private int maxCompositionEventToProcess_ = 2;
      /**
       * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
       * @return Whether the maxCompositionEventToProcess field is set.
       */
      @java.lang.Override
      public boolean hasMaxCompositionEventToProcess() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
       * @return The maxCompositionEventToProcess.
       */
      @java.lang.Override
      public int getMaxCompositionEventToProcess() {
        return maxCompositionEventToProcess_;
      }
      /**
       * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
       * @param value The maxCompositionEventToProcess to set.
       * @return This builder for chaining.
       */
      public Builder setMaxCompositionEventToProcess(int value) {
        
        maxCompositionEventToProcess_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 max_composition_event_to_process = 64 [default = 2];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxCompositionEventToProcess() {
        bitField0_ = (bitField0_ & ~0x00000200);
        maxCompositionEventToProcess_ = 2;
        onChanged();
        return this;
      }

      private int katakanaPromotionOffset_ = 5;
      /**
       * <pre>
       * Offset to promote Katakana candidates in rewriter.
       * The promotion will be disabled if the value is negative.
       * </pre>
       *
       * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
       * @return Whether the katakanaPromotionOffset field is set.
       */
      @java.lang.Override
      public boolean hasKatakanaPromotionOffset() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Offset to promote Katakana candidates in rewriter.
       * The promotion will be disabled if the value is negative.
       * </pre>
       *
       * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
       * @return The katakanaPromotionOffset.
       */
      @java.lang.Override
      public int getKatakanaPromotionOffset() {
        return katakanaPromotionOffset_;
      }
      /**
       * <pre>
       * Offset to promote Katakana candidates in rewriter.
       * The promotion will be disabled if the value is negative.
       * </pre>
       *
       * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
       * @param value The katakanaPromotionOffset to set.
       * @return This builder for chaining.
       */
      public Builder setKatakanaPromotionOffset(int value) {
        
        katakanaPromotionOffset_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Offset to promote Katakana candidates in rewriter.
       * The promotion will be disabled if the value is negative.
       * </pre>
       *
       * <code>optional int32 katakana_promotion_offset = 83 [default = 5];</code>
       * @return This builder for chaining.
       */
      public Builder clearKatakanaPromotionOffset() {
        bitField0_ = (bitField0_ & ~0x00000400);
        katakanaPromotionOffset_ = 5;
        onChanged();
        return this;
      }

      private int handwritingConversionCandidateCostOffset_ = 1151;
      /**
       * <pre>
       * Cost offset for handwriting conversion candidate.
       * default_value: 10*log(500)
       * </pre>
       *
       * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
       * @return Whether the handwritingConversionCandidateCostOffset field is set.
       */
      @java.lang.Override
      public boolean hasHandwritingConversionCandidateCostOffset() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Cost offset for handwriting conversion candidate.
       * default_value: 10*log(500)
       * </pre>
       *
       * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
       * @return The handwritingConversionCandidateCostOffset.
       */
      @java.lang.Override
      public int getHandwritingConversionCandidateCostOffset() {
        return handwritingConversionCandidateCostOffset_;
      }
      /**
       * <pre>
       * Cost offset for handwriting conversion candidate.
       * default_value: 10*log(500)
       * </pre>
       *
       * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
       * @param value The handwritingConversionCandidateCostOffset to set.
       * @return This builder for chaining.
       */
      public Builder setHandwritingConversionCandidateCostOffset(int value) {
        
        handwritingConversionCandidateCostOffset_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Cost offset for handwriting conversion candidate.
       * default_value: 10*log(500)
       * </pre>
       *
       * <code>optional int32 handwriting_conversion_candidate_cost_offset = 102 [default = 1151];</code>
       * @return This builder for chaining.
       */
      public Builder clearHandwritingConversionCandidateCostOffset() {
        bitField0_ = (bitField0_ & ~0x00000800);
        handwritingConversionCandidateCostOffset_ = 1151;
        onChanged();
        return this;
      }

      private int suffixNwpTransitionCostThreshold_ ;
      /**
       * <pre>
       * Threshold for suffix NWP transition cost.
       * If the transition cost is greater than this value, the candidate will be
       * filtered.
       * The candidate will not be filtered if this value is zero.
       * </pre>
       *
       * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
       * @return Whether the suffixNwpTransitionCostThreshold field is set.
       */
      @java.lang.Override
      public boolean hasSuffixNwpTransitionCostThreshold() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Threshold for suffix NWP transition cost.
       * If the transition cost is greater than this value, the candidate will be
       * filtered.
       * The candidate will not be filtered if this value is zero.
       * </pre>
       *
       * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
       * @return The suffixNwpTransitionCostThreshold.
       */
      @java.lang.Override
      public int getSuffixNwpTransitionCostThreshold() {
        return suffixNwpTransitionCostThreshold_;
      }
      /**
       * <pre>
       * Threshold for suffix NWP transition cost.
       * If the transition cost is greater than this value, the candidate will be
       * filtered.
       * The candidate will not be filtered if this value is zero.
       * </pre>
       *
       * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
       * @param value The suffixNwpTransitionCostThreshold to set.
       * @return This builder for chaining.
       */
      public Builder setSuffixNwpTransitionCostThreshold(int value) {
        
        suffixNwpTransitionCostThreshold_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Threshold for suffix NWP transition cost.
       * If the transition cost is greater than this value, the candidate will be
       * filtered.
       * The candidate will not be filtered if this value is zero.
       * </pre>
       *
       * <code>optional int32 suffix_nwp_transition_cost_threshold = 107 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearSuffixNwpTransitionCostThreshold() {
        bitField0_ = (bitField0_ & ~0x00001000);
        suffixNwpTransitionCostThreshold_ = 0;
        onChanged();
        return this;
      }

      private int userHistoryMaxSuggestionTrial_ ;
      /**
       * <pre>
       * How many initial LRU entries to look up.
       * We use a simple linear-search on LRU.
       * When zero, default value (3000) is used.
       * </pre>
       *
       * <code>optional int32 user_history_max_suggestion_trial = 108 [default = 0];</code>
       * @return Whether the userHistoryMaxSuggestionTrial field is set.
       */
      @java.lang.Override
      public boolean hasUserHistoryMaxSuggestionTrial() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * How many initial LRU entries to look up.
       * We use a simple linear-search on LRU.
       * When zero, default value (3000) is used.
       * </pre>
       *
       * <code>optional int32 user_history_max_suggestion_trial = 108 [default = 0];</code>
       * @return The userHistoryMaxSuggestionTrial.
       */
      @java.lang.Override
      public int getUserHistoryMaxSuggestionTrial() {
        return userHistoryMaxSuggestionTrial_;
      }
      /**
       * <pre>
       * How many initial LRU entries to look up.
       * We use a simple linear-search on LRU.
       * When zero, default value (3000) is used.
       * </pre>
       *
       * <code>optional int32 user_history_max_suggestion_trial = 108 [default = 0];</code>
       * @param value The userHistoryMaxSuggestionTrial to set.
       * @return This builder for chaining.
       */
      public Builder setUserHistoryMaxSuggestionTrial(int value) {
        
        userHistoryMaxSuggestionTrial_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * How many initial LRU entries to look up.
       * We use a simple linear-search on LRU.
       * When zero, default value (3000) is used.
       * </pre>
       *
       * <code>optional int32 user_history_max_suggestion_trial = 108 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearUserHistoryMaxSuggestionTrial() {
        bitField0_ = (bitField0_ & ~0x00002000);
        userHistoryMaxSuggestionTrial_ = 0;
        onChanged();
        return this;
      }

      private int userHistoryEntryLifetimeDays_ ;
      /**
       * <pre>
       * The maximum lifetime of the entries.
       * When zero, default value (62) is used.
       * </pre>
       *
       * <code>optional int32 user_history_entry_lifetime_days = 109 [default = 0];</code>
       * @return Whether the userHistoryEntryLifetimeDays field is set.
       */
      @java.lang.Override
      public boolean hasUserHistoryEntryLifetimeDays() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * The maximum lifetime of the entries.
       * When zero, default value (62) is used.
       * </pre>
       *
       * <code>optional int32 user_history_entry_lifetime_days = 109 [default = 0];</code>
       * @return The userHistoryEntryLifetimeDays.
       */
      @java.lang.Override
      public int getUserHistoryEntryLifetimeDays() {
        return userHistoryEntryLifetimeDays_;
      }
      /**
       * <pre>
       * The maximum lifetime of the entries.
       * When zero, default value (62) is used.
       * </pre>
       *
       * <code>optional int32 user_history_entry_lifetime_days = 109 [default = 0];</code>
       * @param value The userHistoryEntryLifetimeDays to set.
       * @return This builder for chaining.
       */
      public Builder setUserHistoryEntryLifetimeDays(int value) {
        
        userHistoryEntryLifetimeDays_ = value;
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum lifetime of the entries.
       * When zero, default value (62) is used.
       * </pre>
       *
       * <code>optional int32 user_history_entry_lifetime_days = 109 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearUserHistoryEntryLifetimeDays() {
        bitField0_ = (bitField0_ & ~0x00004000);
        userHistoryEntryLifetimeDays_ = 0;
        onChanged();
        return this;
      }

      private int userHistoryCacheStoreSize_ ;
      /**
       * <pre>
       * The maximum size of entries actually saved to disk.
       * When zero, store all entries in the on-memory LRU.
       * </pre>
       *
       * <code>optional int32 user_history_cache_store_size = 110 [default = 0];</code>
       * @return Whether the userHistoryCacheStoreSize field is set.
       */
      @java.lang.Override
      public boolean hasUserHistoryCacheStoreSize() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * The maximum size of entries actually saved to disk.
       * When zero, store all entries in the on-memory LRU.
       * </pre>
       *
       * <code>optional int32 user_history_cache_store_size = 110 [default = 0];</code>
       * @return The userHistoryCacheStoreSize.
       */
      @java.lang.Override
      public int getUserHistoryCacheStoreSize() {
        return userHistoryCacheStoreSize_;
      }
      /**
       * <pre>
       * The maximum size of entries actually saved to disk.
       * When zero, store all entries in the on-memory LRU.
       * </pre>
       *
       * <code>optional int32 user_history_cache_store_size = 110 [default = 0];</code>
       * @param value The userHistoryCacheStoreSize to set.
       * @return This builder for chaining.
       */
      public Builder setUserHistoryCacheStoreSize(int value) {
        
        userHistoryCacheStoreSize_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum size of entries actually saved to disk.
       * When zero, store all entries in the on-memory LRU.
       * </pre>
       *
       * <code>optional int32 user_history_cache_store_size = 110 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearUserHistoryCacheStoreSize() {
        bitField0_ = (bitField0_ & ~0x00008000);
        userHistoryCacheStoreSize_ = 0;
        onChanged();
        return this;
      }

      private int userHistoryPartialRevertMode_ ;
      /**
       * <pre>
       * The mode of partial revert. When zero, partial revert is not enabled.
       * </pre>
       *
       * <code>optional int32 user_history_partial_revert_mode = 125 [default = 0];</code>
       * @return Whether the userHistoryPartialRevertMode field is set.
       */
      @java.lang.Override
      public boolean hasUserHistoryPartialRevertMode() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * The mode of partial revert. When zero, partial revert is not enabled.
       * </pre>
       *
       * <code>optional int32 user_history_partial_revert_mode = 125 [default = 0];</code>
       * @return The userHistoryPartialRevertMode.
       */
      @java.lang.Override
      public int getUserHistoryPartialRevertMode() {
        return userHistoryPartialRevertMode_;
      }
      /**
       * <pre>
       * The mode of partial revert. When zero, partial revert is not enabled.
       * </pre>
       *
       * <code>optional int32 user_history_partial_revert_mode = 125 [default = 0];</code>
       * @param value The userHistoryPartialRevertMode to set.
       * @return This builder for chaining.
       */
      public Builder setUserHistoryPartialRevertMode(int value) {
        
        userHistoryPartialRevertMode_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The mode of partial revert. When zero, partial revert is not enabled.
       * </pre>
       *
       * <code>optional int32 user_history_partial_revert_mode = 125 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearUserHistoryPartialRevertMode() {
        bitField0_ = (bitField0_ & ~0x00010000);
        userHistoryPartialRevertMode_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.DecoderExperimentParams)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.DecoderExperimentParams)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DecoderExperimentParams>
        PARSER = new com.google.protobuf.AbstractParser<DecoderExperimentParams>() {
      @java.lang.Override
      public DecoderExperimentParams parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DecoderExperimentParams> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DecoderExperimentParams> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Request)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     * @return Whether the zeroQuerySuggestion field is set.
     */
    boolean hasZeroQuerySuggestion();
    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     * @return The zeroQuerySuggestion.
     */
    boolean getZeroQuerySuggestion();

    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     * @return Whether the mixedConversion field is set.
     */
    boolean hasMixedConversion();
    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     * @return The mixedConversion.
     */
    boolean getMixedConversion();

    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     * @return Whether the specialRomanjiTable field is set.
     */
    boolean hasSpecialRomanjiTable();
    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     * @return The specialRomanjiTable.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable getSpecialRomanjiTable();

    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     * @return Whether the spaceOnAlphanumeric field is set.
     */
    boolean hasSpaceOnAlphanumeric();
    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     * @return The spaceOnAlphanumeric.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric getSpaceOnAlphanumeric();

    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return Whether the keyboardName field is set.
     */
    boolean hasKeyboardName();
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return The keyboardName.
     */
    java.lang.String getKeyboardName();
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return The bytes for keyboardName.
     */
    com.google.protobuf.ByteString
        getKeyboardNameBytes();

    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     * @return Whether the updateInputModeFromSurroundingText field is set.
     */
    boolean hasUpdateInputModeFromSurroundingText();
    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     * @return The updateInputModeFromSurroundingText.
     */
    boolean getUpdateInputModeFromSurroundingText();

    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     * @return Whether the kanaModifierInsensitiveConversion field is set.
     */
    boolean hasKanaModifierInsensitiveConversion();
    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     * @return The kanaModifierInsensitiveConversion.
     */
    boolean getKanaModifierInsensitiveConversion();

    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     * @return Whether the autoPartialSuggestion field is set.
     */
    boolean hasAutoPartialSuggestion();
    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     * @return The autoPartialSuggestion.
     */
    boolean getAutoPartialSuggestion();

    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     * @return Whether the emojiRewriterCapability field is set.
     */
    boolean hasEmojiRewriterCapability();
    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     * @return The emojiRewriterCapability.
     */
    int getEmojiRewriterCapability();

    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     * @return Whether the crossingEdgeBehavior field is set.
     */
    boolean hasCrossingEdgeBehavior();
    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     * @return The crossingEdgeBehavior.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior getCrossingEdgeBehavior();

    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     * @return Whether the languageAwareInput field is set.
     */
    boolean hasLanguageAwareInput();
    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     * @return The languageAwareInput.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior getLanguageAwareInput();

    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     * @return Whether the candidatePageSize field is set.
     */
    boolean hasCandidatePageSize();
    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     * @return The candidatePageSize.
     */
    int getCandidatePageSize();

    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     * @return Whether the candidatesSizeLimit field is set.
     */
    boolean hasCandidatesSizeLimit();
    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     * @return The candidatesSizeLimit.
     */
    int getCandidatesSizeLimit();

    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     * @return Whether the decoderExperimentParams field is set.
     */
    boolean hasDecoderExperimentParams();
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     * @return The decoderExperimentParams.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDecoderExperimentParams();
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParamsOrBuilder getDecoderExperimentParamsOrBuilder();

    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     * @return Whether the fillIncognitoCandidateWords field is set.
     */
    boolean hasFillIncognitoCandidateWords();
    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     * @return The fillIncognitoCandidateWords.
     */
    boolean getFillIncognitoCandidateWords();

    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     * @return Whether the enableA11yDescription field is set.
     */
    boolean hasEnableA11YDescription();
    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     * @return The enableA11yDescription.
     */
    boolean getEnableA11YDescription();

    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @return A list containing the additionalRenderableCharacterGroups.
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> getAdditionalRenderableCharacterGroupsList();
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @return The count of additionalRenderableCharacterGroups.
     */
    int getAdditionalRenderableCharacterGroupsCount();
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The additionalRenderableCharacterGroups at the given index.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup getAdditionalRenderableCharacterGroups(int index);

    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     * @return Whether the isHandwriting field is set.
     */
    boolean hasIsHandwriting();
    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     * @return The isHandwriting.
     */
    boolean getIsHandwriting();

    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     * @return Whether the isIncognitoMode field is set.
     */
    boolean hasIsIncognitoMode();
    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     * @return The isIncognitoMode.
     */
    boolean getIsIncognitoMode();
  }
  /**
   * <pre>
   * Clients' request to the server.
   * Users cannot modify this.
   * In the future each request may be able to be overwritten by Config.
   * The server does not have to obey this request.
   * Next ID: 24
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Request}
   */
  public static final class Request extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Request)
      RequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Request.newBuilder() to construct.
    private Request(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Request() {
      specialRomanjiTable_ = 0;
      spaceOnAlphanumeric_ = 0;
      keyboardName_ = "";
      updateInputModeFromSurroundingText_ = true;
      emojiRewriterCapability_ = 1;
      crossingEdgeBehavior_ = 0;
      languageAwareInput_ = 0;
      candidatePageSize_ = 9;
      additionalRenderableCharacterGroups_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Request();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Request_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Request_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.Builder.class);
    }

    /**
     * <pre>
     * Next ID: 51
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.SpecialRomanjiTable}
     */
    public enum SpecialRomanjiTable
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Do not use special table.
       * Romanji table is selected based on Config.
       * </pre>
       *
       * <code>DEFAULT_TABLE = 0;</code>
       */
      DEFAULT_TABLE(0),
      /**
       * <pre>
       * Use special table for 12keys (to hiragana).
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HIRAGANA = 10;</code>
       */
      TWELVE_KEYS_TO_HIRAGANA(10),
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current 12keys-to-hiragana table.
       * TODO(noriyukit): Replace TWELVE_KEYS_TO_HIRAGANA by this.
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HIRAGANA_INTUITIVE = 10000;</code>
       */
      TWELVE_KEYS_TO_HIRAGANA_INTUITIVE(10000),
      /**
       * <pre>
       * Use special table for 12keys (to half-width ascii).
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HALFWIDTHASCII = 11;</code>
       */
      TWELVE_KEYS_TO_HALFWIDTHASCII(11),
      /**
       * <pre>
       * Use special table for flick (to hiragana).
       * </pre>
       *
       * <code>FLICK_TO_HIRAGANA = 13;</code>
       */
      FLICK_TO_HIRAGANA(13),
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current flick-to-hiragana table.
       * TODO(noriyukit): Replace FLICK_TO_HIRAGANA by this.
       * </pre>
       *
       * <code>FLICK_TO_HIRAGANA_INTUITIVE = 10002;</code>
       */
      FLICK_TO_HIRAGANA_INTUITIVE(10002),
      /**
       * <pre>
       * Use special table for flick (to half-width ascii).
       * </pre>
       *
       * <code>FLICK_TO_HALFWIDTHASCII = 14;</code>
       */
      FLICK_TO_HALFWIDTHASCII(14),
      /**
       * <pre>
       * Use special table for flick (to alphabet).
       * </pre>
       *
       * <code>FLICK_TO_HALFWIDTHASCII_IOS = 44;</code>
       */
      FLICK_TO_HALFWIDTHASCII_IOS(44),
      /**
       * <pre>
       * Use special table for flick (to number).
       * </pre>
       *
       * <code>FLICK_TO_NUMBER = 43;</code>
       */
      FLICK_TO_NUMBER(43),
      /**
       * <pre>
       * Use special table for both toggle and flick (to hiragana).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HIRAGANA = 16;</code>
       */
      TOGGLE_FLICK_TO_HIRAGANA(16),
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current toggle_flick_hiragana table.
       * TODO(noriyukit): Replace TOGGLE_FLICK_HIRAGANA by this.
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE = 10001;</code>
       */
      TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE(10001),
      /**
       * <pre>
       * Use special table for both toggle and flick (to number).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_NUMBER = 42;</code>
       */
      TOGGLE_FLICK_TO_NUMBER(42),
      /**
       * <pre>
       * Use special table for both toggle and flick (to alphabet).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS = 45;</code>
       */
      TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS(45),
      /**
       * <pre>
       * Use special table for both toggle and flick (to half-width ascii).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HALFWIDTHASCII = 17;</code>
       */
      TOGGLE_FLICK_TO_HALFWIDTHASCII(17),
      /**
       * <pre>
       * Use special table for Qwerty (for Mobile) (to hiragana).
       * </pre>
       *
       * <code>QWERTY_MOBILE_TO_HIRAGANA = 20;</code>
       */
      QWERTY_MOBILE_TO_HIRAGANA(20),
      /**
       * <pre>
       * Use special table for Qwerty (for Mobile) (to half-width ascii).
       * </pre>
       *
       * <code>QWERTY_MOBILE_TO_HALFWIDTHASCII = 22;</code>
       */
      QWERTY_MOBILE_TO_HALFWIDTHASCII(22),
      /**
       * <pre>
       * Use special table for Godan (to hiragana).
       * </pre>
       *
       * <code>GODAN_TO_HIRAGANA = 30;</code>
       */
      GODAN_TO_HIRAGANA(30),
      /**
       * <pre>
       * Use special table for Godan (to half-width ascii).
       * </pre>
       *
       * <code>GODAN_TO_HALFWIDTHASCII = 31;</code>
       */
      GODAN_TO_HALFWIDTHASCII(31),
      /**
       * <pre>
       * Use special table for Notouch (to hiragana).
       * </pre>
       *
       * <code>NOTOUCH_TO_HIRAGANA = 40;</code>
       */
      NOTOUCH_TO_HIRAGANA(40),
      /**
       * <pre>
       * Use special table for Notouch (to half-width ascii).
       * </pre>
       *
       * <code>NOTOUCH_TO_HALFWIDTHASCII = 41;</code>
       */
      NOTOUCH_TO_HALFWIDTHASCII(41),
      /**
       * <pre>
       * Use special table for 50keys keyboard.
       * </pre>
       *
       * <code>FIFTY_KEYS_TO_HIRAGANA = 46;</code>
       */
      FIFTY_KEYS_TO_HIRAGANA(46),
      ;

      /**
       * <pre>
       * Do not use special table.
       * Romanji table is selected based on Config.
       * </pre>
       *
       * <code>DEFAULT_TABLE = 0;</code>
       */
      public static final int DEFAULT_TABLE_VALUE = 0;
      /**
       * <pre>
       * Use special table for 12keys (to hiragana).
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HIRAGANA = 10;</code>
       */
      public static final int TWELVE_KEYS_TO_HIRAGANA_VALUE = 10;
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current 12keys-to-hiragana table.
       * TODO(noriyukit): Replace TWELVE_KEYS_TO_HIRAGANA by this.
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HIRAGANA_INTUITIVE = 10000;</code>
       */
      public static final int TWELVE_KEYS_TO_HIRAGANA_INTUITIVE_VALUE = 10000;
      /**
       * <pre>
       * Use special table for 12keys (to half-width ascii).
       * </pre>
       *
       * <code>TWELVE_KEYS_TO_HALFWIDTHASCII = 11;</code>
       */
      public static final int TWELVE_KEYS_TO_HALFWIDTHASCII_VALUE = 11;
      /**
       * <pre>
       * Use special table for flick (to hiragana).
       * </pre>
       *
       * <code>FLICK_TO_HIRAGANA = 13;</code>
       */
      public static final int FLICK_TO_HIRAGANA_VALUE = 13;
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current flick-to-hiragana table.
       * TODO(noriyukit): Replace FLICK_TO_HIRAGANA by this.
       * </pre>
       *
       * <code>FLICK_TO_HIRAGANA_INTUITIVE = 10002;</code>
       */
      public static final int FLICK_TO_HIRAGANA_INTUITIVE_VALUE = 10002;
      /**
       * <pre>
       * Use special table for flick (to half-width ascii).
       * </pre>
       *
       * <code>FLICK_TO_HALFWIDTHASCII = 14;</code>
       */
      public static final int FLICK_TO_HALFWIDTHASCII_VALUE = 14;
      /**
       * <pre>
       * Use special table for flick (to alphabet).
       * </pre>
       *
       * <code>FLICK_TO_HALFWIDTHASCII_IOS = 44;</code>
       */
      public static final int FLICK_TO_HALFWIDTHASCII_IOS_VALUE = 44;
      /**
       * <pre>
       * Use special table for flick (to number).
       * </pre>
       *
       * <code>FLICK_TO_NUMBER = 43;</code>
       */
      public static final int FLICK_TO_NUMBER_VALUE = 43;
      /**
       * <pre>
       * Use special table for both toggle and flick (to hiragana).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HIRAGANA = 16;</code>
       */
      public static final int TOGGLE_FLICK_TO_HIRAGANA_VALUE = 16;
      /**
       * <pre>
       * This is a temporary romaji table that is to be used instead of the
       * current toggle_flick_hiragana table.
       * TODO(noriyukit): Replace TOGGLE_FLICK_HIRAGANA by this.
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE = 10001;</code>
       */
      public static final int TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE_VALUE = 10001;
      /**
       * <pre>
       * Use special table for both toggle and flick (to number).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_NUMBER = 42;</code>
       */
      public static final int TOGGLE_FLICK_TO_NUMBER_VALUE = 42;
      /**
       * <pre>
       * Use special table for both toggle and flick (to alphabet).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS = 45;</code>
       */
      public static final int TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS_VALUE = 45;
      /**
       * <pre>
       * Use special table for both toggle and flick (to half-width ascii).
       * </pre>
       *
       * <code>TOGGLE_FLICK_TO_HALFWIDTHASCII = 17;</code>
       */
      public static final int TOGGLE_FLICK_TO_HALFWIDTHASCII_VALUE = 17;
      /**
       * <pre>
       * Use special table for Qwerty (for Mobile) (to hiragana).
       * </pre>
       *
       * <code>QWERTY_MOBILE_TO_HIRAGANA = 20;</code>
       */
      public static final int QWERTY_MOBILE_TO_HIRAGANA_VALUE = 20;
      /**
       * <pre>
       * Use special table for Qwerty (for Mobile) (to half-width ascii).
       * </pre>
       *
       * <code>QWERTY_MOBILE_TO_HALFWIDTHASCII = 22;</code>
       */
      public static final int QWERTY_MOBILE_TO_HALFWIDTHASCII_VALUE = 22;
      /**
       * <pre>
       * Use special table for Godan (to hiragana).
       * </pre>
       *
       * <code>GODAN_TO_HIRAGANA = 30;</code>
       */
      public static final int GODAN_TO_HIRAGANA_VALUE = 30;
      /**
       * <pre>
       * Use special table for Godan (to half-width ascii).
       * </pre>
       *
       * <code>GODAN_TO_HALFWIDTHASCII = 31;</code>
       */
      public static final int GODAN_TO_HALFWIDTHASCII_VALUE = 31;
      /**
       * <pre>
       * Use special table for Notouch (to hiragana).
       * </pre>
       *
       * <code>NOTOUCH_TO_HIRAGANA = 40;</code>
       */
      public static final int NOTOUCH_TO_HIRAGANA_VALUE = 40;
      /**
       * <pre>
       * Use special table for Notouch (to half-width ascii).
       * </pre>
       *
       * <code>NOTOUCH_TO_HALFWIDTHASCII = 41;</code>
       */
      public static final int NOTOUCH_TO_HALFWIDTHASCII_VALUE = 41;
      /**
       * <pre>
       * Use special table for 50keys keyboard.
       * </pre>
       *
       * <code>FIFTY_KEYS_TO_HIRAGANA = 46;</code>
       */
      public static final int FIFTY_KEYS_TO_HIRAGANA_VALUE = 46;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SpecialRomanjiTable valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static SpecialRomanjiTable forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT_TABLE;
          case 10: return TWELVE_KEYS_TO_HIRAGANA;
          case 10000: return TWELVE_KEYS_TO_HIRAGANA_INTUITIVE;
          case 11: return TWELVE_KEYS_TO_HALFWIDTHASCII;
          case 13: return FLICK_TO_HIRAGANA;
          case 10002: return FLICK_TO_HIRAGANA_INTUITIVE;
          case 14: return FLICK_TO_HALFWIDTHASCII;
          case 44: return FLICK_TO_HALFWIDTHASCII_IOS;
          case 43: return FLICK_TO_NUMBER;
          case 16: return TOGGLE_FLICK_TO_HIRAGANA;
          case 10001: return TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE;
          case 42: return TOGGLE_FLICK_TO_NUMBER;
          case 45: return TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS;
          case 17: return TOGGLE_FLICK_TO_HALFWIDTHASCII;
          case 20: return QWERTY_MOBILE_TO_HIRAGANA;
          case 22: return QWERTY_MOBILE_TO_HALFWIDTHASCII;
          case 30: return GODAN_TO_HIRAGANA;
          case 31: return GODAN_TO_HALFWIDTHASCII;
          case 40: return NOTOUCH_TO_HIRAGANA;
          case 41: return NOTOUCH_TO_HALFWIDTHASCII;
          case 46: return FIFTY_KEYS_TO_HIRAGANA;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SpecialRomanjiTable>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SpecialRomanjiTable> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SpecialRomanjiTable>() {
              public SpecialRomanjiTable findValueByNumber(int number) {
                return SpecialRomanjiTable.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDescriptor().getEnumTypes().get(0);
      }

      private static final SpecialRomanjiTable[] VALUES = values();

      public static SpecialRomanjiTable valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SpecialRomanjiTable(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.SpecialRomanjiTable)
    }

    /**
     * Protobuf enum {@code mozc.commands.Request.SpaceOnAlphanumeric}
     */
    public enum SpaceOnAlphanumeric
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * The first input is treated as a space, double input is treated
       * as a conversion.  If a character is input after the first
       * input, the composition will remain.  For example, "ab&lt;space&gt;dc"
       * becomes "ab dc" as a single composition.
       * </pre>
       *
       * <code>SPACE_OR_CONVERT_KEEPING_COMPOSITION = 0;</code>
       */
      SPACE_OR_CONVERT_KEEPING_COMPOSITION(0),
      /**
       * <pre>
       * The first input is treated as a space, double input is treated
       * as a conversion.  If a character is input after the first
       * input, the previous composition will be committed.  For
       * example, "ab&lt;space&gt;dc" results "ab " as a committed string and
       * "dc" as a composition.
       * </pre>
       *
       * <code>SPACE_OR_CONVERT_COMMITTING_COMPOSITION = 1;</code>
       */
      SPACE_OR_CONVERT_COMMITTING_COMPOSITION(1),
      /**
       * <pre>
       * Commit the composition and a space.
       * </pre>
       *
       * <code>COMMIT = 2;</code>
       */
      COMMIT(2),
      ;

      /**
       * <pre>
       * The first input is treated as a space, double input is treated
       * as a conversion.  If a character is input after the first
       * input, the composition will remain.  For example, "ab&lt;space&gt;dc"
       * becomes "ab dc" as a single composition.
       * </pre>
       *
       * <code>SPACE_OR_CONVERT_KEEPING_COMPOSITION = 0;</code>
       */
      public static final int SPACE_OR_CONVERT_KEEPING_COMPOSITION_VALUE = 0;
      /**
       * <pre>
       * The first input is treated as a space, double input is treated
       * as a conversion.  If a character is input after the first
       * input, the previous composition will be committed.  For
       * example, "ab&lt;space&gt;dc" results "ab " as a committed string and
       * "dc" as a composition.
       * </pre>
       *
       * <code>SPACE_OR_CONVERT_COMMITTING_COMPOSITION = 1;</code>
       */
      public static final int SPACE_OR_CONVERT_COMMITTING_COMPOSITION_VALUE = 1;
      /**
       * <pre>
       * Commit the composition and a space.
       * </pre>
       *
       * <code>COMMIT = 2;</code>
       */
      public static final int COMMIT_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SpaceOnAlphanumeric valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static SpaceOnAlphanumeric forNumber(int value) {
        switch (value) {
          case 0: return SPACE_OR_CONVERT_KEEPING_COMPOSITION;
          case 1: return SPACE_OR_CONVERT_COMMITTING_COMPOSITION;
          case 2: return COMMIT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SpaceOnAlphanumeric>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SpaceOnAlphanumeric> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SpaceOnAlphanumeric>() {
              public SpaceOnAlphanumeric findValueByNumber(int number) {
                return SpaceOnAlphanumeric.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDescriptor().getEnumTypes().get(1);
      }

      private static final SpaceOnAlphanumeric[] VALUES = values();

      public static SpaceOnAlphanumeric valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SpaceOnAlphanumeric(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.SpaceOnAlphanumeric)
    }

    /**
     * <pre>
     * For emoji rewriter, it is necessary to control when the rewriter runs
     * based on the clients. The following bit set is sync'ed to
     * RewriterInterface::CapabilityType (see rewriter_interface.h, too),
     * so that clients can fill the value.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.RewriterCapability}
     */
    public enum RewriterCapability
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NOT_AVAILABLE = 0;</code>
       */
      NOT_AVAILABLE(0),
      /**
       * <code>CONVERSION = 1;</code>
       */
      CONVERSION(1),
      /**
       * <code>PREDICTION = 2;</code>
       */
      PREDICTION(2),
      /**
       * <code>SUGGESTION = 4;</code>
       */
      SUGGESTION(4),
      /**
       * <pre>
       * CONVERSION | PREDICTION | SUGGESTION.
       * </pre>
       *
       * <code>ALL = 7;</code>
       */
      ALL(7),
      ;

      /**
       * <code>NOT_AVAILABLE = 0;</code>
       */
      public static final int NOT_AVAILABLE_VALUE = 0;
      /**
       * <code>CONVERSION = 1;</code>
       */
      public static final int CONVERSION_VALUE = 1;
      /**
       * <code>PREDICTION = 2;</code>
       */
      public static final int PREDICTION_VALUE = 2;
      /**
       * <code>SUGGESTION = 4;</code>
       */
      public static final int SUGGESTION_VALUE = 4;
      /**
       * <pre>
       * CONVERSION | PREDICTION | SUGGESTION.
       * </pre>
       *
       * <code>ALL = 7;</code>
       */
      public static final int ALL_VALUE = 7;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static RewriterCapability valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static RewriterCapability forNumber(int value) {
        switch (value) {
          case 0: return NOT_AVAILABLE;
          case 1: return CONVERSION;
          case 2: return PREDICTION;
          case 4: return SUGGESTION;
          case 7: return ALL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<RewriterCapability>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          RewriterCapability> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<RewriterCapability>() {
              public RewriterCapability findValueByNumber(int number) {
                return RewriterCapability.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDescriptor().getEnumTypes().get(2);
      }

      private static final RewriterCapability[] VALUES = values();

      public static RewriterCapability valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private RewriterCapability(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.RewriterCapability)
    }

    /**
     * <pre>
     * Controls the behavior when a user types the left/right key at the edge
     * of the preedit string (in more precise, the left key at the beginning
     * of the preedit string, or the right key at the end).
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.CrossingEdgeBehavior}
     */
    public enum CrossingEdgeBehavior
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * This is the default behavior. The cursor movement at the edge
       * will make nothing, i.e., keeping the current cursor position (at the
       * edge), consume the key event.
       * </pre>
       *
       * <code>DO_NOTHING = 0;</code>
       */
      DO_NOTHING(0),
      /**
       * <pre>
       * This is the behavior, especially designed for alphabet keyboards on
       * mobile devices. Assuming the following text:
       *   XXXXabcde|YYYYY
       * where XXXX is preceding text, abcde is composing text, YYYYY is
       * following text and '|' is the caret, when a user sends "RIGHT"
       * cursor key, we'd like to commit the abcde and move the caret to right.
       * So the user will get:
       *   XXXXabcdeY|YYYY
       * Here, what we need is committing the "abcde" with the appropriate
       * caret position. (Note that we need to handle the left cursor key, too).
       * Also, we should *NOT* consume the key, so that the key event will be
       * handled appropriately by the target application.
       * </pre>
       *
       * <code>COMMIT_WITHOUT_CONSUMING = 1;</code>
       */
      COMMIT_WITHOUT_CONSUMING(1),
      ;

      /**
       * <pre>
       * This is the default behavior. The cursor movement at the edge
       * will make nothing, i.e., keeping the current cursor position (at the
       * edge), consume the key event.
       * </pre>
       *
       * <code>DO_NOTHING = 0;</code>
       */
      public static final int DO_NOTHING_VALUE = 0;
      /**
       * <pre>
       * This is the behavior, especially designed for alphabet keyboards on
       * mobile devices. Assuming the following text:
       *   XXXXabcde|YYYYY
       * where XXXX is preceding text, abcde is composing text, YYYYY is
       * following text and '|' is the caret, when a user sends "RIGHT"
       * cursor key, we'd like to commit the abcde and move the caret to right.
       * So the user will get:
       *   XXXXabcdeY|YYYY
       * Here, what we need is committing the "abcde" with the appropriate
       * caret position. (Note that we need to handle the left cursor key, too).
       * Also, we should *NOT* consume the key, so that the key event will be
       * handled appropriately by the target application.
       * </pre>
       *
       * <code>COMMIT_WITHOUT_CONSUMING = 1;</code>
       */
      public static final int COMMIT_WITHOUT_CONSUMING_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CrossingEdgeBehavior valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static CrossingEdgeBehavior forNumber(int value) {
        switch (value) {
          case 0: return DO_NOTHING;
          case 1: return COMMIT_WITHOUT_CONSUMING;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CrossingEdgeBehavior>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CrossingEdgeBehavior> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CrossingEdgeBehavior>() {
              public CrossingEdgeBehavior findValueByNumber(int number) {
                return CrossingEdgeBehavior.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDescriptor().getEnumTypes().get(3);
      }

      private static final CrossingEdgeBehavior[] VALUES = values();

      public static CrossingEdgeBehavior valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private CrossingEdgeBehavior(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.CrossingEdgeBehavior)
    }

    /**
     * <pre>
     * Controls the behavior of language aware input.  Language aware input
     * guesses the actual language regardless the input mode.  For example,
     * if user type "てｓｔ" it will be treated as "test".
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.LanguageAwareInputBehavior}
     */
    public enum LanguageAwareInputBehavior
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Performs the default behavior considering the platform and channel.
       * </pre>
       *
       * <code>DEFAULT_LANGUAGE_AWARE_BEHAVIOR = 0;</code>
       */
      DEFAULT_LANGUAGE_AWARE_BEHAVIOR(0),
      /**
       * <pre>
       * Does not perform this functionarity.
       * </pre>
       *
       * <code>NO_LANGUAGE_AWARE_INPUT = 1;</code>
       */
      NO_LANGUAGE_AWARE_INPUT(1),
      /**
       * <pre>
       * Adds a language aware candidate to the suggestion.
       * </pre>
       *
       * <code>LANGUAGE_AWARE_SUGGESTION = 2;</code>
       */
      LANGUAGE_AWARE_SUGGESTION(2),
      ;

      /**
       * <pre>
       * Performs the default behavior considering the platform and channel.
       * </pre>
       *
       * <code>DEFAULT_LANGUAGE_AWARE_BEHAVIOR = 0;</code>
       */
      public static final int DEFAULT_LANGUAGE_AWARE_BEHAVIOR_VALUE = 0;
      /**
       * <pre>
       * Does not perform this functionarity.
       * </pre>
       *
       * <code>NO_LANGUAGE_AWARE_INPUT = 1;</code>
       */
      public static final int NO_LANGUAGE_AWARE_INPUT_VALUE = 1;
      /**
       * <pre>
       * Adds a language aware candidate to the suggestion.
       * </pre>
       *
       * <code>LANGUAGE_AWARE_SUGGESTION = 2;</code>
       */
      public static final int LANGUAGE_AWARE_SUGGESTION_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static LanguageAwareInputBehavior valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static LanguageAwareInputBehavior forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT_LANGUAGE_AWARE_BEHAVIOR;
          case 1: return NO_LANGUAGE_AWARE_INPUT;
          case 2: return LANGUAGE_AWARE_SUGGESTION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<LanguageAwareInputBehavior>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          LanguageAwareInputBehavior> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<LanguageAwareInputBehavior>() {
              public LanguageAwareInputBehavior findValueByNumber(int number) {
                return LanguageAwareInputBehavior.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDescriptor().getEnumTypes().get(4);
      }

      private static final LanguageAwareInputBehavior[] VALUES = values();

      public static LanguageAwareInputBehavior valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private LanguageAwareInputBehavior(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.LanguageAwareInputBehavior)
    }

    /**
     * <pre>
     * Additional Character Group represents certain group of characters, that can
     * be additionaly requested from the client side, based on font-availability
     * information.
     * This enum is not intended to be used for user preference. 'Additional'
     * cases can change as time advances. For example, when KANA_SUPPLEMENT_6_0
     * becomes enough available among environments, this option becomes default
     * and the case will be removed.
     * WARNING: Although cases are mutually exclusive now, they are not
     * necessarily mutually exclusive. However, the current implementation in
     * NormalizationRewriter assumes they are mutually exclusive.
     * LINT.IfChange
     * Next ID: 14
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Request.AdditionalRenderableCharacterGroup}
     */
    public enum AdditionalRenderableCharacterGroup
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Do not use this case. This case is reserved for future usage.
       * Because 0th element in enum is used as default value, in order to prevend
       * having unexpected additional group, this case represents empty set of
       * characters.
       * </pre>
       *
       * <code>EMPTY = 0;</code>
       */
      EMPTY(0),
      /**
       * <pre>
       * Additional Hiragana, Katakana, and Hentaigana.
       * It only contains KATAKANA / HIRAGANA LETTER ARCHAIC YE (U+1B000 and
       * U+1B001) since Unicode 6.0. Some fonts including M+ fonts only support
       * this letter.
       * </pre>
       *
       * <code>KANA_SUPPLEMENT_6_0 = 2;</code>
       */
      KANA_SUPPLEMENT_6_0(2),
      /**
       * <pre>
       * It contains 285 Hentaigana characters supported in KANA_SUPPLEMENT and
       * KANA_EXTENDED_A (U+1B002 ~ U+1B11E) since Unicode 10.0.
       * </pre>
       *
       * <code>KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0 = 3;</code>
       */
      KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0(3),
      /**
       * <pre>
       * It contains four archaic hiraganas/katakanas (U+1B11F ~ U+1B122) since
       * Unicode 14.0.
       * </pre>
       *
       * <code>KANA_EXTENDED_A_14_0 = 4;</code>
       */
      KANA_EXTENDED_A_14_0(4),
      /**
       * <pre>
       * Additional Emoji
       * Emoji in enum can be removed and become default several years passed
       * after the introduction. Emoji 12.1, released October 2019
       * </pre>
       *
       * <code>EMOJI_12_1 = 5;</code>
       */
      EMOJI_12_1(5),
      /**
       * <pre>
       * Emoji 13.0, released March 2020
       * </pre>
       *
       * <code>EMOJI_13_0 = 6;</code>
       */
      EMOJI_13_0(6),
      /**
       * <pre>
       * Emoji 13.1, released September 2020
       * </pre>
       *
       * <code>EMOJI_13_1 = 7;</code>
       */
      EMOJI_13_1(7),
      /**
       * <pre>
       * Emoji 14.0, released September 2021
       * </pre>
       *
       * <code>EMOJI_14_0 = 8;</code>
       */
      EMOJI_14_0(8),
      /**
       * <pre>
       * Emoji 15.0, released September 2022
       * </pre>
       *
       * <code>EMOJI_15_0 = 9;</code>
       */
      EMOJI_15_0(9),
      /**
       * <pre>
       * Emoji 15.1, released September 2023
       * </pre>
       *
       * <code>EMOJI_15_1 = 12;</code>
       */
      EMOJI_15_1(12),
      /**
       * <pre>
       * Emoji 16.0, released September 2024
       * </pre>
       *
       * <code>EMOJI_16_0 = 13;</code>
       */
      EMOJI_16_0(13),
      /**
       * <pre>
       * Additional Hieroglyphs (U+13000 ~ U+1342E)
       * Unicode 5.2, released October 2009
       * </pre>
       *
       * <code>EGYPTIAN_HIEROGLYPH_5_2 = 10;</code>
       */
      EGYPTIAN_HIEROGLYPH_5_2(10),
      /**
       * <pre>
       * IVS characters in Adobe-Japan1 (U+E0100 ~ U+E010E)
       * </pre>
       *
       * <code>IVS_CHARACTER = 11;</code>
       */
      IVS_CHARACTER(11),
      ;

      /**
       * <pre>
       * Do not use this case. This case is reserved for future usage.
       * Because 0th element in enum is used as default value, in order to prevend
       * having unexpected additional group, this case represents empty set of
       * characters.
       * </pre>
       *
       * <code>EMPTY = 0;</code>
       */
      public static final int EMPTY_VALUE = 0;
      /**
       * <pre>
       * Additional Hiragana, Katakana, and Hentaigana.
       * It only contains KATAKANA / HIRAGANA LETTER ARCHAIC YE (U+1B000 and
       * U+1B001) since Unicode 6.0. Some fonts including M+ fonts only support
       * this letter.
       * </pre>
       *
       * <code>KANA_SUPPLEMENT_6_0 = 2;</code>
       */
      public static final int KANA_SUPPLEMENT_6_0_VALUE = 2;
      /**
       * <pre>
       * It contains 285 Hentaigana characters supported in KANA_SUPPLEMENT and
       * KANA_EXTENDED_A (U+1B002 ~ U+1B11E) since Unicode 10.0.
       * </pre>
       *
       * <code>KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0 = 3;</code>
       */
      public static final int KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0_VALUE = 3;
      /**
       * <pre>
       * It contains four archaic hiraganas/katakanas (U+1B11F ~ U+1B122) since
       * Unicode 14.0.
       * </pre>
       *
       * <code>KANA_EXTENDED_A_14_0 = 4;</code>
       */
      public static final int KANA_EXTENDED_A_14_0_VALUE = 4;
      /**
       * <pre>
       * Additional Emoji
       * Emoji in enum can be removed and become default several years passed
       * after the introduction. Emoji 12.1, released October 2019
       * </pre>
       *
       * <code>EMOJI_12_1 = 5;</code>
       */
      public static final int EMOJI_12_1_VALUE = 5;
      /**
       * <pre>
       * Emoji 13.0, released March 2020
       * </pre>
       *
       * <code>EMOJI_13_0 = 6;</code>
       */
      public static final int EMOJI_13_0_VALUE = 6;
      /**
       * <pre>
       * Emoji 13.1, released September 2020
       * </pre>
       *
       * <code>EMOJI_13_1 = 7;</code>
       */
      public static final int EMOJI_13_1_VALUE = 7;
      /**
       * <pre>
       * Emoji 14.0, released September 2021
       * </pre>
       *
       * <code>EMOJI_14_0 = 8;</code>
       */
      public static final int EMOJI_14_0_VALUE = 8;
      /**
       * <pre>
       * Emoji 15.0, released September 2022
       * </pre>
       *
       * <code>EMOJI_15_0 = 9;</code>
       */
      public static final int EMOJI_15_0_VALUE = 9;
      /**
       * <pre>
       * Emoji 15.1, released September 2023
       * </pre>
       *
       * <code>EMOJI_15_1 = 12;</code>
       */
      public static final int EMOJI_15_1_VALUE = 12;
      /**
       * <pre>
       * Emoji 16.0, released September 2024
       * </pre>
       *
       * <code>EMOJI_16_0 = 13;</code>
       */
      public static final int EMOJI_16_0_VALUE = 13;
      /**
       * <pre>
       * Additional Hieroglyphs (U+13000 ~ U+1342E)
       * Unicode 5.2, released October 2009
       * </pre>
       *
       * <code>EGYPTIAN_HIEROGLYPH_5_2 = 10;</code>
       */
      public static final int EGYPTIAN_HIEROGLYPH_5_2_VALUE = 10;
      /**
       * <pre>
       * IVS characters in Adobe-Japan1 (U+E0100 ~ U+E010E)
       * </pre>
       *
       * <code>IVS_CHARACTER = 11;</code>
       */
      public static final int IVS_CHARACTER_VALUE = 11;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static AdditionalRenderableCharacterGroup valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static AdditionalRenderableCharacterGroup forNumber(int value) {
        switch (value) {
          case 0: return EMPTY;
          case 2: return KANA_SUPPLEMENT_6_0;
          case 3: return KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0;
          case 4: return KANA_EXTENDED_A_14_0;
          case 5: return EMOJI_12_1;
          case 6: return EMOJI_13_0;
          case 7: return EMOJI_13_1;
          case 8: return EMOJI_14_0;
          case 9: return EMOJI_15_0;
          case 12: return EMOJI_15_1;
          case 13: return EMOJI_16_0;
          case 10: return EGYPTIAN_HIEROGLYPH_5_2;
          case 11: return IVS_CHARACTER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<AdditionalRenderableCharacterGroup>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          AdditionalRenderableCharacterGroup> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AdditionalRenderableCharacterGroup>() {
              public AdditionalRenderableCharacterGroup findValueByNumber(int number) {
                return AdditionalRenderableCharacterGroup.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDescriptor().getEnumTypes().get(5);
      }

      private static final AdditionalRenderableCharacterGroup[] VALUES = values();

      public static AdditionalRenderableCharacterGroup valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private AdditionalRenderableCharacterGroup(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Request.AdditionalRenderableCharacterGroup)
    }

    private int bitField0_;
    public static final int ZERO_QUERY_SUGGESTION_FIELD_NUMBER = 1;
    private boolean zeroQuerySuggestion_ = false;
    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     * @return Whether the zeroQuerySuggestion field is set.
     */
    @java.lang.Override
    public boolean hasZeroQuerySuggestion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Enable zero query suggestion.
     * </pre>
     *
     * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
     * @return The zeroQuerySuggestion.
     */
    @java.lang.Override
    public boolean getZeroQuerySuggestion() {
      return zeroQuerySuggestion_;
    }

    public static final int MIXED_CONVERSION_FIELD_NUMBER = 2;
    private boolean mixedConversion_ = false;
    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     * @return Whether the mixedConversion field is set.
     */
    @java.lang.Override
    public boolean hasMixedConversion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Conversion's candidate includes suggestion, prediction and conversion.
     * </pre>
     *
     * <code>optional bool mixed_conversion = 2 [default = false];</code>
     * @return The mixedConversion.
     */
    @java.lang.Override
    public boolean getMixedConversion() {
      return mixedConversion_;
    }

    public static final int SPECIAL_ROMANJI_TABLE_FIELD_NUMBER = 4;
    private int specialRomanjiTable_ = 0;
    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     * @return Whether the specialRomanjiTable field is set.
     */
    @java.lang.Override public boolean hasSpecialRomanjiTable() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Use special Romanji table.
     * </pre>
     *
     * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
     * @return The specialRomanjiTable.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable getSpecialRomanjiTable() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable.forNumber(specialRomanjiTable_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable.DEFAULT_TABLE : result;
    }

    public static final int SPACE_ON_ALPHANUMERIC_FIELD_NUMBER = 6;
    private int spaceOnAlphanumeric_ = 0;
    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     * @return Whether the spaceOnAlphanumeric field is set.
     */
    @java.lang.Override public boolean hasSpaceOnAlphanumeric() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
     * @return The spaceOnAlphanumeric.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric getSpaceOnAlphanumeric() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric.forNumber(spaceOnAlphanumeric_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric.SPACE_OR_CONVERT_KEEPING_COMPOSITION : result;
    }

    public static final int KEYBOARD_NAME_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object keyboardName_ = "";
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return Whether the keyboardName field is set.
     */
    @java.lang.Override
    public boolean hasKeyboardName() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return The keyboardName.
     */
    @java.lang.Override
    public java.lang.String getKeyboardName() {
      java.lang.Object ref = keyboardName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          keyboardName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Keyboard name for touch devices.
     * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
     * It is used to analyze touch event usage stats.
     * </pre>
     *
     * <code>optional string keyboard_name = 7;</code>
     * @return The bytes for keyboardName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyboardNameBytes() {
      java.lang.Object ref = keyboardName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        keyboardName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UPDATE_INPUT_MODE_FROM_SURROUNDING_TEXT_FIELD_NUMBER = 8;
    private boolean updateInputModeFromSurroundingText_ = true;
    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     * @return Whether the updateInputModeFromSurroundingText field is set.
     */
    @java.lang.Override
    public boolean hasUpdateInputModeFromSurroundingText() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Enables Composer's input mode auto updating by using surrounding text.
     * For example, when a composition string is "ad", a carret is at the end,
     * and a user selects HIRAGANA mode, if the user moves the carret to between
     * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
     * See details in the Composer::UpdateInputMode.
     * </pre>
     *
     * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
     * @return The updateInputModeFromSurroundingText.
     */
    @java.lang.Override
    public boolean getUpdateInputModeFromSurroundingText() {
      return updateInputModeFromSurroundingText_;
    }

    public static final int KANA_MODIFIER_INSENSITIVE_CONVERSION_FIELD_NUMBER = 9;
    private boolean kanaModifierInsensitiveConversion_ = false;
    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     * @return Whether the kanaModifierInsensitiveConversion field is set.
     */
    @java.lang.Override
    public boolean hasKanaModifierInsensitiveConversion() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Enables Kana-modifier-insensitive conversion as follows:
     * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
     *    e.g.) "ば" and "ぱ" will be hit by key "は".
     * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
     * 3) Palatalized kana will be hit by non-modified kana.
     *    e.g.) "ゃ" will be hit by key "や".
     * Here is an example of the search: "学校" ("がっこう") will be hit
     * by "かつこう".
     * </pre>
     *
     * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
     * @return The kanaModifierInsensitiveConversion.
     */
    @java.lang.Override
    public boolean getKanaModifierInsensitiveConversion() {
      return kanaModifierInsensitiveConversion_;
    }

    public static final int AUTO_PARTIAL_SUGGESTION_FIELD_NUMBER = 10;
    private boolean autoPartialSuggestion_ = false;
    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     * @return Whether the autoPartialSuggestion field is set.
     */
    @java.lang.Override
    public boolean hasAutoPartialSuggestion() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Enables Auto partial suggestion (prefix candidates).
     * For Auto partial suggestion, we can see candidates that match
     * the prefix of the input reading.
     * If we commit that candidate, we will show suggestions for remaining part
     * of key.
     * Note: This feature can be enabled only for mobile due to UX design.
     * </pre>
     *
     * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
     * @return The autoPartialSuggestion.
     */
    @java.lang.Override
    public boolean getAutoPartialSuggestion() {
      return autoPartialSuggestion_;
    }

    public static final int EMOJI_REWRITER_CAPABILITY_FIELD_NUMBER = 12;
    private int emojiRewriterCapability_ = 1;
    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     * @return Whether the emojiRewriterCapability field is set.
     */
    @java.lang.Override
    public boolean hasEmojiRewriterCapability() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * By default, Emoji rewriter works on conversion mode only.
     * </pre>
     *
     * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
     * @return The emojiRewriterCapability.
     */
    @java.lang.Override
    public int getEmojiRewriterCapability() {
      return emojiRewriterCapability_;
    }

    public static final int CROSSING_EDGE_BEHAVIOR_FIELD_NUMBER = 13;
    private int crossingEdgeBehavior_ = 0;
    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     * @return Whether the crossingEdgeBehavior field is set.
     */
    @java.lang.Override public boolean hasCrossingEdgeBehavior() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
     * @return The crossingEdgeBehavior.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior getCrossingEdgeBehavior() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior.forNumber(crossingEdgeBehavior_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior.DO_NOTHING : result;
    }

    public static final int LANGUAGE_AWARE_INPUT_FIELD_NUMBER = 14;
    private int languageAwareInput_ = 0;
    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     * @return Whether the languageAwareInput field is set.
     */
    @java.lang.Override public boolean hasLanguageAwareInput() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
     * @return The languageAwareInput.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior getLanguageAwareInput() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior.forNumber(languageAwareInput_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior.DEFAULT_LANGUAGE_AWARE_BEHAVIOR : result;
    }

    public static final int CANDIDATE_PAGE_SIZE_FIELD_NUMBER = 15;
    private int candidatePageSize_ = 9;
    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     * @return Whether the candidatePageSize field is set.
     */
    @java.lang.Override
    public boolean hasCandidatePageSize() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Page size of the candidate list.
     * </pre>
     *
     * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
     * @return The candidatePageSize.
     */
    @java.lang.Override
    public int getCandidatePageSize() {
      return candidatePageSize_;
    }

    public static final int CANDIDATES_SIZE_LIMIT_FIELD_NUMBER = 16;
    private int candidatesSizeLimit_ = 0;
    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     * @return Whether the candidatesSizeLimit field is set.
     */
    @java.lang.Override
    public boolean hasCandidatesSizeLimit() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * The maximum limit of the candidates size.
     * If not set, converter doesn't limit the size.
     * NOTE: Each segment has at least one candidate and meta candidates even if
     *       this value is set to 0.
     * </pre>
     *
     * <code>optional int32 candidates_size_limit = 16;</code>
     * @return The candidatesSizeLimit.
     */
    @java.lang.Override
    public int getCandidatesSizeLimit() {
      return candidatesSizeLimit_;
    }

    public static final int DECODER_EXPERIMENT_PARAMS_FIELD_NUMBER = 17;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams decoderExperimentParams_;
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     * @return Whether the decoderExperimentParams field is set.
     */
    @java.lang.Override
    public boolean hasDecoderExperimentParams() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     * @return The decoderExperimentParams.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDecoderExperimentParams() {
      return decoderExperimentParams_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDefaultInstance() : decoderExperimentParams_;
    }
    /**
     * <pre>
     * Experimentally changes the decoder's behavior.
     * This flag is usually populated through the phenotype flags.
     * </pre>
     *
     * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParamsOrBuilder getDecoderExperimentParamsOrBuilder() {
      return decoderExperimentParams_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDefaultInstance() : decoderExperimentParams_;
    }

    public static final int FILL_INCOGNITO_CANDIDATE_WORDS_FIELD_NUMBER = 18;
    private boolean fillIncognitoCandidateWords_ = false;
    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     * @return Whether the fillIncognitoCandidateWords field is set.
     */
    @java.lang.Override
    public boolean hasFillIncognitoCandidateWords() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Fills incognito_candidate_words filed of output.
     * </pre>
     *
     * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
     * @return The fillIncognitoCandidateWords.
     */
    @java.lang.Override
    public boolean getFillIncognitoCandidateWords() {
      return fillIncognitoCandidateWords_;
    }

    public static final int ENABLE_A11Y_DESCRIPTION_FIELD_NUMBER = 20;
    private boolean enableA11YDescription_ = false;
    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     * @return Whether the enableA11yDescription field is set.
     */
    @java.lang.Override
    public boolean hasEnableA11YDescription() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Enables a11y support for candidates.
     * If this field is set to true, a11y description is set to each candidate.
     * </pre>
     *
     * <code>optional bool enable_a11y_description = 20 [default = false];</code>
     * @return The enableA11yDescription.
     */
    @java.lang.Override
    public boolean getEnableA11YDescription() {
      return enableA11YDescription_;
    }

    public static final int ADDITIONAL_RENDERABLE_CHARACTER_GROUPS_FIELD_NUMBER = 21;
    @SuppressWarnings("serial")
    private java.util.List<java.lang.Integer> additionalRenderableCharacterGroups_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> additionalRenderableCharacterGroups_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup>() {
              public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup convert(java.lang.Integer from) {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup.forNumber(from);
                return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup.EMPTY : result;
              }
            };
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @return A list containing the additionalRenderableCharacterGroups.
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> getAdditionalRenderableCharacterGroupsList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup>(additionalRenderableCharacterGroups_, additionalRenderableCharacterGroups_converter_);
    }
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @return The count of additionalRenderableCharacterGroups.
     */
    @java.lang.Override
    public int getAdditionalRenderableCharacterGroupsCount() {
      return additionalRenderableCharacterGroups_.size();
    }
    /**
     * <pre>
     * Characters in the union of this list of groups can be contained in
     * candidates.
     * This feature is distinct from user preference. Do not make these option
     * user selectable.
     * </pre>
     *
     * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The additionalRenderableCharacterGroups at the given index.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup getAdditionalRenderableCharacterGroups(int index) {
      return additionalRenderableCharacterGroups_converter_.convert(additionalRenderableCharacterGroups_.get(index));
    }
    private int additionalRenderableCharacterGroupsMemoizedSerializedSize;

    public static final int IS_HANDWRITING_FIELD_NUMBER = 22;
    private boolean isHandwriting_ = false;
    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     * @return Whether the isHandwriting field is set.
     */
    @java.lang.Override
    public boolean hasIsHandwriting() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Whether the request is from handwriting. Candidates can be optimized
     * differently for handwriting.
     * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
     * handwriting.
     * </pre>
     *
     * <code>optional bool is_handwriting = 22 [default = false];</code>
     * @return The isHandwriting.
     */
    @java.lang.Override
    public boolean getIsHandwriting() {
      return isHandwriting_;
    }

    public static final int IS_INCOGNITO_MODE_FIELD_NUMBER = 23;
    private boolean isIncognitoMode_ = false;
    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     * @return Whether the isIncognitoMode field is set.
     */
    @java.lang.Override
    public boolean hasIsIncognitoMode() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * Whether the conversion is performed in incognito mode.
     * In incognito mode, the conversion is performed without using
     * user history and user dictionary.
     * When any of this value and Config::incognito_mode are true,
     * incognito mode is enabled.
     * Clients needs to check ConversionRequest::incognito_mode() instead of
     * this value directly, as the incognito mode can be set in other ways.
     * </pre>
     *
     * <code>optional bool is_incognito_mode = 23 [default = false];</code>
     * @return The isIncognitoMode.
     */
    @java.lang.Override
    public boolean getIsIncognitoMode() {
      return isIncognitoMode_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(1, zeroQuerySuggestion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(2, mixedConversion_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeEnum(4, specialRomanjiTable_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeEnum(6, spaceOnAlphanumeric_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, keyboardName_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(8, updateInputModeFromSurroundingText_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(9, kanaModifierInsensitiveConversion_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeBool(10, autoPartialSuggestion_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeInt32(12, emojiRewriterCapability_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeEnum(13, crossingEdgeBehavior_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeEnum(14, languageAwareInput_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeInt32(15, candidatePageSize_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeInt32(16, candidatesSizeLimit_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeMessage(17, getDecoderExperimentParams());
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeBool(18, fillIncognitoCandidateWords_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeBool(20, enableA11YDescription_);
      }
      if (getAdditionalRenderableCharacterGroupsList().size() > 0) {
        output.writeUInt32NoTag(170);
        output.writeUInt32NoTag(additionalRenderableCharacterGroupsMemoizedSerializedSize);
      }
      for (int i = 0; i < additionalRenderableCharacterGroups_.size(); i++) {
        output.writeEnumNoTag(additionalRenderableCharacterGroups_.get(i));
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeBool(22, isHandwriting_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        output.writeBool(23, isIncognitoMode_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, zeroQuerySuggestion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, mixedConversion_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, specialRomanjiTable_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, spaceOnAlphanumeric_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, keyboardName_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(8, updateInputModeFromSurroundingText_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, kanaModifierInsensitiveConversion_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, autoPartialSuggestion_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(12, emojiRewriterCapability_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(13, crossingEdgeBehavior_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(14, languageAwareInput_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(15, candidatePageSize_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(16, candidatesSizeLimit_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(17, getDecoderExperimentParams());
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(18, fillIncognitoCandidateWords_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(20, enableA11YDescription_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < additionalRenderableCharacterGroups_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(additionalRenderableCharacterGroups_.get(i));
        }
        size += dataSize;
        if (!getAdditionalRenderableCharacterGroupsList().isEmpty()) {  size += 2;
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(dataSize);
        }additionalRenderableCharacterGroupsMemoizedSerializedSize = dataSize;
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(22, isHandwriting_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(23, isIncognitoMode_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request) obj;

      if (hasZeroQuerySuggestion() != other.hasZeroQuerySuggestion()) return false;
      if (hasZeroQuerySuggestion()) {
        if (getZeroQuerySuggestion()
            != other.getZeroQuerySuggestion()) return false;
      }
      if (hasMixedConversion() != other.hasMixedConversion()) return false;
      if (hasMixedConversion()) {
        if (getMixedConversion()
            != other.getMixedConversion()) return false;
      }
      if (hasSpecialRomanjiTable() != other.hasSpecialRomanjiTable()) return false;
      if (hasSpecialRomanjiTable()) {
        if (specialRomanjiTable_ != other.specialRomanjiTable_) return false;
      }
      if (hasSpaceOnAlphanumeric() != other.hasSpaceOnAlphanumeric()) return false;
      if (hasSpaceOnAlphanumeric()) {
        if (spaceOnAlphanumeric_ != other.spaceOnAlphanumeric_) return false;
      }
      if (hasKeyboardName() != other.hasKeyboardName()) return false;
      if (hasKeyboardName()) {
        if (!getKeyboardName()
            .equals(other.getKeyboardName())) return false;
      }
      if (hasUpdateInputModeFromSurroundingText() != other.hasUpdateInputModeFromSurroundingText()) return false;
      if (hasUpdateInputModeFromSurroundingText()) {
        if (getUpdateInputModeFromSurroundingText()
            != other.getUpdateInputModeFromSurroundingText()) return false;
      }
      if (hasKanaModifierInsensitiveConversion() != other.hasKanaModifierInsensitiveConversion()) return false;
      if (hasKanaModifierInsensitiveConversion()) {
        if (getKanaModifierInsensitiveConversion()
            != other.getKanaModifierInsensitiveConversion()) return false;
      }
      if (hasAutoPartialSuggestion() != other.hasAutoPartialSuggestion()) return false;
      if (hasAutoPartialSuggestion()) {
        if (getAutoPartialSuggestion()
            != other.getAutoPartialSuggestion()) return false;
      }
      if (hasEmojiRewriterCapability() != other.hasEmojiRewriterCapability()) return false;
      if (hasEmojiRewriterCapability()) {
        if (getEmojiRewriterCapability()
            != other.getEmojiRewriterCapability()) return false;
      }
      if (hasCrossingEdgeBehavior() != other.hasCrossingEdgeBehavior()) return false;
      if (hasCrossingEdgeBehavior()) {
        if (crossingEdgeBehavior_ != other.crossingEdgeBehavior_) return false;
      }
      if (hasLanguageAwareInput() != other.hasLanguageAwareInput()) return false;
      if (hasLanguageAwareInput()) {
        if (languageAwareInput_ != other.languageAwareInput_) return false;
      }
      if (hasCandidatePageSize() != other.hasCandidatePageSize()) return false;
      if (hasCandidatePageSize()) {
        if (getCandidatePageSize()
            != other.getCandidatePageSize()) return false;
      }
      if (hasCandidatesSizeLimit() != other.hasCandidatesSizeLimit()) return false;
      if (hasCandidatesSizeLimit()) {
        if (getCandidatesSizeLimit()
            != other.getCandidatesSizeLimit()) return false;
      }
      if (hasDecoderExperimentParams() != other.hasDecoderExperimentParams()) return false;
      if (hasDecoderExperimentParams()) {
        if (!getDecoderExperimentParams()
            .equals(other.getDecoderExperimentParams())) return false;
      }
      if (hasFillIncognitoCandidateWords() != other.hasFillIncognitoCandidateWords()) return false;
      if (hasFillIncognitoCandidateWords()) {
        if (getFillIncognitoCandidateWords()
            != other.getFillIncognitoCandidateWords()) return false;
      }
      if (hasEnableA11YDescription() != other.hasEnableA11YDescription()) return false;
      if (hasEnableA11YDescription()) {
        if (getEnableA11YDescription()
            != other.getEnableA11YDescription()) return false;
      }
      if (!additionalRenderableCharacterGroups_.equals(other.additionalRenderableCharacterGroups_)) return false;
      if (hasIsHandwriting() != other.hasIsHandwriting()) return false;
      if (hasIsHandwriting()) {
        if (getIsHandwriting()
            != other.getIsHandwriting()) return false;
      }
      if (hasIsIncognitoMode() != other.hasIsIncognitoMode()) return false;
      if (hasIsIncognitoMode()) {
        if (getIsIncognitoMode()
            != other.getIsIncognitoMode()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasZeroQuerySuggestion()) {
        hash = (37 * hash) + ZERO_QUERY_SUGGESTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getZeroQuerySuggestion());
      }
      if (hasMixedConversion()) {
        hash = (37 * hash) + MIXED_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getMixedConversion());
      }
      if (hasSpecialRomanjiTable()) {
        hash = (37 * hash) + SPECIAL_ROMANJI_TABLE_FIELD_NUMBER;
        hash = (53 * hash) + specialRomanjiTable_;
      }
      if (hasSpaceOnAlphanumeric()) {
        hash = (37 * hash) + SPACE_ON_ALPHANUMERIC_FIELD_NUMBER;
        hash = (53 * hash) + spaceOnAlphanumeric_;
      }
      if (hasKeyboardName()) {
        hash = (37 * hash) + KEYBOARD_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getKeyboardName().hashCode();
      }
      if (hasUpdateInputModeFromSurroundingText()) {
        hash = (37 * hash) + UPDATE_INPUT_MODE_FROM_SURROUNDING_TEXT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUpdateInputModeFromSurroundingText());
      }
      if (hasKanaModifierInsensitiveConversion()) {
        hash = (37 * hash) + KANA_MODIFIER_INSENSITIVE_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getKanaModifierInsensitiveConversion());
      }
      if (hasAutoPartialSuggestion()) {
        hash = (37 * hash) + AUTO_PARTIAL_SUGGESTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAutoPartialSuggestion());
      }
      if (hasEmojiRewriterCapability()) {
        hash = (37 * hash) + EMOJI_REWRITER_CAPABILITY_FIELD_NUMBER;
        hash = (53 * hash) + getEmojiRewriterCapability();
      }
      if (hasCrossingEdgeBehavior()) {
        hash = (37 * hash) + CROSSING_EDGE_BEHAVIOR_FIELD_NUMBER;
        hash = (53 * hash) + crossingEdgeBehavior_;
      }
      if (hasLanguageAwareInput()) {
        hash = (37 * hash) + LANGUAGE_AWARE_INPUT_FIELD_NUMBER;
        hash = (53 * hash) + languageAwareInput_;
      }
      if (hasCandidatePageSize()) {
        hash = (37 * hash) + CANDIDATE_PAGE_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getCandidatePageSize();
      }
      if (hasCandidatesSizeLimit()) {
        hash = (37 * hash) + CANDIDATES_SIZE_LIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getCandidatesSizeLimit();
      }
      if (hasDecoderExperimentParams()) {
        hash = (37 * hash) + DECODER_EXPERIMENT_PARAMS_FIELD_NUMBER;
        hash = (53 * hash) + getDecoderExperimentParams().hashCode();
      }
      if (hasFillIncognitoCandidateWords()) {
        hash = (37 * hash) + FILL_INCOGNITO_CANDIDATE_WORDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getFillIncognitoCandidateWords());
      }
      if (hasEnableA11YDescription()) {
        hash = (37 * hash) + ENABLE_A11Y_DESCRIPTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEnableA11YDescription());
      }
      if (getAdditionalRenderableCharacterGroupsCount() > 0) {
        hash = (37 * hash) + ADDITIONAL_RENDERABLE_CHARACTER_GROUPS_FIELD_NUMBER;
        hash = (53 * hash) + additionalRenderableCharacterGroups_.hashCode();
      }
      if (hasIsHandwriting()) {
        hash = (37 * hash) + IS_HANDWRITING_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsHandwriting());
      }
      if (hasIsIncognitoMode()) {
        hash = (37 * hash) + IS_INCOGNITO_MODE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsIncognitoMode());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Clients' request to the server.
     * Users cannot modify this.
     * In the future each request may be able to be overwritten by Config.
     * The server does not have to obey this request.
     * Next ID: 24
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Request}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Request)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.RequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Request_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Request_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getDecoderExperimentParamsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        zeroQuerySuggestion_ = false;
        mixedConversion_ = false;
        specialRomanjiTable_ = 0;
        spaceOnAlphanumeric_ = 0;
        keyboardName_ = "";
        updateInputModeFromSurroundingText_ = true;
        kanaModifierInsensitiveConversion_ = false;
        autoPartialSuggestion_ = false;
        emojiRewriterCapability_ = 1;
        crossingEdgeBehavior_ = 0;
        languageAwareInput_ = 0;
        candidatePageSize_ = 9;
        candidatesSizeLimit_ = 0;
        decoderExperimentParams_ = null;
        if (decoderExperimentParamsBuilder_ != null) {
          decoderExperimentParamsBuilder_.dispose();
          decoderExperimentParamsBuilder_ = null;
        }
        fillIncognitoCandidateWords_ = false;
        enableA11YDescription_ = false;
        additionalRenderableCharacterGroups_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00010000);
        isHandwriting_ = false;
        isIncognitoMode_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Request_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request result) {
        if (((bitField0_ & 0x00010000) != 0)) {
          additionalRenderableCharacterGroups_ = java.util.Collections.unmodifiableList(additionalRenderableCharacterGroups_);
          bitField0_ = (bitField0_ & ~0x00010000);
        }
        result.additionalRenderableCharacterGroups_ = additionalRenderableCharacterGroups_;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.zeroQuerySuggestion_ = zeroQuerySuggestion_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.mixedConversion_ = mixedConversion_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.specialRomanjiTable_ = specialRomanjiTable_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.spaceOnAlphanumeric_ = spaceOnAlphanumeric_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.keyboardName_ = keyboardName_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.updateInputModeFromSurroundingText_ = updateInputModeFromSurroundingText_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.kanaModifierInsensitiveConversion_ = kanaModifierInsensitiveConversion_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.autoPartialSuggestion_ = autoPartialSuggestion_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.emojiRewriterCapability_ = emojiRewriterCapability_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.crossingEdgeBehavior_ = crossingEdgeBehavior_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.languageAwareInput_ = languageAwareInput_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.candidatePageSize_ = candidatePageSize_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.candidatesSizeLimit_ = candidatesSizeLimit_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.decoderExperimentParams_ = decoderExperimentParamsBuilder_ == null
              ? decoderExperimentParams_
              : decoderExperimentParamsBuilder_.build();
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.fillIncognitoCandidateWords_ = fillIncognitoCandidateWords_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.enableA11YDescription_ = enableA11YDescription_;
          to_bitField0_ |= 0x00008000;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.isHandwriting_ = isHandwriting_;
          to_bitField0_ |= 0x00010000;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.isIncognitoMode_ = isIncognitoMode_;
          to_bitField0_ |= 0x00020000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDefaultInstance()) return this;
        if (other.hasZeroQuerySuggestion()) {
          setZeroQuerySuggestion(other.getZeroQuerySuggestion());
        }
        if (other.hasMixedConversion()) {
          setMixedConversion(other.getMixedConversion());
        }
        if (other.hasSpecialRomanjiTable()) {
          setSpecialRomanjiTable(other.getSpecialRomanjiTable());
        }
        if (other.hasSpaceOnAlphanumeric()) {
          setSpaceOnAlphanumeric(other.getSpaceOnAlphanumeric());
        }
        if (other.hasKeyboardName()) {
          keyboardName_ = other.keyboardName_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasUpdateInputModeFromSurroundingText()) {
          setUpdateInputModeFromSurroundingText(other.getUpdateInputModeFromSurroundingText());
        }
        if (other.hasKanaModifierInsensitiveConversion()) {
          setKanaModifierInsensitiveConversion(other.getKanaModifierInsensitiveConversion());
        }
        if (other.hasAutoPartialSuggestion()) {
          setAutoPartialSuggestion(other.getAutoPartialSuggestion());
        }
        if (other.hasEmojiRewriterCapability()) {
          setEmojiRewriterCapability(other.getEmojiRewriterCapability());
        }
        if (other.hasCrossingEdgeBehavior()) {
          setCrossingEdgeBehavior(other.getCrossingEdgeBehavior());
        }
        if (other.hasLanguageAwareInput()) {
          setLanguageAwareInput(other.getLanguageAwareInput());
        }
        if (other.hasCandidatePageSize()) {
          setCandidatePageSize(other.getCandidatePageSize());
        }
        if (other.hasCandidatesSizeLimit()) {
          setCandidatesSizeLimit(other.getCandidatesSizeLimit());
        }
        if (other.hasDecoderExperimentParams()) {
          mergeDecoderExperimentParams(other.getDecoderExperimentParams());
        }
        if (other.hasFillIncognitoCandidateWords()) {
          setFillIncognitoCandidateWords(other.getFillIncognitoCandidateWords());
        }
        if (other.hasEnableA11YDescription()) {
          setEnableA11YDescription(other.getEnableA11YDescription());
        }
        if (!other.additionalRenderableCharacterGroups_.isEmpty()) {
          if (additionalRenderableCharacterGroups_.isEmpty()) {
            additionalRenderableCharacterGroups_ = other.additionalRenderableCharacterGroups_;
            bitField0_ = (bitField0_ & ~0x00010000);
          } else {
            ensureAdditionalRenderableCharacterGroupsIsMutable();
            additionalRenderableCharacterGroups_.addAll(other.additionalRenderableCharacterGroups_);
          }
          onChanged();
        }
        if (other.hasIsHandwriting()) {
          setIsHandwriting(other.getIsHandwriting());
        }
        if (other.hasIsIncognitoMode()) {
          setIsIncognitoMode(other.getIsIncognitoMode());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                zeroQuerySuggestion_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                mixedConversion_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 32: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(4, tmpRaw);
                } else {
                  specialRomanjiTable_ = tmpRaw;
                  bitField0_ |= 0x00000004;
                }
                break;
              } // case 32
              case 48: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(6, tmpRaw);
                } else {
                  spaceOnAlphanumeric_ = tmpRaw;
                  bitField0_ |= 0x00000008;
                }
                break;
              } // case 48
              case 58: {
                keyboardName_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 58
              case 64: {
                updateInputModeFromSurroundingText_ = input.readBool();
                bitField0_ |= 0x00000020;
                break;
              } // case 64
              case 72: {
                kanaModifierInsensitiveConversion_ = input.readBool();
                bitField0_ |= 0x00000040;
                break;
              } // case 72
              case 80: {
                autoPartialSuggestion_ = input.readBool();
                bitField0_ |= 0x00000080;
                break;
              } // case 80
              case 96: {
                emojiRewriterCapability_ = input.readInt32();
                bitField0_ |= 0x00000100;
                break;
              } // case 96
              case 104: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(13, tmpRaw);
                } else {
                  crossingEdgeBehavior_ = tmpRaw;
                  bitField0_ |= 0x00000200;
                }
                break;
              } // case 104
              case 112: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(14, tmpRaw);
                } else {
                  languageAwareInput_ = tmpRaw;
                  bitField0_ |= 0x00000400;
                }
                break;
              } // case 112
              case 120: {
                candidatePageSize_ = input.readInt32();
                bitField0_ |= 0x00000800;
                break;
              } // case 120
              case 128: {
                candidatesSizeLimit_ = input.readInt32();
                bitField0_ |= 0x00001000;
                break;
              } // case 128
              case 138: {
                input.readMessage(
                    getDecoderExperimentParamsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00002000;
                break;
              } // case 138
              case 144: {
                fillIncognitoCandidateWords_ = input.readBool();
                bitField0_ |= 0x00004000;
                break;
              } // case 144
              case 160: {
                enableA11YDescription_ = input.readBool();
                bitField0_ |= 0x00008000;
                break;
              } // case 160
              case 168: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(21, tmpRaw);
                } else {
                  ensureAdditionalRenderableCharacterGroupsIsMutable();
                  additionalRenderableCharacterGroups_.add(tmpRaw);
                }
                break;
              } // case 168
              case 170: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup tmpValue =
                      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(21, tmpRaw);
                  } else {
                    ensureAdditionalRenderableCharacterGroupsIsMutable();
                    additionalRenderableCharacterGroups_.add(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 170
              case 176: {
                isHandwriting_ = input.readBool();
                bitField0_ |= 0x00020000;
                break;
              } // case 176
              case 184: {
                isIncognitoMode_ = input.readBool();
                bitField0_ |= 0x00040000;
                break;
              } // case 184
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean zeroQuerySuggestion_ ;
      /**
       * <pre>
       * Enable zero query suggestion.
       * </pre>
       *
       * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
       * @return Whether the zeroQuerySuggestion field is set.
       */
      @java.lang.Override
      public boolean hasZeroQuerySuggestion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Enable zero query suggestion.
       * </pre>
       *
       * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
       * @return The zeroQuerySuggestion.
       */
      @java.lang.Override
      public boolean getZeroQuerySuggestion() {
        return zeroQuerySuggestion_;
      }
      /**
       * <pre>
       * Enable zero query suggestion.
       * </pre>
       *
       * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
       * @param value The zeroQuerySuggestion to set.
       * @return This builder for chaining.
       */
      public Builder setZeroQuerySuggestion(boolean value) {
        
        zeroQuerySuggestion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Enable zero query suggestion.
       * </pre>
       *
       * <code>optional bool zero_query_suggestion = 1 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearZeroQuerySuggestion() {
        bitField0_ = (bitField0_ & ~0x00000001);
        zeroQuerySuggestion_ = false;
        onChanged();
        return this;
      }

      private boolean mixedConversion_ ;
      /**
       * <pre>
       * Conversion's candidate includes suggestion, prediction and conversion.
       * </pre>
       *
       * <code>optional bool mixed_conversion = 2 [default = false];</code>
       * @return Whether the mixedConversion field is set.
       */
      @java.lang.Override
      public boolean hasMixedConversion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Conversion's candidate includes suggestion, prediction and conversion.
       * </pre>
       *
       * <code>optional bool mixed_conversion = 2 [default = false];</code>
       * @return The mixedConversion.
       */
      @java.lang.Override
      public boolean getMixedConversion() {
        return mixedConversion_;
      }
      /**
       * <pre>
       * Conversion's candidate includes suggestion, prediction and conversion.
       * </pre>
       *
       * <code>optional bool mixed_conversion = 2 [default = false];</code>
       * @param value The mixedConversion to set.
       * @return This builder for chaining.
       */
      public Builder setMixedConversion(boolean value) {
        
        mixedConversion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Conversion's candidate includes suggestion, prediction and conversion.
       * </pre>
       *
       * <code>optional bool mixed_conversion = 2 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearMixedConversion() {
        bitField0_ = (bitField0_ & ~0x00000002);
        mixedConversion_ = false;
        onChanged();
        return this;
      }

      private int specialRomanjiTable_ = 0;
      /**
       * <pre>
       * Use special Romanji table.
       * </pre>
       *
       * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
       * @return Whether the specialRomanjiTable field is set.
       */
      @java.lang.Override public boolean hasSpecialRomanjiTable() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Use special Romanji table.
       * </pre>
       *
       * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
       * @return The specialRomanjiTable.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable getSpecialRomanjiTable() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable.forNumber(specialRomanjiTable_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable.DEFAULT_TABLE : result;
      }
      /**
       * <pre>
       * Use special Romanji table.
       * </pre>
       *
       * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
       * @param value The specialRomanjiTable to set.
       * @return This builder for chaining.
       */
      public Builder setSpecialRomanjiTable(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpecialRomanjiTable value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        specialRomanjiTable_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use special Romanji table.
       * </pre>
       *
       * <code>optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];</code>
       * @return This builder for chaining.
       */
      public Builder clearSpecialRomanjiTable() {
        bitField0_ = (bitField0_ & ~0x00000004);
        specialRomanjiTable_ = 0;
        onChanged();
        return this;
      }

      private int spaceOnAlphanumeric_ = 0;
      /**
       * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
       * @return Whether the spaceOnAlphanumeric field is set.
       */
      @java.lang.Override public boolean hasSpaceOnAlphanumeric() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
       * @return The spaceOnAlphanumeric.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric getSpaceOnAlphanumeric() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric.forNumber(spaceOnAlphanumeric_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric.SPACE_OR_CONVERT_KEEPING_COMPOSITION : result;
      }
      /**
       * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
       * @param value The spaceOnAlphanumeric to set.
       * @return This builder for chaining.
       */
      public Builder setSpaceOnAlphanumeric(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.SpaceOnAlphanumeric value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        spaceOnAlphanumeric_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];</code>
       * @return This builder for chaining.
       */
      public Builder clearSpaceOnAlphanumeric() {
        bitField0_ = (bitField0_ & ~0x00000008);
        spaceOnAlphanumeric_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object keyboardName_ = "";
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @return Whether the keyboardName field is set.
       */
      public boolean hasKeyboardName() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @return The keyboardName.
       */
      public java.lang.String getKeyboardName() {
        java.lang.Object ref = keyboardName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            keyboardName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @return The bytes for keyboardName.
       */
      public com.google.protobuf.ByteString
          getKeyboardNameBytes() {
        java.lang.Object ref = keyboardName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          keyboardName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @param value The keyboardName to set.
       * @return This builder for chaining.
       */
      public Builder setKeyboardName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        keyboardName_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyboardName() {
        keyboardName_ = getDefaultInstance().getKeyboardName();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Keyboard name for touch devices.
       * For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
       * It is used to analyze touch event usage stats.
       * </pre>
       *
       * <code>optional string keyboard_name = 7;</code>
       * @param value The bytes for keyboardName to set.
       * @return This builder for chaining.
       */
      public Builder setKeyboardNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        keyboardName_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private boolean updateInputModeFromSurroundingText_ = true;
      /**
       * <pre>
       * Enables Composer's input mode auto updating by using surrounding text.
       * For example, when a composition string is "ad", a carret is at the end,
       * and a user selects HIRAGANA mode, if the user moves the carret to between
       * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
       * See details in the Composer::UpdateInputMode.
       * </pre>
       *
       * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
       * @return Whether the updateInputModeFromSurroundingText field is set.
       */
      @java.lang.Override
      public boolean hasUpdateInputModeFromSurroundingText() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Enables Composer's input mode auto updating by using surrounding text.
       * For example, when a composition string is "ad", a carret is at the end,
       * and a user selects HIRAGANA mode, if the user moves the carret to between
       * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
       * See details in the Composer::UpdateInputMode.
       * </pre>
       *
       * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
       * @return The updateInputModeFromSurroundingText.
       */
      @java.lang.Override
      public boolean getUpdateInputModeFromSurroundingText() {
        return updateInputModeFromSurroundingText_;
      }
      /**
       * <pre>
       * Enables Composer's input mode auto updating by using surrounding text.
       * For example, when a composition string is "ad", a carret is at the end,
       * and a user selects HIRAGANA mode, if the user moves the carret to between
       * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
       * See details in the Composer::UpdateInputMode.
       * </pre>
       *
       * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
       * @param value The updateInputModeFromSurroundingText to set.
       * @return This builder for chaining.
       */
      public Builder setUpdateInputModeFromSurroundingText(boolean value) {
        
        updateInputModeFromSurroundingText_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Enables Composer's input mode auto updating by using surrounding text.
       * For example, when a composition string is "ad", a carret is at the end,
       * and a user selects HIRAGANA mode, if the user moves the carret to between
       * "a" and "d" the mode will be automatically switch to ASCII (temporarily).
       * See details in the Composer::UpdateInputMode.
       * </pre>
       *
       * <code>optional bool update_input_mode_from_surrounding_text = 8 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUpdateInputModeFromSurroundingText() {
        bitField0_ = (bitField0_ & ~0x00000020);
        updateInputModeFromSurroundingText_ = true;
        onChanged();
        return this;
      }

      private boolean kanaModifierInsensitiveConversion_ ;
      /**
       * <pre>
       * Enables Kana-modifier-insensitive conversion as follows:
       * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
       *    e.g.) "ば" and "ぱ" will be hit by key "は".
       * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
       * 3) Palatalized kana will be hit by non-modified kana.
       *    e.g.) "ゃ" will be hit by key "や".
       * Here is an example of the search: "学校" ("がっこう") will be hit
       * by "かつこう".
       * </pre>
       *
       * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
       * @return Whether the kanaModifierInsensitiveConversion field is set.
       */
      @java.lang.Override
      public boolean hasKanaModifierInsensitiveConversion() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Enables Kana-modifier-insensitive conversion as follows:
       * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
       *    e.g.) "ば" and "ぱ" will be hit by key "は".
       * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
       * 3) Palatalized kana will be hit by non-modified kana.
       *    e.g.) "ゃ" will be hit by key "や".
       * Here is an example of the search: "学校" ("がっこう") will be hit
       * by "かつこう".
       * </pre>
       *
       * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
       * @return The kanaModifierInsensitiveConversion.
       */
      @java.lang.Override
      public boolean getKanaModifierInsensitiveConversion() {
        return kanaModifierInsensitiveConversion_;
      }
      /**
       * <pre>
       * Enables Kana-modifier-insensitive conversion as follows:
       * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
       *    e.g.) "ば" and "ぱ" will be hit by key "は".
       * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
       * 3) Palatalized kana will be hit by non-modified kana.
       *    e.g.) "ゃ" will be hit by key "や".
       * Here is an example of the search: "学校" ("がっこう") will be hit
       * by "かつこう".
       * </pre>
       *
       * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
       * @param value The kanaModifierInsensitiveConversion to set.
       * @return This builder for chaining.
       */
      public Builder setKanaModifierInsensitiveConversion(boolean value) {
        
        kanaModifierInsensitiveConversion_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Enables Kana-modifier-insensitive conversion as follows:
       * 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
       *    e.g.) "ば" and "ぱ" will be hit by key "は".
       * 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
       * 3) Palatalized kana will be hit by non-modified kana.
       *    e.g.) "ゃ" will be hit by key "や".
       * Here is an example of the search: "学校" ("がっこう") will be hit
       * by "かつこう".
       * </pre>
       *
       * <code>optional bool kana_modifier_insensitive_conversion = 9 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearKanaModifierInsensitiveConversion() {
        bitField0_ = (bitField0_ & ~0x00000040);
        kanaModifierInsensitiveConversion_ = false;
        onChanged();
        return this;
      }

      private boolean autoPartialSuggestion_ ;
      /**
       * <pre>
       * Enables Auto partial suggestion (prefix candidates).
       * For Auto partial suggestion, we can see candidates that match
       * the prefix of the input reading.
       * If we commit that candidate, we will show suggestions for remaining part
       * of key.
       * Note: This feature can be enabled only for mobile due to UX design.
       * </pre>
       *
       * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
       * @return Whether the autoPartialSuggestion field is set.
       */
      @java.lang.Override
      public boolean hasAutoPartialSuggestion() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Enables Auto partial suggestion (prefix candidates).
       * For Auto partial suggestion, we can see candidates that match
       * the prefix of the input reading.
       * If we commit that candidate, we will show suggestions for remaining part
       * of key.
       * Note: This feature can be enabled only for mobile due to UX design.
       * </pre>
       *
       * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
       * @return The autoPartialSuggestion.
       */
      @java.lang.Override
      public boolean getAutoPartialSuggestion() {
        return autoPartialSuggestion_;
      }
      /**
       * <pre>
       * Enables Auto partial suggestion (prefix candidates).
       * For Auto partial suggestion, we can see candidates that match
       * the prefix of the input reading.
       * If we commit that candidate, we will show suggestions for remaining part
       * of key.
       * Note: This feature can be enabled only for mobile due to UX design.
       * </pre>
       *
       * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
       * @param value The autoPartialSuggestion to set.
       * @return This builder for chaining.
       */
      public Builder setAutoPartialSuggestion(boolean value) {
        
        autoPartialSuggestion_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Enables Auto partial suggestion (prefix candidates).
       * For Auto partial suggestion, we can see candidates that match
       * the prefix of the input reading.
       * If we commit that candidate, we will show suggestions for remaining part
       * of key.
       * Note: This feature can be enabled only for mobile due to UX design.
       * </pre>
       *
       * <code>optional bool auto_partial_suggestion = 10 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoPartialSuggestion() {
        bitField0_ = (bitField0_ & ~0x00000080);
        autoPartialSuggestion_ = false;
        onChanged();
        return this;
      }

      private int emojiRewriterCapability_ = 1;
      /**
       * <pre>
       * By default, Emoji rewriter works on conversion mode only.
       * </pre>
       *
       * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
       * @return Whether the emojiRewriterCapability field is set.
       */
      @java.lang.Override
      public boolean hasEmojiRewriterCapability() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * By default, Emoji rewriter works on conversion mode only.
       * </pre>
       *
       * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
       * @return The emojiRewriterCapability.
       */
      @java.lang.Override
      public int getEmojiRewriterCapability() {
        return emojiRewriterCapability_;
      }
      /**
       * <pre>
       * By default, Emoji rewriter works on conversion mode only.
       * </pre>
       *
       * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
       * @param value The emojiRewriterCapability to set.
       * @return This builder for chaining.
       */
      public Builder setEmojiRewriterCapability(int value) {
        
        emojiRewriterCapability_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * By default, Emoji rewriter works on conversion mode only.
       * </pre>
       *
       * <code>optional int32 emoji_rewriter_capability = 12 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearEmojiRewriterCapability() {
        bitField0_ = (bitField0_ & ~0x00000100);
        emojiRewriterCapability_ = 1;
        onChanged();
        return this;
      }

      private int crossingEdgeBehavior_ = 0;
      /**
       * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
       * @return Whether the crossingEdgeBehavior field is set.
       */
      @java.lang.Override public boolean hasCrossingEdgeBehavior() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
       * @return The crossingEdgeBehavior.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior getCrossingEdgeBehavior() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior.forNumber(crossingEdgeBehavior_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior.DO_NOTHING : result;
      }
      /**
       * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
       * @param value The crossingEdgeBehavior to set.
       * @return This builder for chaining.
       */
      public Builder setCrossingEdgeBehavior(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.CrossingEdgeBehavior value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000200;
        crossingEdgeBehavior_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];</code>
       * @return This builder for chaining.
       */
      public Builder clearCrossingEdgeBehavior() {
        bitField0_ = (bitField0_ & ~0x00000200);
        crossingEdgeBehavior_ = 0;
        onChanged();
        return this;
      }

      private int languageAwareInput_ = 0;
      /**
       * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
       * @return Whether the languageAwareInput field is set.
       */
      @java.lang.Override public boolean hasLanguageAwareInput() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
       * @return The languageAwareInput.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior getLanguageAwareInput() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior.forNumber(languageAwareInput_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior.DEFAULT_LANGUAGE_AWARE_BEHAVIOR : result;
      }
      /**
       * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
       * @param value The languageAwareInput to set.
       * @return This builder for chaining.
       */
      public Builder setLanguageAwareInput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.LanguageAwareInputBehavior value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000400;
        languageAwareInput_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];</code>
       * @return This builder for chaining.
       */
      public Builder clearLanguageAwareInput() {
        bitField0_ = (bitField0_ & ~0x00000400);
        languageAwareInput_ = 0;
        onChanged();
        return this;
      }

      private int candidatePageSize_ = 9;
      /**
       * <pre>
       * Page size of the candidate list.
       * </pre>
       *
       * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
       * @return Whether the candidatePageSize field is set.
       */
      @java.lang.Override
      public boolean hasCandidatePageSize() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Page size of the candidate list.
       * </pre>
       *
       * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
       * @return The candidatePageSize.
       */
      @java.lang.Override
      public int getCandidatePageSize() {
        return candidatePageSize_;
      }
      /**
       * <pre>
       * Page size of the candidate list.
       * </pre>
       *
       * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
       * @param value The candidatePageSize to set.
       * @return This builder for chaining.
       */
      public Builder setCandidatePageSize(int value) {
        
        candidatePageSize_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Page size of the candidate list.
       * </pre>
       *
       * <code>optional int32 candidate_page_size = 15 [default = 9];</code>
       * @return This builder for chaining.
       */
      public Builder clearCandidatePageSize() {
        bitField0_ = (bitField0_ & ~0x00000800);
        candidatePageSize_ = 9;
        onChanged();
        return this;
      }

      private int candidatesSizeLimit_ ;
      /**
       * <pre>
       * The maximum limit of the candidates size.
       * If not set, converter doesn't limit the size.
       * NOTE: Each segment has at least one candidate and meta candidates even if
       *       this value is set to 0.
       * </pre>
       *
       * <code>optional int32 candidates_size_limit = 16;</code>
       * @return Whether the candidatesSizeLimit field is set.
       */
      @java.lang.Override
      public boolean hasCandidatesSizeLimit() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * The maximum limit of the candidates size.
       * If not set, converter doesn't limit the size.
       * NOTE: Each segment has at least one candidate and meta candidates even if
       *       this value is set to 0.
       * </pre>
       *
       * <code>optional int32 candidates_size_limit = 16;</code>
       * @return The candidatesSizeLimit.
       */
      @java.lang.Override
      public int getCandidatesSizeLimit() {
        return candidatesSizeLimit_;
      }
      /**
       * <pre>
       * The maximum limit of the candidates size.
       * If not set, converter doesn't limit the size.
       * NOTE: Each segment has at least one candidate and meta candidates even if
       *       this value is set to 0.
       * </pre>
       *
       * <code>optional int32 candidates_size_limit = 16;</code>
       * @param value The candidatesSizeLimit to set.
       * @return This builder for chaining.
       */
      public Builder setCandidatesSizeLimit(int value) {
        
        candidatesSizeLimit_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum limit of the candidates size.
       * If not set, converter doesn't limit the size.
       * NOTE: Each segment has at least one candidate and meta candidates even if
       *       this value is set to 0.
       * </pre>
       *
       * <code>optional int32 candidates_size_limit = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearCandidatesSizeLimit() {
        bitField0_ = (bitField0_ & ~0x00001000);
        candidatesSizeLimit_ = 0;
        onChanged();
        return this;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams decoderExperimentParams_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParamsOrBuilder> decoderExperimentParamsBuilder_;
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       * @return Whether the decoderExperimentParams field is set.
       */
      public boolean hasDecoderExperimentParams() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       * @return The decoderExperimentParams.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams getDecoderExperimentParams() {
        if (decoderExperimentParamsBuilder_ == null) {
          return decoderExperimentParams_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDefaultInstance() : decoderExperimentParams_;
        } else {
          return decoderExperimentParamsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public Builder setDecoderExperimentParams(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams value) {
        if (decoderExperimentParamsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          decoderExperimentParams_ = value;
        } else {
          decoderExperimentParamsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public Builder setDecoderExperimentParams(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.Builder builderForValue) {
        if (decoderExperimentParamsBuilder_ == null) {
          decoderExperimentParams_ = builderForValue.build();
        } else {
          decoderExperimentParamsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public Builder mergeDecoderExperimentParams(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams value) {
        if (decoderExperimentParamsBuilder_ == null) {
          if (((bitField0_ & 0x00002000) != 0) &&
            decoderExperimentParams_ != null &&
            decoderExperimentParams_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDefaultInstance()) {
            getDecoderExperimentParamsBuilder().mergeFrom(value);
          } else {
            decoderExperimentParams_ = value;
          }
        } else {
          decoderExperimentParamsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public Builder clearDecoderExperimentParams() {
        bitField0_ = (bitField0_ & ~0x00002000);
        decoderExperimentParams_ = null;
        if (decoderExperimentParamsBuilder_ != null) {
          decoderExperimentParamsBuilder_.dispose();
          decoderExperimentParamsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.Builder getDecoderExperimentParamsBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getDecoderExperimentParamsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParamsOrBuilder getDecoderExperimentParamsOrBuilder() {
        if (decoderExperimentParamsBuilder_ != null) {
          return decoderExperimentParamsBuilder_.getMessageOrBuilder();
        } else {
          return decoderExperimentParams_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.getDefaultInstance() : decoderExperimentParams_;
        }
      }
      /**
       * <pre>
       * Experimentally changes the decoder's behavior.
       * This flag is usually populated through the phenotype flags.
       * </pre>
       *
       * <code>optional .mozc.commands.DecoderExperimentParams decoder_experiment_params = 17;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParamsOrBuilder> 
          getDecoderExperimentParamsFieldBuilder() {
        if (decoderExperimentParamsBuilder_ == null) {
          decoderExperimentParamsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParams.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DecoderExperimentParamsOrBuilder>(
                  getDecoderExperimentParams(),
                  getParentForChildren(),
                  isClean());
          decoderExperimentParams_ = null;
        }
        return decoderExperimentParamsBuilder_;
      }

      private boolean fillIncognitoCandidateWords_ ;
      /**
       * <pre>
       * Fills incognito_candidate_words filed of output.
       * </pre>
       *
       * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
       * @return Whether the fillIncognitoCandidateWords field is set.
       */
      @java.lang.Override
      public boolean hasFillIncognitoCandidateWords() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * Fills incognito_candidate_words filed of output.
       * </pre>
       *
       * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
       * @return The fillIncognitoCandidateWords.
       */
      @java.lang.Override
      public boolean getFillIncognitoCandidateWords() {
        return fillIncognitoCandidateWords_;
      }
      /**
       * <pre>
       * Fills incognito_candidate_words filed of output.
       * </pre>
       *
       * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
       * @param value The fillIncognitoCandidateWords to set.
       * @return This builder for chaining.
       */
      public Builder setFillIncognitoCandidateWords(boolean value) {
        
        fillIncognitoCandidateWords_ = value;
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Fills incognito_candidate_words filed of output.
       * </pre>
       *
       * <code>optional bool fill_incognito_candidate_words = 18 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearFillIncognitoCandidateWords() {
        bitField0_ = (bitField0_ & ~0x00004000);
        fillIncognitoCandidateWords_ = false;
        onChanged();
        return this;
      }

      private boolean enableA11YDescription_ ;
      /**
       * <pre>
       * Enables a11y support for candidates.
       * If this field is set to true, a11y description is set to each candidate.
       * </pre>
       *
       * <code>optional bool enable_a11y_description = 20 [default = false];</code>
       * @return Whether the enableA11yDescription field is set.
       */
      @java.lang.Override
      public boolean hasEnableA11YDescription() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * Enables a11y support for candidates.
       * If this field is set to true, a11y description is set to each candidate.
       * </pre>
       *
       * <code>optional bool enable_a11y_description = 20 [default = false];</code>
       * @return The enableA11yDescription.
       */
      @java.lang.Override
      public boolean getEnableA11YDescription() {
        return enableA11YDescription_;
      }
      /**
       * <pre>
       * Enables a11y support for candidates.
       * If this field is set to true, a11y description is set to each candidate.
       * </pre>
       *
       * <code>optional bool enable_a11y_description = 20 [default = false];</code>
       * @param value The enableA11yDescription to set.
       * @return This builder for chaining.
       */
      public Builder setEnableA11YDescription(boolean value) {
        
        enableA11YDescription_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Enables a11y support for candidates.
       * If this field is set to true, a11y description is set to each candidate.
       * </pre>
       *
       * <code>optional bool enable_a11y_description = 20 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearEnableA11YDescription() {
        bitField0_ = (bitField0_ & ~0x00008000);
        enableA11YDescription_ = false;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> additionalRenderableCharacterGroups_ =
        java.util.Collections.emptyList();
      private void ensureAdditionalRenderableCharacterGroupsIsMutable() {
        if (!((bitField0_ & 0x00010000) != 0)) {
          additionalRenderableCharacterGroups_ = new java.util.ArrayList<java.lang.Integer>(additionalRenderableCharacterGroups_);
          bitField0_ |= 0x00010000;
        }
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @return A list containing the additionalRenderableCharacterGroups.
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> getAdditionalRenderableCharacterGroupsList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup>(additionalRenderableCharacterGroups_, additionalRenderableCharacterGroups_converter_);
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @return The count of additionalRenderableCharacterGroups.
       */
      public int getAdditionalRenderableCharacterGroupsCount() {
        return additionalRenderableCharacterGroups_.size();
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The additionalRenderableCharacterGroups at the given index.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup getAdditionalRenderableCharacterGroups(int index) {
        return additionalRenderableCharacterGroups_converter_.convert(additionalRenderableCharacterGroups_.get(index));
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The additionalRenderableCharacterGroups to set.
       * @return This builder for chaining.
       */
      public Builder setAdditionalRenderableCharacterGroups(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAdditionalRenderableCharacterGroupsIsMutable();
        additionalRenderableCharacterGroups_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @param value The additionalRenderableCharacterGroups to add.
       * @return This builder for chaining.
       */
      public Builder addAdditionalRenderableCharacterGroups(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAdditionalRenderableCharacterGroupsIsMutable();
        additionalRenderableCharacterGroups_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @param values The additionalRenderableCharacterGroups to add.
       * @return This builder for chaining.
       */
      public Builder addAllAdditionalRenderableCharacterGroups(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup> values) {
        ensureAdditionalRenderableCharacterGroupsIsMutable();
        for (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.AdditionalRenderableCharacterGroup value : values) {
          additionalRenderableCharacterGroups_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Characters in the union of this list of groups can be contained in
       * candidates.
       * This feature is distinct from user preference. Do not make these option
       * user selectable.
       * </pre>
       *
       * <code>repeated .mozc.commands.Request.AdditionalRenderableCharacterGroup additional_renderable_character_groups = 21 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearAdditionalRenderableCharacterGroups() {
        additionalRenderableCharacterGroups_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00010000);
        onChanged();
        return this;
      }

      private boolean isHandwriting_ ;
      /**
       * <pre>
       * Whether the request is from handwriting. Candidates can be optimized
       * differently for handwriting.
       * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
       * handwriting.
       * </pre>
       *
       * <code>optional bool is_handwriting = 22 [default = false];</code>
       * @return Whether the isHandwriting field is set.
       */
      @java.lang.Override
      public boolean hasIsHandwriting() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * Whether the request is from handwriting. Candidates can be optimized
       * differently for handwriting.
       * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
       * handwriting.
       * </pre>
       *
       * <code>optional bool is_handwriting = 22 [default = false];</code>
       * @return The isHandwriting.
       */
      @java.lang.Override
      public boolean getIsHandwriting() {
        return isHandwriting_;
      }
      /**
       * <pre>
       * Whether the request is from handwriting. Candidates can be optimized
       * differently for handwriting.
       * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
       * handwriting.
       * </pre>
       *
       * <code>optional bool is_handwriting = 22 [default = false];</code>
       * @param value The isHandwriting to set.
       * @return This builder for chaining.
       */
      public Builder setIsHandwriting(boolean value) {
        
        isHandwriting_ = value;
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the request is from handwriting. Candidates can be optimized
       * differently for handwriting.
       * For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
       * handwriting.
       * </pre>
       *
       * <code>optional bool is_handwriting = 22 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIsHandwriting() {
        bitField0_ = (bitField0_ & ~0x00020000);
        isHandwriting_ = false;
        onChanged();
        return this;
      }

      private boolean isIncognitoMode_ ;
      /**
       * <pre>
       * Whether the conversion is performed in incognito mode.
       * In incognito mode, the conversion is performed without using
       * user history and user dictionary.
       * When any of this value and Config::incognito_mode are true,
       * incognito mode is enabled.
       * Clients needs to check ConversionRequest::incognito_mode() instead of
       * this value directly, as the incognito mode can be set in other ways.
       * </pre>
       *
       * <code>optional bool is_incognito_mode = 23 [default = false];</code>
       * @return Whether the isIncognitoMode field is set.
       */
      @java.lang.Override
      public boolean hasIsIncognitoMode() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * Whether the conversion is performed in incognito mode.
       * In incognito mode, the conversion is performed without using
       * user history and user dictionary.
       * When any of this value and Config::incognito_mode are true,
       * incognito mode is enabled.
       * Clients needs to check ConversionRequest::incognito_mode() instead of
       * this value directly, as the incognito mode can be set in other ways.
       * </pre>
       *
       * <code>optional bool is_incognito_mode = 23 [default = false];</code>
       * @return The isIncognitoMode.
       */
      @java.lang.Override
      public boolean getIsIncognitoMode() {
        return isIncognitoMode_;
      }
      /**
       * <pre>
       * Whether the conversion is performed in incognito mode.
       * In incognito mode, the conversion is performed without using
       * user history and user dictionary.
       * When any of this value and Config::incognito_mode are true,
       * incognito mode is enabled.
       * Clients needs to check ConversionRequest::incognito_mode() instead of
       * this value directly, as the incognito mode can be set in other ways.
       * </pre>
       *
       * <code>optional bool is_incognito_mode = 23 [default = false];</code>
       * @param value The isIncognitoMode to set.
       * @return This builder for chaining.
       */
      public Builder setIsIncognitoMode(boolean value) {
        
        isIncognitoMode_ = value;
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the conversion is performed in incognito mode.
       * In incognito mode, the conversion is performed without using
       * user history and user dictionary.
       * When any of this value and Config::incognito_mode are true,
       * incognito mode is enabled.
       * Clients needs to check ConversionRequest::incognito_mode() instead of
       * this value directly, as the incognito mode can be set in other ways.
       * </pre>
       *
       * <code>optional bool is_incognito_mode = 23 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIsIncognitoMode() {
        bitField0_ = (bitField0_ & ~0x00040000);
        isIncognitoMode_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.Request)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.Request)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Request>
        PARSER = new com.google.protobuf.AbstractParser<Request>() {
      @java.lang.Override
      public Request parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Request> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Request> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ApplicationInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.ApplicationInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint32 process_id = 1;</code>
     * @return Whether the processId field is set.
     */
    boolean hasProcessId();
    /**
     * <code>optional uint32 process_id = 1;</code>
     * @return The processId.
     */
    int getProcessId();

    /**
     * <code>optional uint32 thread_id = 2;</code>
     * @return Whether the threadId field is set.
     */
    boolean hasThreadId();
    /**
     * <code>optional uint32 thread_id = 2;</code>
     * @return The threadId.
     */
    int getThreadId();
  }
  /**
   * <pre>
   * Note there is another ApplicationInfo inside RendererCommand.
   * Since Input is not using nested message, define ApplicationInfo here.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.ApplicationInfo}
   */
  public static final class ApplicationInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.ApplicationInfo)
      ApplicationInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ApplicationInfo.newBuilder() to construct.
    private ApplicationInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ApplicationInfo() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ApplicationInfo();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ApplicationInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ApplicationInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.Builder.class);
    }

    private int bitField0_;
    public static final int PROCESS_ID_FIELD_NUMBER = 1;
    private int processId_ = 0;
    /**
     * <code>optional uint32 process_id = 1;</code>
     * @return Whether the processId field is set.
     */
    @java.lang.Override
    public boolean hasProcessId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint32 process_id = 1;</code>
     * @return The processId.
     */
    @java.lang.Override
    public int getProcessId() {
      return processId_;
    }

    public static final int THREAD_ID_FIELD_NUMBER = 2;
    private int threadId_ = 0;
    /**
     * <code>optional uint32 thread_id = 2;</code>
     * @return Whether the threadId field is set.
     */
    @java.lang.Override
    public boolean hasThreadId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional uint32 thread_id = 2;</code>
     * @return The threadId.
     */
    @java.lang.Override
    public int getThreadId() {
      return threadId_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(1, processId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt32(2, threadId_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, processId_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, threadId_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo) obj;

      if (hasProcessId() != other.hasProcessId()) return false;
      if (hasProcessId()) {
        if (getProcessId()
            != other.getProcessId()) return false;
      }
      if (hasThreadId() != other.hasThreadId()) return false;
      if (hasThreadId()) {
        if (getThreadId()
            != other.getThreadId()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasProcessId()) {
        hash = (37 * hash) + PROCESS_ID_FIELD_NUMBER;
        hash = (53 * hash) + getProcessId();
      }
      if (hasThreadId()) {
        hash = (37 * hash) + THREAD_ID_FIELD_NUMBER;
        hash = (53 * hash) + getThreadId();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Note there is another ApplicationInfo inside RendererCommand.
     * Since Input is not using nested message, define ApplicationInfo here.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.ApplicationInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.ApplicationInfo)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ApplicationInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ApplicationInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        processId_ = 0;
        threadId_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ApplicationInfo_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.processId_ = processId_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.threadId_ = threadId_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.getDefaultInstance()) return this;
        if (other.hasProcessId()) {
          setProcessId(other.getProcessId());
        }
        if (other.hasThreadId()) {
          setThreadId(other.getThreadId());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                processId_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                threadId_ = input.readUInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int processId_ ;
      /**
       * <code>optional uint32 process_id = 1;</code>
       * @return Whether the processId field is set.
       */
      @java.lang.Override
      public boolean hasProcessId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint32 process_id = 1;</code>
       * @return The processId.
       */
      @java.lang.Override
      public int getProcessId() {
        return processId_;
      }
      /**
       * <code>optional uint32 process_id = 1;</code>
       * @param value The processId to set.
       * @return This builder for chaining.
       */
      public Builder setProcessId(int value) {
        
        processId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 process_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearProcessId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        processId_ = 0;
        onChanged();
        return this;
      }

      private int threadId_ ;
      /**
       * <code>optional uint32 thread_id = 2;</code>
       * @return Whether the threadId field is set.
       */
      @java.lang.Override
      public boolean hasThreadId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional uint32 thread_id = 2;</code>
       * @return The threadId.
       */
      @java.lang.Override
      public int getThreadId() {
        return threadId_;
      }
      /**
       * <code>optional uint32 thread_id = 2;</code>
       * @param value The threadId to set.
       * @return This builder for chaining.
       */
      public Builder setThreadId(int value) {
        
        threadId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 thread_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearThreadId() {
        bitField0_ = (bitField0_ & ~0x00000002);
        threadId_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.ApplicationInfo)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.ApplicationInfo)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ApplicationInfo>
        PARSER = new com.google.protobuf.AbstractParser<ApplicationInfo>() {
      @java.lang.Override
      public ApplicationInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ApplicationInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ApplicationInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InputOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Input)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     * @return The type.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType getType();

    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     * @return The id.
     */
    long getId();

    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     * @return The key.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey();
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder getKeyOrBuilder();

    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     * @return Whether the command field is set.
     */
    boolean hasCommand();
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     * @return The command.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getCommand();
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder getCommandOrBuilder();

    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     * @return Whether the config field is set.
     */
    boolean hasConfig();
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     * @return The config.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig();
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder getConfigOrBuilder();

    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     * @return Whether the context field is set.
     */
    boolean hasContext();
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     * @return The context.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getContext();
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ContextOrBuilder getContextOrBuilder();

    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     * @return Whether the capability field is set.
     */
    boolean hasCapability();
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     * @return The capability.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getCapability();
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CapabilityOrBuilder getCapabilityOrBuilder();

    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     * @return Whether the applicationInfo field is set.
     */
    boolean hasApplicationInfo();
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     * @return The applicationInfo.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getApplicationInfo();
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfoOrBuilder getApplicationInfoOrBuilder();

    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     * @return Whether the request field is set.
     */
    boolean hasRequest();
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     * @return The request.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getRequest();
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.RequestOrBuilder getRequestOrBuilder();

    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> 
        getTouchEventsList();
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getTouchEvents(int index);
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    int getTouchEventsCount();
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder> 
        getTouchEventsOrBuilderList();
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder getTouchEventsOrBuilder(
        int index);

    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
     * @return Whether the userDictionaryCommand field is set.
     */
    boolean hasUserDictionaryCommand();
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
     * @return The userDictionaryCommand.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand getUserDictionaryCommand();
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandOrBuilder getUserDictionaryCommandOrBuilder();

    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     * @return Whether the requestSuggestion field is set.
     */
    boolean hasRequestSuggestion();
    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     * @return The requestSuggestion.
     */
    boolean getRequestSuggestion();

    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     * @return Whether the engineReloadRequest field is set.
     */
    boolean hasEngineReloadRequest();
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     * @return The engineReloadRequest.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest getEngineReloadRequest();
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequestOrBuilder getEngineReloadRequestOrBuilder();
  }
  /**
   * Protobuf type {@code mozc.commands.Input}
   */
  public static final class Input extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Input)
      InputOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Input.newBuilder() to construct.
    private Input(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Input() {
      type_ = 0;
      touchEvents_ = java.util.Collections.emptyList();
      requestSuggestion_ = true;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Input();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.Builder.class);
    }

    /**
     * Protobuf enum {@code mozc.commands.Input.CommandType}
     */
    public enum CommandType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NONE = 0;</code>
       */
      NONE(0),
      /**
       * <code>CREATE_SESSION = 1;</code>
       */
      CREATE_SESSION(1),
      /**
       * <code>DELETE_SESSION = 2;</code>
       */
      DELETE_SESSION(2),
      /**
       * <code>SEND_KEY = 3;</code>
       */
      SEND_KEY(3),
      /**
       * <pre>
       * Check only if the key event will be consumed.  This command is
       * for TSF on Windows.  You do not need to use this command, if it
       * is not necessary.
       * </pre>
       *
       * <code>TEST_SEND_KEY = 4;</code>
       */
      TEST_SEND_KEY(4),
      /**
       * <pre>
       * Evaluate the command specified by SessionCommand.  The output
       * format should be the same with an output of a SEND_KEY command.
       * </pre>
       *
       * <code>SEND_COMMAND = 5;</code>
       */
      SEND_COMMAND(5),
      /**
       * <pre>
       * Config accessors.
       * </pre>
       *
       * <code>GET_CONFIG = 6;</code>
       */
      GET_CONFIG(6),
      /**
       * <code>SET_CONFIG = 7;</code>
       */
      SET_CONFIG(7),
      /**
       * <pre>
       * Set client's request
       * </pre>
       *
       * <code>SET_REQUEST = 17;</code>
       */
      SET_REQUEST(17),
      /**
       * <pre>
       * sync dictionary/history data to local file
       * </pre>
       *
       * <code>SYNC_DATA = 8;</code>
       */
      SYNC_DATA(8),
      /**
       * <pre>
       * shutdowon server safely
       * </pre>
       *
       * <code>SHUTDOWN = 9;</code>
       */
      SHUTDOWN(9),
      /**
       * <pre>
       * reload mutable data (like config, user-dic, history)
       * </pre>
       *
       * <code>RELOAD = 10;</code>
       */
      RELOAD(10),
      /**
       * <pre>
       * realod mutable data and wait for finish
       * Note: Reloading of user dictionary data is async so that
       * it will not block the typing.
       * This command wait for the reloader.
       * </pre>
       *
       * <code>RELOAD_AND_WAIT = 15;</code>
       */
      RELOAD_AND_WAIT(15),
      /**
       * <pre>
       * clear user history data
       * </pre>
       *
       * <code>CLEAR_USER_HISTORY = 11;</code>
       */
      CLEAR_USER_HISTORY(11),
      /**
       * <pre>
       * clear user prediction data
       * </pre>
       *
       * <code>CLEAR_USER_PREDICTION = 12;</code>
       */
      CLEAR_USER_PREDICTION(12),
      /**
       * <pre>
       * clear unused prediction
       * </pre>
       *
       * <code>CLEAR_UNUSED_USER_PREDICTION = 16;</code>
       */
      CLEAR_UNUSED_USER_PREDICTION(16),
      /**
       * <pre>
       * clean up sessions
       * shutdwon if session is empty and
       * mozc_server is launched with timeout mode
       * </pre>
       *
       * <code>CLEANUP = 13;</code>
       */
      CLEANUP(13),
      /**
       * <pre>
       * no operation
       * can be used for pinging the server
       * </pre>
       *
       * <code>NO_OPERATION = 14;</code>
       */
      NO_OPERATION(14),
      /**
       * <pre>
       * Send a command for user dictionary session.
       * </pre>
       *
       * <code>SEND_USER_DICTIONARY_COMMAND = 26;</code>
       */
      SEND_USER_DICTIONARY_COMMAND(26),
      /**
       * <pre>
       * Send an engine_reload_request (ID: 15) to reload the engine.
       * </pre>
       *
       * <code>SEND_ENGINE_RELOAD_REQUEST = 27;</code>
       */
      SEND_ENGINE_RELOAD_REQUEST(27),
      /**
       * <pre>
       * Sends reload supplemental model
       * </pre>
       *
       * <code>RELOAD_SUPPLEMENTAL_MODEL = 30;</code>
       */
      RELOAD_SUPPLEMENTAL_MODEL(30),
      /**
       * <code>GET_SERVER_VERSION = 19;</code>
       */
      GET_SERVER_VERSION(19),
      /**
       * <pre>
       * Number of commands.
       * When new command is added, the command should use below number
       * and NUM_OF_COMMANDS should be incremented.
       * </pre>
       *
       * <code>NUM_OF_COMMANDS = 31;</code>
       */
      NUM_OF_COMMANDS(31),
      ;

      /**
       * <code>NONE = 0;</code>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <code>CREATE_SESSION = 1;</code>
       */
      public static final int CREATE_SESSION_VALUE = 1;
      /**
       * <code>DELETE_SESSION = 2;</code>
       */
      public static final int DELETE_SESSION_VALUE = 2;
      /**
       * <code>SEND_KEY = 3;</code>
       */
      public static final int SEND_KEY_VALUE = 3;
      /**
       * <pre>
       * Check only if the key event will be consumed.  This command is
       * for TSF on Windows.  You do not need to use this command, if it
       * is not necessary.
       * </pre>
       *
       * <code>TEST_SEND_KEY = 4;</code>
       */
      public static final int TEST_SEND_KEY_VALUE = 4;
      /**
       * <pre>
       * Evaluate the command specified by SessionCommand.  The output
       * format should be the same with an output of a SEND_KEY command.
       * </pre>
       *
       * <code>SEND_COMMAND = 5;</code>
       */
      public static final int SEND_COMMAND_VALUE = 5;
      /**
       * <pre>
       * Config accessors.
       * </pre>
       *
       * <code>GET_CONFIG = 6;</code>
       */
      public static final int GET_CONFIG_VALUE = 6;
      /**
       * <code>SET_CONFIG = 7;</code>
       */
      public static final int SET_CONFIG_VALUE = 7;
      /**
       * <pre>
       * Set client's request
       * </pre>
       *
       * <code>SET_REQUEST = 17;</code>
       */
      public static final int SET_REQUEST_VALUE = 17;
      /**
       * <pre>
       * sync dictionary/history data to local file
       * </pre>
       *
       * <code>SYNC_DATA = 8;</code>
       */
      public static final int SYNC_DATA_VALUE = 8;
      /**
       * <pre>
       * shutdowon server safely
       * </pre>
       *
       * <code>SHUTDOWN = 9;</code>
       */
      public static final int SHUTDOWN_VALUE = 9;
      /**
       * <pre>
       * reload mutable data (like config, user-dic, history)
       * </pre>
       *
       * <code>RELOAD = 10;</code>
       */
      public static final int RELOAD_VALUE = 10;
      /**
       * <pre>
       * realod mutable data and wait for finish
       * Note: Reloading of user dictionary data is async so that
       * it will not block the typing.
       * This command wait for the reloader.
       * </pre>
       *
       * <code>RELOAD_AND_WAIT = 15;</code>
       */
      public static final int RELOAD_AND_WAIT_VALUE = 15;
      /**
       * <pre>
       * clear user history data
       * </pre>
       *
       * <code>CLEAR_USER_HISTORY = 11;</code>
       */
      public static final int CLEAR_USER_HISTORY_VALUE = 11;
      /**
       * <pre>
       * clear user prediction data
       * </pre>
       *
       * <code>CLEAR_USER_PREDICTION = 12;</code>
       */
      public static final int CLEAR_USER_PREDICTION_VALUE = 12;
      /**
       * <pre>
       * clear unused prediction
       * </pre>
       *
       * <code>CLEAR_UNUSED_USER_PREDICTION = 16;</code>
       */
      public static final int CLEAR_UNUSED_USER_PREDICTION_VALUE = 16;
      /**
       * <pre>
       * clean up sessions
       * shutdwon if session is empty and
       * mozc_server is launched with timeout mode
       * </pre>
       *
       * <code>CLEANUP = 13;</code>
       */
      public static final int CLEANUP_VALUE = 13;
      /**
       * <pre>
       * no operation
       * can be used for pinging the server
       * </pre>
       *
       * <code>NO_OPERATION = 14;</code>
       */
      public static final int NO_OPERATION_VALUE = 14;
      /**
       * <pre>
       * Send a command for user dictionary session.
       * </pre>
       *
       * <code>SEND_USER_DICTIONARY_COMMAND = 26;</code>
       */
      public static final int SEND_USER_DICTIONARY_COMMAND_VALUE = 26;
      /**
       * <pre>
       * Send an engine_reload_request (ID: 15) to reload the engine.
       * </pre>
       *
       * <code>SEND_ENGINE_RELOAD_REQUEST = 27;</code>
       */
      public static final int SEND_ENGINE_RELOAD_REQUEST_VALUE = 27;
      /**
       * <pre>
       * Sends reload supplemental model
       * </pre>
       *
       * <code>RELOAD_SUPPLEMENTAL_MODEL = 30;</code>
       */
      public static final int RELOAD_SUPPLEMENTAL_MODEL_VALUE = 30;
      /**
       * <code>GET_SERVER_VERSION = 19;</code>
       */
      public static final int GET_SERVER_VERSION_VALUE = 19;
      /**
       * <pre>
       * Number of commands.
       * When new command is added, the command should use below number
       * and NUM_OF_COMMANDS should be incremented.
       * </pre>
       *
       * <code>NUM_OF_COMMANDS = 31;</code>
       */
      public static final int NUM_OF_COMMANDS_VALUE = 31;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CommandType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static CommandType forNumber(int value) {
        switch (value) {
          case 0: return NONE;
          case 1: return CREATE_SESSION;
          case 2: return DELETE_SESSION;
          case 3: return SEND_KEY;
          case 4: return TEST_SEND_KEY;
          case 5: return SEND_COMMAND;
          case 6: return GET_CONFIG;
          case 7: return SET_CONFIG;
          case 17: return SET_REQUEST;
          case 8: return SYNC_DATA;
          case 9: return SHUTDOWN;
          case 10: return RELOAD;
          case 15: return RELOAD_AND_WAIT;
          case 11: return CLEAR_USER_HISTORY;
          case 12: return CLEAR_USER_PREDICTION;
          case 16: return CLEAR_UNUSED_USER_PREDICTION;
          case 13: return CLEANUP;
          case 14: return NO_OPERATION;
          case 26: return SEND_USER_DICTIONARY_COMMAND;
          case 27: return SEND_ENGINE_RELOAD_REQUEST;
          case 30: return RELOAD_SUPPLEMENTAL_MODEL;
          case 19: return GET_SERVER_VERSION;
          case 31: return NUM_OF_COMMANDS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CommandType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CommandType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CommandType>() {
              public CommandType findValueByNumber(int number) {
                return CommandType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDescriptor().getEnumTypes().get(0);
      }

      private static final CommandType[] VALUES = values();

      public static CommandType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private CommandType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Input.CommandType)
    }

    /**
     * Protobuf enum {@code mozc.commands.Input.TouchAction}
     */
    public enum TouchAction
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>TOUCH_DOWN = 1;</code>
       */
      TOUCH_DOWN(1),
      /**
       * <code>TOUCH_MOVE = 2;</code>
       */
      TOUCH_MOVE(2),
      /**
       * <code>TOUCH_UP = 3;</code>
       */
      TOUCH_UP(3),
      ;

      /**
       * <code>TOUCH_DOWN = 1;</code>
       */
      public static final int TOUCH_DOWN_VALUE = 1;
      /**
       * <code>TOUCH_MOVE = 2;</code>
       */
      public static final int TOUCH_MOVE_VALUE = 2;
      /**
       * <code>TOUCH_UP = 3;</code>
       */
      public static final int TOUCH_UP_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TouchAction valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static TouchAction forNumber(int value) {
        switch (value) {
          case 1: return TOUCH_DOWN;
          case 2: return TOUCH_MOVE;
          case 3: return TOUCH_UP;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<TouchAction>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          TouchAction> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<TouchAction>() {
              public TouchAction findValueByNumber(int number) {
                return TouchAction.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDescriptor().getEnumTypes().get(1);
      }

      private static final TouchAction[] VALUES = values();

      public static TouchAction valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private TouchAction(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Input.TouchAction)
    }

    public interface TouchPositionOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Input.TouchPosition)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       * @return Whether the action field is set.
       */
      boolean hasAction();
      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       * @return The action.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction getAction();

      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       * @return Whether the x field is set.
       */
      boolean hasX();
      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       * @return The x.
       */
      float getX();

      /**
       * <code>optional float y = 3;</code>
       * @return Whether the y field is set.
       */
      boolean hasY();
      /**
       * <code>optional float y = 3;</code>
       * @return The y.
       */
      float getY();

      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       * @return Whether the timestamp field is set.
       */
      boolean hasTimestamp();
      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       * @return The timestamp.
       */
      long getTimestamp();
    }
    /**
     * Protobuf type {@code mozc.commands.Input.TouchPosition}
     */
    public static final class TouchPosition extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Input.TouchPosition)
        TouchPositionOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use TouchPosition.newBuilder() to construct.
      private TouchPosition(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private TouchPosition() {
        action_ = 1;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new TouchPosition();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchPosition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchPosition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder.class);
      }

      private int bitField0_;
      public static final int ACTION_FIELD_NUMBER = 1;
      private int action_ = 1;
      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       * @return Whether the action field is set.
       */
      @java.lang.Override public boolean hasAction() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
       * @return The action.
       */
      @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction getAction() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction.forNumber(action_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction.TOUCH_DOWN : result;
      }

      public static final int X_FIELD_NUMBER = 2;
      private float x_ = 0F;
      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       * @return Whether the x field is set.
       */
      @java.lang.Override
      public boolean hasX() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
       * </pre>
       *
       * <code>optional float x = 2;</code>
       * @return The x.
       */
      @java.lang.Override
      public float getX() {
        return x_;
      }

      public static final int Y_FIELD_NUMBER = 3;
      private float y_ = 0F;
      /**
       * <code>optional float y = 3;</code>
       * @return Whether the y field is set.
       */
      @java.lang.Override
      public boolean hasY() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional float y = 3;</code>
       * @return The y.
       */
      @java.lang.Override
      public float getY() {
        return y_;
      }

      public static final int TIMESTAMP_FIELD_NUMBER = 4;
      private long timestamp_ = 0L;
      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       * @return Whether the timestamp field is set.
       */
      @java.lang.Override
      public boolean hasTimestamp() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * timestamp (in ms) is set to zero when the touch event starts.
       * </pre>
       *
       * <code>optional int64 timestamp = 4;</code>
       * @return The timestamp.
       */
      @java.lang.Override
      public long getTimestamp() {
        return timestamp_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeEnum(1, action_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeFloat(2, x_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeFloat(3, y_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeInt64(4, timestamp_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, action_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(2, x_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(3, y_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(4, timestamp_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition) obj;

        if (hasAction() != other.hasAction()) return false;
        if (hasAction()) {
          if (action_ != other.action_) return false;
        }
        if (hasX() != other.hasX()) return false;
        if (hasX()) {
          if (java.lang.Float.floatToIntBits(getX())
              != java.lang.Float.floatToIntBits(
                  other.getX())) return false;
        }
        if (hasY() != other.hasY()) return false;
        if (hasY()) {
          if (java.lang.Float.floatToIntBits(getY())
              != java.lang.Float.floatToIntBits(
                  other.getY())) return false;
        }
        if (hasTimestamp() != other.hasTimestamp()) return false;
        if (hasTimestamp()) {
          if (getTimestamp()
              != other.getTimestamp()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasAction()) {
          hash = (37 * hash) + ACTION_FIELD_NUMBER;
          hash = (53 * hash) + action_;
        }
        if (hasX()) {
          hash = (37 * hash) + X_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getX());
        }
        if (hasY()) {
          hash = (37 * hash) + Y_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getY());
        }
        if (hasTimestamp()) {
          hash = (37 * hash) + TIMESTAMP_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getTimestamp());
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code mozc.commands.Input.TouchPosition}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Input.TouchPosition)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchPosition_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchPosition_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          action_ = 1;
          x_ = 0F;
          y_ = 0F;
          timestamp_ = 0L;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchPosition_descriptor;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.getDefaultInstance();
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.action_ = action_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.x_ = x_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.y_ = y_;
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.timestamp_ = timestamp_;
            to_bitField0_ |= 0x00000008;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.getDefaultInstance()) return this;
          if (other.hasAction()) {
            setAction(other.getAction());
          }
          if (other.hasX()) {
            setX(other.getX());
          }
          if (other.hasY()) {
            setY(other.getY());
          }
          if (other.hasTimestamp()) {
            setTimestamp(other.getTimestamp());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  int tmpRaw = input.readEnum();
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction tmpValue =
                      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(1, tmpRaw);
                  } else {
                    action_ = tmpRaw;
                    bitField0_ |= 0x00000001;
                  }
                  break;
                } // case 8
                case 21: {
                  x_ = input.readFloat();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 21
                case 29: {
                  y_ = input.readFloat();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 29
                case 32: {
                  timestamp_ = input.readInt64();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int action_ = 1;
        /**
         * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
         * @return Whether the action field is set.
         */
        @java.lang.Override public boolean hasAction() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
         * @return The action.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction getAction() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction.forNumber(action_);
          return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction.TOUCH_DOWN : result;
        }
        /**
         * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
         * @param value The action to set.
         * @return This builder for chaining.
         */
        public Builder setAction(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchAction value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000001;
          action_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>optional .mozc.commands.Input.TouchAction action = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearAction() {
          bitField0_ = (bitField0_ & ~0x00000001);
          action_ = 1;
          onChanged();
          return this;
        }

        private float x_ ;
        /**
         * <pre>
         * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
         * </pre>
         *
         * <code>optional float x = 2;</code>
         * @return Whether the x field is set.
         */
        @java.lang.Override
        public boolean hasX() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
         * </pre>
         *
         * <code>optional float x = 2;</code>
         * @return The x.
         */
        @java.lang.Override
        public float getX() {
          return x_;
        }
        /**
         * <pre>
         * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
         * </pre>
         *
         * <code>optional float x = 2;</code>
         * @param value The x to set.
         * @return This builder for chaining.
         */
        public Builder setX(float value) {
          
          x_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
         * </pre>
         *
         * <code>optional float x = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearX() {
          bitField0_ = (bitField0_ & ~0x00000002);
          x_ = 0F;
          onChanged();
          return this;
        }

        private float y_ ;
        /**
         * <code>optional float y = 3;</code>
         * @return Whether the y field is set.
         */
        @java.lang.Override
        public boolean hasY() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <code>optional float y = 3;</code>
         * @return The y.
         */
        @java.lang.Override
        public float getY() {
          return y_;
        }
        /**
         * <code>optional float y = 3;</code>
         * @param value The y to set.
         * @return This builder for chaining.
         */
        public Builder setY(float value) {
          
          y_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <code>optional float y = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearY() {
          bitField0_ = (bitField0_ & ~0x00000004);
          y_ = 0F;
          onChanged();
          return this;
        }

        private long timestamp_ ;
        /**
         * <pre>
         * timestamp (in ms) is set to zero when the touch event starts.
         * </pre>
         *
         * <code>optional int64 timestamp = 4;</code>
         * @return Whether the timestamp field is set.
         */
        @java.lang.Override
        public boolean hasTimestamp() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * timestamp (in ms) is set to zero when the touch event starts.
         * </pre>
         *
         * <code>optional int64 timestamp = 4;</code>
         * @return The timestamp.
         */
        @java.lang.Override
        public long getTimestamp() {
          return timestamp_;
        }
        /**
         * <pre>
         * timestamp (in ms) is set to zero when the touch event starts.
         * </pre>
         *
         * <code>optional int64 timestamp = 4;</code>
         * @param value The timestamp to set.
         * @return This builder for chaining.
         */
        public Builder setTimestamp(long value) {
          
          timestamp_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * timestamp (in ms) is set to zero when the touch event starts.
         * </pre>
         *
         * <code>optional int64 timestamp = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearTimestamp() {
          bitField0_ = (bitField0_ & ~0x00000008);
          timestamp_ = 0L;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.commands.Input.TouchPosition)
      }

      // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchPosition)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<TouchPosition>
          PARSER = new com.google.protobuf.AbstractParser<TouchPosition>() {
        @java.lang.Override
        public TouchPosition parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<TouchPosition> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<TouchPosition> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface TouchEventOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Input.TouchEvent)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       * @return Whether the sourceId field is set.
       */
      boolean hasSourceId();
      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       * @return The sourceId.
       */
      int getSourceId();

      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> 
          getStrokeList();
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getStroke(int index);
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      int getStrokeCount();
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder> 
          getStrokeOrBuilderList();
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder getStrokeOrBuilder(
          int index);
    }
    /**
     * <pre>
     * TouchEvent contains source_id and stroke.
     * Touch_events contain all key touch event.
     * Statistical information are collected for each source_id
     * by SessionUsageObserver.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Input.TouchEvent}
     */
    public static final class TouchEvent extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Input.TouchEvent)
        TouchEventOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use TouchEvent.newBuilder() to construct.
      private TouchEvent(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private TouchEvent() {
        stroke_ = java.util.Collections.emptyList();
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new TouchEvent();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchEvent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchEvent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder.class);
      }

      private int bitField0_;
      public static final int SOURCE_ID_FIELD_NUMBER = 1;
      private int sourceId_ = 0;
      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       * @return Whether the sourceId field is set.
       */
      @java.lang.Override
      public boolean hasSourceId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * source_id specifies the user action such as "X button pressed".
       * It must be unique within the same keyboard_name,
       * which is set in Request message.
       * </pre>
       *
       * <code>optional uint32 source_id = 1;</code>
       * @return The sourceId.
       */
      @java.lang.Override
      public int getSourceId() {
        return sourceId_;
      }

      public static final int STROKE_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> stroke_;
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      @java.lang.Override
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> getStrokeList() {
        return stroke_;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      @java.lang.Override
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder> 
          getStrokeOrBuilderList() {
        return stroke_;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      @java.lang.Override
      public int getStrokeCount() {
        return stroke_.size();
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getStroke(int index) {
        return stroke_.get(index);
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder getStrokeOrBuilder(
          int index) {
        return stroke_.get(index);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeUInt32(1, sourceId_);
        }
        for (int i = 0; i < stroke_.size(); i++) {
          output.writeMessage(2, stroke_.get(i));
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, sourceId_);
        }
        for (int i = 0; i < stroke_.size(); i++) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, stroke_.get(i));
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent) obj;

        if (hasSourceId() != other.hasSourceId()) return false;
        if (hasSourceId()) {
          if (getSourceId()
              != other.getSourceId()) return false;
        }
        if (!getStrokeList()
            .equals(other.getStrokeList())) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasSourceId()) {
          hash = (37 * hash) + SOURCE_ID_FIELD_NUMBER;
          hash = (53 * hash) + getSourceId();
        }
        if (getStrokeCount() > 0) {
          hash = (37 * hash) + STROKE_FIELD_NUMBER;
          hash = (53 * hash) + getStrokeList().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * TouchEvent contains source_id and stroke.
       * Touch_events contain all key touch event.
       * Statistical information are collected for each source_id
       * by SessionUsageObserver.
       * </pre>
       *
       * Protobuf type {@code mozc.commands.Input.TouchEvent}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Input.TouchEvent)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchEvent_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchEvent_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          sourceId_ = 0;
          if (strokeBuilder_ == null) {
            stroke_ = java.util.Collections.emptyList();
          } else {
            stroke_ = null;
            strokeBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000002);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_TouchEvent_descriptor;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.getDefaultInstance();
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent(this);
          buildPartialRepeatedFields(result);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent result) {
          if (strokeBuilder_ == null) {
            if (((bitField0_ & 0x00000002) != 0)) {
              stroke_ = java.util.Collections.unmodifiableList(stroke_);
              bitField0_ = (bitField0_ & ~0x00000002);
            }
            result.stroke_ = stroke_;
          } else {
            result.stroke_ = strokeBuilder_.build();
          }
        }

        private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.sourceId_ = sourceId_;
            to_bitField0_ |= 0x00000001;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.getDefaultInstance()) return this;
          if (other.hasSourceId()) {
            setSourceId(other.getSourceId());
          }
          if (strokeBuilder_ == null) {
            if (!other.stroke_.isEmpty()) {
              if (stroke_.isEmpty()) {
                stroke_ = other.stroke_;
                bitField0_ = (bitField0_ & ~0x00000002);
              } else {
                ensureStrokeIsMutable();
                stroke_.addAll(other.stroke_);
              }
              onChanged();
            }
          } else {
            if (!other.stroke_.isEmpty()) {
              if (strokeBuilder_.isEmpty()) {
                strokeBuilder_.dispose();
                strokeBuilder_ = null;
                stroke_ = other.stroke_;
                bitField0_ = (bitField0_ & ~0x00000002);
                strokeBuilder_ = 
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                     getStrokeFieldBuilder() : null;
              } else {
                strokeBuilder_.addAllMessages(other.stroke_);
              }
            }
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  sourceId_ = input.readUInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 18: {
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition m =
                      input.readMessage(
                          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.PARSER,
                          extensionRegistry);
                  if (strokeBuilder_ == null) {
                    ensureStrokeIsMutable();
                    stroke_.add(m);
                  } else {
                    strokeBuilder_.addMessage(m);
                  }
                  break;
                } // case 18
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int sourceId_ ;
        /**
         * <pre>
         * source_id specifies the user action such as "X button pressed".
         * It must be unique within the same keyboard_name,
         * which is set in Request message.
         * </pre>
         *
         * <code>optional uint32 source_id = 1;</code>
         * @return Whether the sourceId field is set.
         */
        @java.lang.Override
        public boolean hasSourceId() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * source_id specifies the user action such as "X button pressed".
         * It must be unique within the same keyboard_name,
         * which is set in Request message.
         * </pre>
         *
         * <code>optional uint32 source_id = 1;</code>
         * @return The sourceId.
         */
        @java.lang.Override
        public int getSourceId() {
          return sourceId_;
        }
        /**
         * <pre>
         * source_id specifies the user action such as "X button pressed".
         * It must be unique within the same keyboard_name,
         * which is set in Request message.
         * </pre>
         *
         * <code>optional uint32 source_id = 1;</code>
         * @param value The sourceId to set.
         * @return This builder for chaining.
         */
        public Builder setSourceId(int value) {
          
          sourceId_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * source_id specifies the user action such as "X button pressed".
         * It must be unique within the same keyboard_name,
         * which is set in Request message.
         * </pre>
         *
         * <code>optional uint32 source_id = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearSourceId() {
          bitField0_ = (bitField0_ & ~0x00000001);
          sourceId_ = 0;
          onChanged();
          return this;
        }

        private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> stroke_ =
          java.util.Collections.emptyList();
        private void ensureStrokeIsMutable() {
          if (!((bitField0_ & 0x00000002) != 0)) {
            stroke_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition>(stroke_);
            bitField0_ |= 0x00000002;
           }
        }

        private com.google.protobuf.RepeatedFieldBuilderV3<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder> strokeBuilder_;

        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> getStrokeList() {
          if (strokeBuilder_ == null) {
            return java.util.Collections.unmodifiableList(stroke_);
          } else {
            return strokeBuilder_.getMessageList();
          }
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public int getStrokeCount() {
          if (strokeBuilder_ == null) {
            return stroke_.size();
          } else {
            return strokeBuilder_.getCount();
          }
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition getStroke(int index) {
          if (strokeBuilder_ == null) {
            return stroke_.get(index);
          } else {
            return strokeBuilder_.getMessage(index);
          }
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder setStroke(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition value) {
          if (strokeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureStrokeIsMutable();
            stroke_.set(index, value);
            onChanged();
          } else {
            strokeBuilder_.setMessage(index, value);
          }
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder setStroke(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder builderForValue) {
          if (strokeBuilder_ == null) {
            ensureStrokeIsMutable();
            stroke_.set(index, builderForValue.build());
            onChanged();
          } else {
            strokeBuilder_.setMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addStroke(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition value) {
          if (strokeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureStrokeIsMutable();
            stroke_.add(value);
            onChanged();
          } else {
            strokeBuilder_.addMessage(value);
          }
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addStroke(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition value) {
          if (strokeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureStrokeIsMutable();
            stroke_.add(index, value);
            onChanged();
          } else {
            strokeBuilder_.addMessage(index, value);
          }
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addStroke(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder builderForValue) {
          if (strokeBuilder_ == null) {
            ensureStrokeIsMutable();
            stroke_.add(builderForValue.build());
            onChanged();
          } else {
            strokeBuilder_.addMessage(builderForValue.build());
          }
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addStroke(
            int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder builderForValue) {
          if (strokeBuilder_ == null) {
            ensureStrokeIsMutable();
            stroke_.add(index, builderForValue.build());
            onChanged();
          } else {
            strokeBuilder_.addMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder addAllStroke(
            java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition> values) {
          if (strokeBuilder_ == null) {
            ensureStrokeIsMutable();
            com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, stroke_);
            onChanged();
          } else {
            strokeBuilder_.addAllMessages(values);
          }
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder clearStroke() {
          if (strokeBuilder_ == null) {
            stroke_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000002);
            onChanged();
          } else {
            strokeBuilder_.clear();
          }
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public Builder removeStroke(int index) {
          if (strokeBuilder_ == null) {
            ensureStrokeIsMutable();
            stroke_.remove(index);
            onChanged();
          } else {
            strokeBuilder_.remove(index);
          }
          return this;
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder getStrokeBuilder(
            int index) {
          return getStrokeFieldBuilder().getBuilder(index);
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder getStrokeOrBuilder(
            int index) {
          if (strokeBuilder_ == null) {
            return stroke_.get(index);  } else {
            return strokeBuilder_.getMessageOrBuilder(index);
          }
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder> 
             getStrokeOrBuilderList() {
          if (strokeBuilder_ != null) {
            return strokeBuilder_.getMessageOrBuilderList();
          } else {
            return java.util.Collections.unmodifiableList(stroke_);
          }
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder addStrokeBuilder() {
          return getStrokeFieldBuilder().addBuilder(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.getDefaultInstance());
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder addStrokeBuilder(
            int index) {
          return getStrokeFieldBuilder().addBuilder(
              index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.getDefaultInstance());
        }
        /**
         * <code>repeated .mozc.commands.Input.TouchPosition stroke = 2;</code>
         */
        public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder> 
             getStrokeBuilderList() {
          return getStrokeFieldBuilder().getBuilderList();
        }
        private com.google.protobuf.RepeatedFieldBuilderV3<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder> 
            getStrokeFieldBuilder() {
          if (strokeBuilder_ == null) {
            strokeBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPosition.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchPositionOrBuilder>(
                    stroke_,
                    ((bitField0_ & 0x00000002) != 0),
                    getParentForChildren(),
                    isClean());
            stroke_ = null;
          }
          return strokeBuilder_;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.commands.Input.TouchEvent)
      }

      // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchEvent)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<TouchEvent>
          PARSER = new com.google.protobuf.AbstractParser<TouchEvent>() {
        @java.lang.Override
        public TouchEvent parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<TouchEvent> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<TouchEvent> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 0;
    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .mozc.commands.Input.CommandType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType getType() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType.forNumber(type_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType.NONE : result;
    }

    public static final int ID_FIELD_NUMBER = 2;
    private long id_ = 0L;
    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Session ID created by CREATE_SESSION.
     * </pre>
     *
     * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
     * @return The id.
     */
    @java.lang.Override
    public long getId() {
      return id_;
    }

    public static final int KEY_FIELD_NUMBER = 3;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent key_;
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     * @return The key.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey() {
      return key_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
    }
    /**
     * <pre>
     * Key combinations used for SEND_KEY or TEST_SEND_KEY.
     * </pre>
     *
     * <code>optional .mozc.commands.KeyEvent key = 3;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder getKeyOrBuilder() {
      return key_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
    }

    public static final int COMMAND_FIELD_NUMBER = 4;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand command_;
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     * @return Whether the command field is set.
     */
    @java.lang.Override
    public boolean hasCommand() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     * @return The command.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getCommand() {
      return command_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : command_;
    }
    /**
     * <pre>
     * Command sent to the session layer used with SEND_COMMAND.
     * </pre>
     *
     * <code>optional .mozc.commands.SessionCommand command = 4;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder getCommandOrBuilder() {
      return command_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : command_;
    }

    public static final int CONFIG_FIELD_NUMBER = 5;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config config_;
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     * @return Whether the config field is set.
     */
    @java.lang.Override
    public boolean hasConfig() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     * @return The config.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig() {
      return config_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
    }
    /**
     * <pre>
     * Input config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 5;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder getConfigOrBuilder() {
      return config_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
    }

    public static final int CONTEXT_FIELD_NUMBER = 6;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context context_;
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     * @return Whether the context field is set.
     */
    @java.lang.Override
    public boolean hasContext() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     * @return The context.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getContext() {
      return context_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDefaultInstance() : context_;
    }
    /**
     * <pre>
     * Context data
     * </pre>
     *
     * <code>optional .mozc.commands.Context context = 6;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ContextOrBuilder getContextOrBuilder() {
      return context_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDefaultInstance() : context_;
    }

    public static final int CAPABILITY_FIELD_NUMBER = 7;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability capability_;
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     * @return Whether the capability field is set.
     */
    @java.lang.Override
    public boolean hasCapability() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     * @return The capability.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getCapability() {
      return capability_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDefaultInstance() : capability_;
    }
    /**
     * <pre>
     * Client capability
     * </pre>
     *
     * <code>optional .mozc.commands.Capability capability = 7;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CapabilityOrBuilder getCapabilityOrBuilder() {
      return capability_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDefaultInstance() : capability_;
    }

    public static final int APPLICATION_INFO_FIELD_NUMBER = 8;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo applicationInfo_;
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     * @return Whether the applicationInfo field is set.
     */
    @java.lang.Override
    public boolean hasApplicationInfo() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     * @return The applicationInfo.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getApplicationInfo() {
      return applicationInfo_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.getDefaultInstance() : applicationInfo_;
    }
    /**
     * <pre>
     * Application information, like process id.
     * Server may be able to change the behavior by seeing the
     * the program name.
     * </pre>
     *
     * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfoOrBuilder getApplicationInfoOrBuilder() {
      return applicationInfo_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.getDefaultInstance() : applicationInfo_;
    }

    public static final int REQUEST_FIELD_NUMBER = 9;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request request_;
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     * @return Whether the request field is set.
     */
    @java.lang.Override
    public boolean hasRequest() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     * @return The request.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getRequest() {
      return request_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDefaultInstance() : request_;
    }
    /**
     * <pre>
     * Client request
     * </pre>
     *
     * <code>optional .mozc.commands.Request request = 9;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.RequestOrBuilder getRequestOrBuilder() {
      return request_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDefaultInstance() : request_;
    }

    public static final int TOUCH_EVENTS_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> touchEvents_;
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> getTouchEventsList() {
      return touchEvents_;
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder> 
        getTouchEventsOrBuilderList() {
      return touchEvents_;
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    @java.lang.Override
    public int getTouchEventsCount() {
      return touchEvents_.size();
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getTouchEvents(int index) {
      return touchEvents_.get(index);
    }
    /**
     * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder getTouchEventsOrBuilder(
        int index) {
      return touchEvents_.get(index);
    }

    public static final int USER_DICTIONARY_COMMAND_FIELD_NUMBER = 13;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand userDictionaryCommand_;
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
     * @return Whether the userDictionaryCommand field is set.
     */
    @java.lang.Override
    public boolean hasUserDictionaryCommand() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
     * @return The userDictionaryCommand.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand getUserDictionaryCommand() {
      return userDictionaryCommand_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.getDefaultInstance() : userDictionaryCommand_;
    }
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandOrBuilder getUserDictionaryCommandOrBuilder() {
      return userDictionaryCommand_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.getDefaultInstance() : userDictionaryCommand_;
    }

    public static final int REQUEST_SUGGESTION_FIELD_NUMBER = 14;
    private boolean requestSuggestion_ = true;
    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     * @return Whether the requestSuggestion field is set.
     */
    @java.lang.Override
    public boolean hasRequestSuggestion() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * A flag to control if the server should return suggest-results or not.
     * If this is set to false, regardless of other configurations,
     * the server won't return suggestion results.
     * This is set to true by default.
     * Note that even if this flag is set to false, when a suggestion is shown
     * in the previous phase, it is possible from the client to submit it.
     * This works only for suggestions for the key insertion, but not for
     * others commands, such as predictions or conversions.
     * This flag is used for the performance improvement in terms of the
     * latency.  If you want to suppress the suggestions for the UX improment,
     * you may want to use suppress_suggestion in the Context message.
     * </pre>
     *
     * <code>optional bool request_suggestion = 14 [default = true];</code>
     * @return The requestSuggestion.
     */
    @java.lang.Override
    public boolean getRequestSuggestion() {
      return requestSuggestion_;
    }

    public static final int ENGINE_RELOAD_REQUEST_FIELD_NUMBER = 15;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest engineReloadRequest_;
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     * @return Whether the engineReloadRequest field is set.
     */
    @java.lang.Override
    public boolean hasEngineReloadRequest() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     * @return The engineReloadRequest.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest getEngineReloadRequest() {
      return engineReloadRequest_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.getDefaultInstance() : engineReloadRequest_;
    }
    /**
     * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequestOrBuilder getEngineReloadRequestOrBuilder() {
      return engineReloadRequest_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.getDefaultInstance() : engineReloadRequest_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (hasCommand()) {
        if (!getCommand().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasUserDictionaryCommand()) {
        if (!getUserDictionaryCommand().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasEngineReloadRequest()) {
        if (!getEngineReloadRequest().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, id_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getKey());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getCommand());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(5, getConfig());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(6, getContext());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(7, getCapability());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(8, getApplicationInfo());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(9, getRequest());
      }
      for (int i = 0; i < touchEvents_.size(); i++) {
        output.writeMessage(12, touchEvents_.get(i));
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeMessage(13, getUserDictionaryCommand());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeBool(14, requestSuggestion_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(15, getEngineReloadRequest());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, id_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getKey());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getCommand());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getConfig());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getContext());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getCapability());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getApplicationInfo());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getRequest());
      }
      for (int i = 0; i < touchEvents_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, touchEvents_.get(i));
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, getUserDictionaryCommand());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(14, requestSuggestion_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getEngineReloadRequest());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasId() != other.hasId()) return false;
      if (hasId()) {
        if (getId()
            != other.getId()) return false;
      }
      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (hasCommand() != other.hasCommand()) return false;
      if (hasCommand()) {
        if (!getCommand()
            .equals(other.getCommand())) return false;
      }
      if (hasConfig() != other.hasConfig()) return false;
      if (hasConfig()) {
        if (!getConfig()
            .equals(other.getConfig())) return false;
      }
      if (hasContext() != other.hasContext()) return false;
      if (hasContext()) {
        if (!getContext()
            .equals(other.getContext())) return false;
      }
      if (hasCapability() != other.hasCapability()) return false;
      if (hasCapability()) {
        if (!getCapability()
            .equals(other.getCapability())) return false;
      }
      if (hasApplicationInfo() != other.hasApplicationInfo()) return false;
      if (hasApplicationInfo()) {
        if (!getApplicationInfo()
            .equals(other.getApplicationInfo())) return false;
      }
      if (hasRequest() != other.hasRequest()) return false;
      if (hasRequest()) {
        if (!getRequest()
            .equals(other.getRequest())) return false;
      }
      if (!getTouchEventsList()
          .equals(other.getTouchEventsList())) return false;
      if (hasUserDictionaryCommand() != other.hasUserDictionaryCommand()) return false;
      if (hasUserDictionaryCommand()) {
        if (!getUserDictionaryCommand()
            .equals(other.getUserDictionaryCommand())) return false;
      }
      if (hasRequestSuggestion() != other.hasRequestSuggestion()) return false;
      if (hasRequestSuggestion()) {
        if (getRequestSuggestion()
            != other.getRequestSuggestion()) return false;
      }
      if (hasEngineReloadRequest() != other.hasEngineReloadRequest()) return false;
      if (hasEngineReloadRequest()) {
        if (!getEngineReloadRequest()
            .equals(other.getEngineReloadRequest())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasId()) {
        hash = (37 * hash) + ID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getId());
      }
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasCommand()) {
        hash = (37 * hash) + COMMAND_FIELD_NUMBER;
        hash = (53 * hash) + getCommand().hashCode();
      }
      if (hasConfig()) {
        hash = (37 * hash) + CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getConfig().hashCode();
      }
      if (hasContext()) {
        hash = (37 * hash) + CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + getContext().hashCode();
      }
      if (hasCapability()) {
        hash = (37 * hash) + CAPABILITY_FIELD_NUMBER;
        hash = (53 * hash) + getCapability().hashCode();
      }
      if (hasApplicationInfo()) {
        hash = (37 * hash) + APPLICATION_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getApplicationInfo().hashCode();
      }
      if (hasRequest()) {
        hash = (37 * hash) + REQUEST_FIELD_NUMBER;
        hash = (53 * hash) + getRequest().hashCode();
      }
      if (getTouchEventsCount() > 0) {
        hash = (37 * hash) + TOUCH_EVENTS_FIELD_NUMBER;
        hash = (53 * hash) + getTouchEventsList().hashCode();
      }
      if (hasUserDictionaryCommand()) {
        hash = (37 * hash) + USER_DICTIONARY_COMMAND_FIELD_NUMBER;
        hash = (53 * hash) + getUserDictionaryCommand().hashCode();
      }
      if (hasRequestSuggestion()) {
        hash = (37 * hash) + REQUEST_SUGGESTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRequestSuggestion());
      }
      if (hasEngineReloadRequest()) {
        hash = (37 * hash) + ENGINE_RELOAD_REQUEST_FIELD_NUMBER;
        hash = (53 * hash) + getEngineReloadRequest().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.commands.Input}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Input)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.InputOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getKeyFieldBuilder();
          getCommandFieldBuilder();
          getConfigFieldBuilder();
          getContextFieldBuilder();
          getCapabilityFieldBuilder();
          getApplicationInfoFieldBuilder();
          getRequestFieldBuilder();
          getTouchEventsFieldBuilder();
          getUserDictionaryCommandFieldBuilder();
          getEngineReloadRequestFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 0;
        id_ = 0L;
        key_ = null;
        if (keyBuilder_ != null) {
          keyBuilder_.dispose();
          keyBuilder_ = null;
        }
        command_ = null;
        if (commandBuilder_ != null) {
          commandBuilder_.dispose();
          commandBuilder_ = null;
        }
        config_ = null;
        if (configBuilder_ != null) {
          configBuilder_.dispose();
          configBuilder_ = null;
        }
        context_ = null;
        if (contextBuilder_ != null) {
          contextBuilder_.dispose();
          contextBuilder_ = null;
        }
        capability_ = null;
        if (capabilityBuilder_ != null) {
          capabilityBuilder_.dispose();
          capabilityBuilder_ = null;
        }
        applicationInfo_ = null;
        if (applicationInfoBuilder_ != null) {
          applicationInfoBuilder_.dispose();
          applicationInfoBuilder_ = null;
        }
        request_ = null;
        if (requestBuilder_ != null) {
          requestBuilder_.dispose();
          requestBuilder_ = null;
        }
        if (touchEventsBuilder_ == null) {
          touchEvents_ = java.util.Collections.emptyList();
        } else {
          touchEvents_ = null;
          touchEventsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        userDictionaryCommand_ = null;
        if (userDictionaryCommandBuilder_ != null) {
          userDictionaryCommandBuilder_.dispose();
          userDictionaryCommandBuilder_ = null;
        }
        requestSuggestion_ = true;
        engineReloadRequest_ = null;
        if (engineReloadRequestBuilder_ != null) {
          engineReloadRequestBuilder_.dispose();
          engineReloadRequestBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Input_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input result) {
        if (touchEventsBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0)) {
            touchEvents_ = java.util.Collections.unmodifiableList(touchEvents_);
            bitField0_ = (bitField0_ & ~0x00000200);
          }
          result.touchEvents_ = touchEvents_;
        } else {
          result.touchEvents_ = touchEventsBuilder_.build();
        }
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.id_ = id_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.key_ = keyBuilder_ == null
              ? key_
              : keyBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.command_ = commandBuilder_ == null
              ? command_
              : commandBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.config_ = configBuilder_ == null
              ? config_
              : configBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.context_ = contextBuilder_ == null
              ? context_
              : contextBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.capability_ = capabilityBuilder_ == null
              ? capability_
              : capabilityBuilder_.build();
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.applicationInfo_ = applicationInfoBuilder_ == null
              ? applicationInfo_
              : applicationInfoBuilder_.build();
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.request_ = requestBuilder_ == null
              ? request_
              : requestBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.userDictionaryCommand_ = userDictionaryCommandBuilder_ == null
              ? userDictionaryCommand_
              : userDictionaryCommandBuilder_.build();
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.requestSuggestion_ = requestSuggestion_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.engineReloadRequest_ = engineReloadRequestBuilder_ == null
              ? engineReloadRequest_
              : engineReloadRequestBuilder_.build();
          to_bitField0_ |= 0x00000800;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasId()) {
          setId(other.getId());
        }
        if (other.hasKey()) {
          mergeKey(other.getKey());
        }
        if (other.hasCommand()) {
          mergeCommand(other.getCommand());
        }
        if (other.hasConfig()) {
          mergeConfig(other.getConfig());
        }
        if (other.hasContext()) {
          mergeContext(other.getContext());
        }
        if (other.hasCapability()) {
          mergeCapability(other.getCapability());
        }
        if (other.hasApplicationInfo()) {
          mergeApplicationInfo(other.getApplicationInfo());
        }
        if (other.hasRequest()) {
          mergeRequest(other.getRequest());
        }
        if (touchEventsBuilder_ == null) {
          if (!other.touchEvents_.isEmpty()) {
            if (touchEvents_.isEmpty()) {
              touchEvents_ = other.touchEvents_;
              bitField0_ = (bitField0_ & ~0x00000200);
            } else {
              ensureTouchEventsIsMutable();
              touchEvents_.addAll(other.touchEvents_);
            }
            onChanged();
          }
        } else {
          if (!other.touchEvents_.isEmpty()) {
            if (touchEventsBuilder_.isEmpty()) {
              touchEventsBuilder_.dispose();
              touchEventsBuilder_ = null;
              touchEvents_ = other.touchEvents_;
              bitField0_ = (bitField0_ & ~0x00000200);
              touchEventsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTouchEventsFieldBuilder() : null;
            } else {
              touchEventsBuilder_.addAllMessages(other.touchEvents_);
            }
          }
        }
        if (other.hasUserDictionaryCommand()) {
          mergeUserDictionaryCommand(other.getUserDictionaryCommand());
        }
        if (other.hasRequestSuggestion()) {
          setRequestSuggestion(other.getRequestSuggestion());
        }
        if (other.hasEngineReloadRequest()) {
          mergeEngineReloadRequest(other.getEngineReloadRequest());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasType()) {
          return false;
        }
        if (hasCommand()) {
          if (!getCommand().isInitialized()) {
            return false;
          }
        }
        if (hasUserDictionaryCommand()) {
          if (!getUserDictionaryCommand().isInitialized()) {
            return false;
          }
        }
        if (hasEngineReloadRequest()) {
          if (!getEngineReloadRequest().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  type_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 16: {
                id_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                input.readMessage(
                    getKeyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getCommandFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    getContextFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    getCapabilityFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 66: {
                input.readMessage(
                    getApplicationInfoFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              case 74: {
                input.readMessage(
                    getRequestFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 74
              case 98: {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent m =
                    input.readMessage(
                        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.PARSER,
                        extensionRegistry);
                if (touchEventsBuilder_ == null) {
                  ensureTouchEventsIsMutable();
                  touchEvents_.add(m);
                } else {
                  touchEventsBuilder_.addMessage(m);
                }
                break;
              } // case 98
              case 106: {
                input.readMessage(
                    getUserDictionaryCommandFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000400;
                break;
              } // case 106
              case 112: {
                requestSuggestion_ = input.readBool();
                bitField0_ |= 0x00000800;
                break;
              } // case 112
              case 122: {
                input.readMessage(
                    getEngineReloadRequestFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00001000;
                break;
              } // case 122
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int type_ = 0;
      /**
       * <code>required .mozc.commands.Input.CommandType type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .mozc.commands.Input.CommandType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType getType() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType.forNumber(type_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType.NONE : result;
      }
      /**
       * <code>required .mozc.commands.Input.CommandType type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.CommandType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .mozc.commands.Input.CommandType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private long id_ ;
      /**
       * <pre>
       * Session ID created by CREATE_SESSION.
       * </pre>
       *
       * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
       * @return Whether the id field is set.
       */
      @java.lang.Override
      public boolean hasId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Session ID created by CREATE_SESSION.
       * </pre>
       *
       * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
       * @return The id.
       */
      @java.lang.Override
      public long getId() {
        return id_;
      }
      /**
       * <pre>
       * Session ID created by CREATE_SESSION.
       * </pre>
       *
       * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(long value) {
        
        id_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Session ID created by CREATE_SESSION.
       * </pre>
       *
       * <code>optional uint64 id = 2 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        bitField0_ = (bitField0_ & ~0x00000002);
        id_ = 0L;
        onChanged();
        return this;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent key_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder> keyBuilder_;
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       * @return Whether the key field is set.
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       * @return The key.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey() {
        if (keyBuilder_ == null) {
          return key_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
        } else {
          return keyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public Builder setKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
        if (keyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          key_ = value;
        } else {
          keyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public Builder setKey(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder builderForValue) {
        if (keyBuilder_ == null) {
          key_ = builderForValue.build();
        } else {
          keyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public Builder mergeKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
        if (keyBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            key_ != null &&
            key_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance()) {
            getKeyBuilder().mergeFrom(value);
          } else {
            key_ = value;
          }
        } else {
          keyBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000004);
        key_ = null;
        if (keyBuilder_ != null) {
          keyBuilder_.dispose();
          keyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder getKeyBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getKeyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder getKeyOrBuilder() {
        if (keyBuilder_ != null) {
          return keyBuilder_.getMessageOrBuilder();
        } else {
          return key_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
        }
      }
      /**
       * <pre>
       * Key combinations used for SEND_KEY or TEST_SEND_KEY.
       * </pre>
       *
       * <code>optional .mozc.commands.KeyEvent key = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder> 
          getKeyFieldBuilder() {
        if (keyBuilder_ == null) {
          keyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder>(
                  getKey(),
                  getParentForChildren(),
                  isClean());
          key_ = null;
        }
        return keyBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand command_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder> commandBuilder_;
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       * @return Whether the command field is set.
       */
      public boolean hasCommand() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       * @return The command.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getCommand() {
        if (commandBuilder_ == null) {
          return command_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : command_;
        } else {
          return commandBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public Builder setCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
        if (commandBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          command_ = value;
        } else {
          commandBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public Builder setCommand(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder builderForValue) {
        if (commandBuilder_ == null) {
          command_ = builderForValue.build();
        } else {
          commandBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public Builder mergeCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
        if (commandBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            command_ != null &&
            command_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance()) {
            getCommandBuilder().mergeFrom(value);
          } else {
            command_ = value;
          }
        } else {
          commandBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public Builder clearCommand() {
        bitField0_ = (bitField0_ & ~0x00000008);
        command_ = null;
        if (commandBuilder_ != null) {
          commandBuilder_.dispose();
          commandBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder getCommandBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getCommandFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder getCommandOrBuilder() {
        if (commandBuilder_ != null) {
          return commandBuilder_.getMessageOrBuilder();
        } else {
          return command_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : command_;
        }
      }
      /**
       * <pre>
       * Command sent to the session layer used with SEND_COMMAND.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand command = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder> 
          getCommandFieldBuilder() {
        if (commandBuilder_ == null) {
          commandBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder>(
                  getCommand(),
                  getParentForChildren(),
                  isClean());
          command_ = null;
        }
        return commandBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config config_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder> configBuilder_;
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       * @return Whether the config field is set.
       */
      public boolean hasConfig() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       * @return The config.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig() {
        if (configBuilder_ == null) {
          return config_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
        } else {
          return configBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public Builder setConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
        if (configBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          config_ = value;
        } else {
          configBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public Builder setConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder builderForValue) {
        if (configBuilder_ == null) {
          config_ = builderForValue.build();
        } else {
          configBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public Builder mergeConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
        if (configBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            config_ != null &&
            config_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance()) {
            getConfigBuilder().mergeFrom(value);
          } else {
            config_ = value;
          }
        } else {
          configBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public Builder clearConfig() {
        bitField0_ = (bitField0_ & ~0x00000010);
        config_ = null;
        if (configBuilder_ != null) {
          configBuilder_.dispose();
          configBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder getConfigBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder getConfigOrBuilder() {
        if (configBuilder_ != null) {
          return configBuilder_.getMessageOrBuilder();
        } else {
          return config_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
        }
      }
      /**
       * <pre>
       * Input config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder> 
          getConfigFieldBuilder() {
        if (configBuilder_ == null) {
          configBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder>(
                  getConfig(),
                  getParentForChildren(),
                  isClean());
          config_ = null;
        }
        return configBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context context_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ContextOrBuilder> contextBuilder_;
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       * @return Whether the context field is set.
       */
      public boolean hasContext() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       * @return The context.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context getContext() {
        if (contextBuilder_ == null) {
          return context_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDefaultInstance() : context_;
        } else {
          return contextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public Builder setContext(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context value) {
        if (contextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          context_ = value;
        } else {
          contextBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public Builder setContext(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.Builder builderForValue) {
        if (contextBuilder_ == null) {
          context_ = builderForValue.build();
        } else {
          contextBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public Builder mergeContext(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context value) {
        if (contextBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            context_ != null &&
            context_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDefaultInstance()) {
            getContextBuilder().mergeFrom(value);
          } else {
            context_ = value;
          }
        } else {
          contextBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public Builder clearContext() {
        bitField0_ = (bitField0_ & ~0x00000020);
        context_ = null;
        if (contextBuilder_ != null) {
          contextBuilder_.dispose();
          contextBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.Builder getContextBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getContextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ContextOrBuilder getContextOrBuilder() {
        if (contextBuilder_ != null) {
          return contextBuilder_.getMessageOrBuilder();
        } else {
          return context_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.getDefaultInstance() : context_;
        }
      }
      /**
       * <pre>
       * Context data
       * </pre>
       *
       * <code>optional .mozc.commands.Context context = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ContextOrBuilder> 
          getContextFieldBuilder() {
        if (contextBuilder_ == null) {
          contextBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Context.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ContextOrBuilder>(
                  getContext(),
                  getParentForChildren(),
                  isClean());
          context_ = null;
        }
        return contextBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability capability_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CapabilityOrBuilder> capabilityBuilder_;
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       * @return Whether the capability field is set.
       */
      public boolean hasCapability() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       * @return The capability.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability getCapability() {
        if (capabilityBuilder_ == null) {
          return capability_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDefaultInstance() : capability_;
        } else {
          return capabilityBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public Builder setCapability(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability value) {
        if (capabilityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          capability_ = value;
        } else {
          capabilityBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public Builder setCapability(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.Builder builderForValue) {
        if (capabilityBuilder_ == null) {
          capability_ = builderForValue.build();
        } else {
          capabilityBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public Builder mergeCapability(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability value) {
        if (capabilityBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            capability_ != null &&
            capability_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDefaultInstance()) {
            getCapabilityBuilder().mergeFrom(value);
          } else {
            capability_ = value;
          }
        } else {
          capabilityBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public Builder clearCapability() {
        bitField0_ = (bitField0_ & ~0x00000040);
        capability_ = null;
        if (capabilityBuilder_ != null) {
          capabilityBuilder_.dispose();
          capabilityBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.Builder getCapabilityBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getCapabilityFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CapabilityOrBuilder getCapabilityOrBuilder() {
        if (capabilityBuilder_ != null) {
          return capabilityBuilder_.getMessageOrBuilder();
        } else {
          return capability_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.getDefaultInstance() : capability_;
        }
      }
      /**
       * <pre>
       * Client capability
       * </pre>
       *
       * <code>optional .mozc.commands.Capability capability = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CapabilityOrBuilder> 
          getCapabilityFieldBuilder() {
        if (capabilityBuilder_ == null) {
          capabilityBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Capability.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CapabilityOrBuilder>(
                  getCapability(),
                  getParentForChildren(),
                  isClean());
          capability_ = null;
        }
        return capabilityBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo applicationInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfoOrBuilder> applicationInfoBuilder_;
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       * @return Whether the applicationInfo field is set.
       */
      public boolean hasApplicationInfo() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       * @return The applicationInfo.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo getApplicationInfo() {
        if (applicationInfoBuilder_ == null) {
          return applicationInfo_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.getDefaultInstance() : applicationInfo_;
        } else {
          return applicationInfoBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public Builder setApplicationInfo(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo value) {
        if (applicationInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          applicationInfo_ = value;
        } else {
          applicationInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public Builder setApplicationInfo(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.Builder builderForValue) {
        if (applicationInfoBuilder_ == null) {
          applicationInfo_ = builderForValue.build();
        } else {
          applicationInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public Builder mergeApplicationInfo(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo value) {
        if (applicationInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
            applicationInfo_ != null &&
            applicationInfo_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.getDefaultInstance()) {
            getApplicationInfoBuilder().mergeFrom(value);
          } else {
            applicationInfo_ = value;
          }
        } else {
          applicationInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public Builder clearApplicationInfo() {
        bitField0_ = (bitField0_ & ~0x00000080);
        applicationInfo_ = null;
        if (applicationInfoBuilder_ != null) {
          applicationInfoBuilder_.dispose();
          applicationInfoBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.Builder getApplicationInfoBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getApplicationInfoFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfoOrBuilder getApplicationInfoOrBuilder() {
        if (applicationInfoBuilder_ != null) {
          return applicationInfoBuilder_.getMessageOrBuilder();
        } else {
          return applicationInfo_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.getDefaultInstance() : applicationInfo_;
        }
      }
      /**
       * <pre>
       * Application information, like process id.
       * Server may be able to change the behavior by seeing the
       * the program name.
       * </pre>
       *
       * <code>optional .mozc.commands.ApplicationInfo application_info = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfoOrBuilder> 
          getApplicationInfoFieldBuilder() {
        if (applicationInfoBuilder_ == null) {
          applicationInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfo.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ApplicationInfoOrBuilder>(
                  getApplicationInfo(),
                  getParentForChildren(),
                  isClean());
          applicationInfo_ = null;
        }
        return applicationInfoBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request request_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.RequestOrBuilder> requestBuilder_;
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       * @return Whether the request field is set.
       */
      public boolean hasRequest() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       * @return The request.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request getRequest() {
        if (requestBuilder_ == null) {
          return request_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDefaultInstance() : request_;
        } else {
          return requestBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public Builder setRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request value) {
        if (requestBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          request_ = value;
        } else {
          requestBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public Builder setRequest(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.Builder builderForValue) {
        if (requestBuilder_ == null) {
          request_ = builderForValue.build();
        } else {
          requestBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public Builder mergeRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request value) {
        if (requestBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
            request_ != null &&
            request_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDefaultInstance()) {
            getRequestBuilder().mergeFrom(value);
          } else {
            request_ = value;
          }
        } else {
          requestBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public Builder clearRequest() {
        bitField0_ = (bitField0_ & ~0x00000100);
        request_ = null;
        if (requestBuilder_ != null) {
          requestBuilder_.dispose();
          requestBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.Builder getRequestBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getRequestFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.RequestOrBuilder getRequestOrBuilder() {
        if (requestBuilder_ != null) {
          return requestBuilder_.getMessageOrBuilder();
        } else {
          return request_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.getDefaultInstance() : request_;
        }
      }
      /**
       * <pre>
       * Client request
       * </pre>
       *
       * <code>optional .mozc.commands.Request request = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.RequestOrBuilder> 
          getRequestFieldBuilder() {
        if (requestBuilder_ == null) {
          requestBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Request.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.RequestOrBuilder>(
                  getRequest(),
                  getParentForChildren(),
                  isClean());
          request_ = null;
        }
        return requestBuilder_;
      }

      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> touchEvents_ =
        java.util.Collections.emptyList();
      private void ensureTouchEventsIsMutable() {
        if (!((bitField0_ & 0x00000200) != 0)) {
          touchEvents_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent>(touchEvents_);
          bitField0_ |= 0x00000200;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder> touchEventsBuilder_;

      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> getTouchEventsList() {
        if (touchEventsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(touchEvents_);
        } else {
          return touchEventsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public int getTouchEventsCount() {
        if (touchEventsBuilder_ == null) {
          return touchEvents_.size();
        } else {
          return touchEventsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent getTouchEvents(int index) {
        if (touchEventsBuilder_ == null) {
          return touchEvents_.get(index);
        } else {
          return touchEventsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder setTouchEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent value) {
        if (touchEventsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTouchEventsIsMutable();
          touchEvents_.set(index, value);
          onChanged();
        } else {
          touchEventsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder setTouchEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder builderForValue) {
        if (touchEventsBuilder_ == null) {
          ensureTouchEventsIsMutable();
          touchEvents_.set(index, builderForValue.build());
          onChanged();
        } else {
          touchEventsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addTouchEvents(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent value) {
        if (touchEventsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTouchEventsIsMutable();
          touchEvents_.add(value);
          onChanged();
        } else {
          touchEventsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addTouchEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent value) {
        if (touchEventsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTouchEventsIsMutable();
          touchEvents_.add(index, value);
          onChanged();
        } else {
          touchEventsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addTouchEvents(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder builderForValue) {
        if (touchEventsBuilder_ == null) {
          ensureTouchEventsIsMutable();
          touchEvents_.add(builderForValue.build());
          onChanged();
        } else {
          touchEventsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addTouchEvents(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder builderForValue) {
        if (touchEventsBuilder_ == null) {
          ensureTouchEventsIsMutable();
          touchEvents_.add(index, builderForValue.build());
          onChanged();
        } else {
          touchEventsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder addAllTouchEvents(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent> values) {
        if (touchEventsBuilder_ == null) {
          ensureTouchEventsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, touchEvents_);
          onChanged();
        } else {
          touchEventsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder clearTouchEvents() {
        if (touchEventsBuilder_ == null) {
          touchEvents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
        } else {
          touchEventsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public Builder removeTouchEvents(int index) {
        if (touchEventsBuilder_ == null) {
          ensureTouchEventsIsMutable();
          touchEvents_.remove(index);
          onChanged();
        } else {
          touchEventsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder getTouchEventsBuilder(
          int index) {
        return getTouchEventsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder getTouchEventsOrBuilder(
          int index) {
        if (touchEventsBuilder_ == null) {
          return touchEvents_.get(index);  } else {
          return touchEventsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder> 
           getTouchEventsOrBuilderList() {
        if (touchEventsBuilder_ != null) {
          return touchEventsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(touchEvents_);
        }
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder addTouchEventsBuilder() {
        return getTouchEventsFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder addTouchEventsBuilder(
          int index) {
        return getTouchEventsFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.commands.Input.TouchEvent touch_events = 12;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder> 
           getTouchEventsBuilderList() {
        return getTouchEventsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder> 
          getTouchEventsFieldBuilder() {
        if (touchEventsBuilder_ == null) {
          touchEventsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.TouchEventOrBuilder>(
                  touchEvents_,
                  ((bitField0_ & 0x00000200) != 0),
                  getParentForChildren(),
                  isClean());
          touchEvents_ = null;
        }
        return touchEventsBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand userDictionaryCommand_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandOrBuilder> userDictionaryCommandBuilder_;
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
       * @return Whether the userDictionaryCommand field is set.
       */
      public boolean hasUserDictionaryCommand() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
       * @return The userDictionaryCommand.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand getUserDictionaryCommand() {
        if (userDictionaryCommandBuilder_ == null) {
          return userDictionaryCommand_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.getDefaultInstance() : userDictionaryCommand_;
        } else {
          return userDictionaryCommandBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
       */
      public Builder setUserDictionaryCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand value) {
        if (userDictionaryCommandBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          userDictionaryCommand_ = value;
        } else {
          userDictionaryCommandBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
       */
      public Builder setUserDictionaryCommand(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.Builder builderForValue) {
        if (userDictionaryCommandBuilder_ == null) {
          userDictionaryCommand_ = builderForValue.build();
        } else {
          userDictionaryCommandBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
       */
      public Builder mergeUserDictionaryCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand value) {
        if (userDictionaryCommandBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
            userDictionaryCommand_ != null &&
            userDictionaryCommand_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.getDefaultInstance()) {
            getUserDictionaryCommandBuilder().mergeFrom(value);
          } else {
            userDictionaryCommand_ = value;
          }
        } else {
          userDictionaryCommandBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
       */
      public Builder clearUserDictionaryCommand() {
        bitField0_ = (bitField0_ & ~0x00000400);
        userDictionaryCommand_ = null;
        if (userDictionaryCommandBuilder_ != null) {
          userDictionaryCommandBuilder_.dispose();
          userDictionaryCommandBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.Builder getUserDictionaryCommandBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getUserDictionaryCommandFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandOrBuilder getUserDictionaryCommandOrBuilder() {
        if (userDictionaryCommandBuilder_ != null) {
          return userDictionaryCommandBuilder_.getMessageOrBuilder();
        } else {
          return userDictionaryCommand_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.getDefaultInstance() : userDictionaryCommand_;
        }
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandOrBuilder> 
          getUserDictionaryCommandFieldBuilder() {
        if (userDictionaryCommandBuilder_ == null) {
          userDictionaryCommandBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommand.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandOrBuilder>(
                  getUserDictionaryCommand(),
                  getParentForChildren(),
                  isClean());
          userDictionaryCommand_ = null;
        }
        return userDictionaryCommandBuilder_;
      }

      private boolean requestSuggestion_ = true;
      /**
       * <pre>
       * A flag to control if the server should return suggest-results or not.
       * If this is set to false, regardless of other configurations,
       * the server won't return suggestion results.
       * This is set to true by default.
       * Note that even if this flag is set to false, when a suggestion is shown
       * in the previous phase, it is possible from the client to submit it.
       * This works only for suggestions for the key insertion, but not for
       * others commands, such as predictions or conversions.
       * This flag is used for the performance improvement in terms of the
       * latency.  If you want to suppress the suggestions for the UX improment,
       * you may want to use suppress_suggestion in the Context message.
       * </pre>
       *
       * <code>optional bool request_suggestion = 14 [default = true];</code>
       * @return Whether the requestSuggestion field is set.
       */
      @java.lang.Override
      public boolean hasRequestSuggestion() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * A flag to control if the server should return suggest-results or not.
       * If this is set to false, regardless of other configurations,
       * the server won't return suggestion results.
       * This is set to true by default.
       * Note that even if this flag is set to false, when a suggestion is shown
       * in the previous phase, it is possible from the client to submit it.
       * This works only for suggestions for the key insertion, but not for
       * others commands, such as predictions or conversions.
       * This flag is used for the performance improvement in terms of the
       * latency.  If you want to suppress the suggestions for the UX improment,
       * you may want to use suppress_suggestion in the Context message.
       * </pre>
       *
       * <code>optional bool request_suggestion = 14 [default = true];</code>
       * @return The requestSuggestion.
       */
      @java.lang.Override
      public boolean getRequestSuggestion() {
        return requestSuggestion_;
      }
      /**
       * <pre>
       * A flag to control if the server should return suggest-results or not.
       * If this is set to false, regardless of other configurations,
       * the server won't return suggestion results.
       * This is set to true by default.
       * Note that even if this flag is set to false, when a suggestion is shown
       * in the previous phase, it is possible from the client to submit it.
       * This works only for suggestions for the key insertion, but not for
       * others commands, such as predictions or conversions.
       * This flag is used for the performance improvement in terms of the
       * latency.  If you want to suppress the suggestions for the UX improment,
       * you may want to use suppress_suggestion in the Context message.
       * </pre>
       *
       * <code>optional bool request_suggestion = 14 [default = true];</code>
       * @param value The requestSuggestion to set.
       * @return This builder for chaining.
       */
      public Builder setRequestSuggestion(boolean value) {
        
        requestSuggestion_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A flag to control if the server should return suggest-results or not.
       * If this is set to false, regardless of other configurations,
       * the server won't return suggestion results.
       * This is set to true by default.
       * Note that even if this flag is set to false, when a suggestion is shown
       * in the previous phase, it is possible from the client to submit it.
       * This works only for suggestions for the key insertion, but not for
       * others commands, such as predictions or conversions.
       * This flag is used for the performance improvement in terms of the
       * latency.  If you want to suppress the suggestions for the UX improment,
       * you may want to use suppress_suggestion in the Context message.
       * </pre>
       *
       * <code>optional bool request_suggestion = 14 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearRequestSuggestion() {
        bitField0_ = (bitField0_ & ~0x00000800);
        requestSuggestion_ = true;
        onChanged();
        return this;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest engineReloadRequest_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequestOrBuilder> engineReloadRequestBuilder_;
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       * @return Whether the engineReloadRequest field is set.
       */
      public boolean hasEngineReloadRequest() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       * @return The engineReloadRequest.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest getEngineReloadRequest() {
        if (engineReloadRequestBuilder_ == null) {
          return engineReloadRequest_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.getDefaultInstance() : engineReloadRequest_;
        } else {
          return engineReloadRequestBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public Builder setEngineReloadRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest value) {
        if (engineReloadRequestBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          engineReloadRequest_ = value;
        } else {
          engineReloadRequestBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public Builder setEngineReloadRequest(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.Builder builderForValue) {
        if (engineReloadRequestBuilder_ == null) {
          engineReloadRequest_ = builderForValue.build();
        } else {
          engineReloadRequestBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public Builder mergeEngineReloadRequest(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest value) {
        if (engineReloadRequestBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0) &&
            engineReloadRequest_ != null &&
            engineReloadRequest_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.getDefaultInstance()) {
            getEngineReloadRequestBuilder().mergeFrom(value);
          } else {
            engineReloadRequest_ = value;
          }
        } else {
          engineReloadRequestBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public Builder clearEngineReloadRequest() {
        bitField0_ = (bitField0_ & ~0x00001000);
        engineReloadRequest_ = null;
        if (engineReloadRequestBuilder_ != null) {
          engineReloadRequestBuilder_.dispose();
          engineReloadRequestBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.Builder getEngineReloadRequestBuilder() {
        bitField0_ |= 0x00001000;
        onChanged();
        return getEngineReloadRequestFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequestOrBuilder getEngineReloadRequestOrBuilder() {
        if (engineReloadRequestBuilder_ != null) {
          return engineReloadRequestBuilder_.getMessageOrBuilder();
        } else {
          return engineReloadRequest_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.getDefaultInstance() : engineReloadRequest_;
        }
      }
      /**
       * <code>optional .mozc.EngineReloadRequest engine_reload_request = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequestOrBuilder> 
          getEngineReloadRequestFieldBuilder() {
        if (engineReloadRequestBuilder_ == null) {
          engineReloadRequestBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequest.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadRequestOrBuilder>(
                  getEngineReloadRequest(),
                  getParentForChildren(),
                  isClean());
          engineReloadRequest_ = null;
        }
        return engineReloadRequestBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.Input)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.Input)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Input>
        PARSER = new com.google.protobuf.AbstractParser<Input>() {
      @java.lang.Override
      public Input parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Input> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Input> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ResultTokenOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.ResultToken)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return The value.
     */
    java.lang.String getValue();
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return The bytes for value.
     */
    com.google.protobuf.ByteString
        getValueBytes();

    /**
     * <code>optional string key = 2;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <code>optional string key = 2;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <code>optional string key = 2;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     * @return Whether the lid field is set.
     */
    boolean hasLid();
    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     * @return The lid.
     */
    int getLid();

    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     * @return Whether the rid field is set.
     */
    boolean hasRid();
    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     * @return The rid.
     */
    int getRid();
  }
  /**
   * <pre>
   * Detailed information of Result.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.ResultToken}
   */
  public static final class ResultToken extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.ResultToken)
      ResultTokenOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ResultToken.newBuilder() to construct.
    private ResultToken(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ResultToken() {
      value_ = "";
      key_ = "";
      lid_ = -1;
      rid_ = -1;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ResultToken();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ResultToken_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ResultToken_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder.class);
    }

    private int bitField0_;
    public static final int VALUE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object value_ = "";
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return The value.
     */
    @java.lang.Override
    public java.lang.String getValue() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          value_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `value` and `key` represents Segment.Candidate. If the candidante has
     * functional values, they are stored as a sepalate ResultToken.
     * e.g. A candidate of {value="今日は", content_value="今日"} results
     * two ResultToken of {value="今日"} and {value="は"}.
     * </pre>
     *
     * <code>optional string value = 1;</code>
     * @return The bytes for value.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValueBytes() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        value_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEY_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object key_ = "";
    /**
     * <code>optional string key = 2;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string key = 2;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          key_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string key = 2;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LID_FIELD_NUMBER = 3;
    private int lid_ = -1;
    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     * @return Whether the lid field is set.
     */
    @java.lang.Override
    public boolean hasLid() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
     * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
     * results two ResultToken of {value="朝", lid=2, rid=-1} and
     * {value="は", lid=-1, rid=3}.
     * </pre>
     *
     * <code>optional int32 lid = 3 [default = -1];</code>
     * @return The lid.
     */
    @java.lang.Override
    public int getLid() {
      return lid_;
    }

    public static final int RID_FIELD_NUMBER = 4;
    private int rid_ = -1;
    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     * @return Whether the rid field is set.
     */
    @java.lang.Override
    public boolean hasRid() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional int32 rid = 4 [default = -1];</code>
     * @return The rid.
     */
    @java.lang.Override
    public int getRid() {
      return rid_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, value_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, key_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt32(3, lid_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(4, rid_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, value_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, key_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, lid_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, rid_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken) obj;

      if (hasValue() != other.hasValue()) return false;
      if (hasValue()) {
        if (!getValue()
            .equals(other.getValue())) return false;
      }
      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (hasLid() != other.hasLid()) return false;
      if (hasLid()) {
        if (getLid()
            != other.getLid()) return false;
      }
      if (hasRid() != other.hasRid()) return false;
      if (hasRid()) {
        if (getRid()
            != other.getRid()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasValue()) {
        hash = (37 * hash) + VALUE_FIELD_NUMBER;
        hash = (53 * hash) + getValue().hashCode();
      }
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasLid()) {
        hash = (37 * hash) + LID_FIELD_NUMBER;
        hash = (53 * hash) + getLid();
      }
      if (hasRid()) {
        hash = (37 * hash) + RID_FIELD_NUMBER;
        hash = (53 * hash) + getRid();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Detailed information of Result.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.ResultToken}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.ResultToken)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ResultToken_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ResultToken_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        value_ = "";
        key_ = "";
        lid_ = -1;
        rid_ = -1;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_ResultToken_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.value_ = value_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.key_ = key_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.lid_ = lid_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.rid_ = rid_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.getDefaultInstance()) return this;
        if (other.hasValue()) {
          value_ = other.value_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasKey()) {
          key_ = other.key_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasLid()) {
          setLid(other.getLid());
        }
        if (other.hasRid()) {
          setRid(other.getRid());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                value_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                key_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                lid_ = input.readInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                rid_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object value_ = "";
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @return Whether the value field is set.
       */
      public boolean hasValue() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @return The value.
       */
      public java.lang.String getValue() {
        java.lang.Object ref = value_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            value_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @return The bytes for value.
       */
      public com.google.protobuf.ByteString
          getValueBytes() {
        java.lang.Object ref = value_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          value_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        value_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        value_ = getDefaultInstance().getValue();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `value` and `key` represents Segment.Candidate. If the candidante has
       * functional values, they are stored as a sepalate ResultToken.
       * e.g. A candidate of {value="今日は", content_value="今日"} results
       * two ResultToken of {value="今日"} and {value="は"}.
       * </pre>
       *
       * <code>optional string value = 1;</code>
       * @param value The bytes for value to set.
       * @return This builder for chaining.
       */
      public Builder setValueBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        value_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object key_ = "";
      /**
       * <code>optional string key = 2;</code>
       * @return Whether the key field is set.
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string key = 2;</code>
       * @return The key.
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string key = 2;</code>
       * @return The bytes for key.
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string key = 2;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional string key = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        key_ = getDefaultInstance().getKey();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <code>optional string key = 2;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private int lid_ = -1;
      /**
       * <pre>
       * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
       * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
       * results two ResultToken of {value="朝", lid=2, rid=-1} and
       * {value="は", lid=-1, rid=3}.
       * </pre>
       *
       * <code>optional int32 lid = 3 [default = -1];</code>
       * @return Whether the lid field is set.
       */
      @java.lang.Override
      public boolean hasLid() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
       * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
       * results two ResultToken of {value="朝", lid=2, rid=-1} and
       * {value="は", lid=-1, rid=3}.
       * </pre>
       *
       * <code>optional int32 lid = 3 [default = -1];</code>
       * @return The lid.
       */
      @java.lang.Override
      public int getLid() {
        return lid_;
      }
      /**
       * <pre>
       * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
       * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
       * results two ResultToken of {value="朝", lid=2, rid=-1} and
       * {value="は", lid=-1, rid=3}.
       * </pre>
       *
       * <code>optional int32 lid = 3 [default = -1];</code>
       * @param value The lid to set.
       * @return This builder for chaining.
       */
      public Builder setLid(int value) {
        
        lid_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
       * POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
       * results two ResultToken of {value="朝", lid=2, rid=-1} and
       * {value="は", lid=-1, rid=3}.
       * </pre>
       *
       * <code>optional int32 lid = 3 [default = -1];</code>
       * @return This builder for chaining.
       */
      public Builder clearLid() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lid_ = -1;
        onChanged();
        return this;
      }

      private int rid_ = -1;
      /**
       * <code>optional int32 rid = 4 [default = -1];</code>
       * @return Whether the rid field is set.
       */
      @java.lang.Override
      public boolean hasRid() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional int32 rid = 4 [default = -1];</code>
       * @return The rid.
       */
      @java.lang.Override
      public int getRid() {
        return rid_;
      }
      /**
       * <code>optional int32 rid = 4 [default = -1];</code>
       * @param value The rid to set.
       * @return This builder for chaining.
       */
      public Builder setRid(int value) {
        
        rid_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 rid = 4 [default = -1];</code>
       * @return This builder for chaining.
       */
      public Builder clearRid() {
        bitField0_ = (bitField0_ & ~0x00000008);
        rid_ = -1;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.ResultToken)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.ResultToken)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ResultToken>
        PARSER = new com.google.protobuf.AbstractParser<ResultToken>() {
      @java.lang.Override
      public ResultToken parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ResultToken> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ResultToken> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ResultOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Result)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     * @return The type.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType getType();

    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return The value.
     */
    java.lang.String getValue();
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return The bytes for value.
     */
    com.google.protobuf.ByteString
        getValueBytes();

    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     * @return Whether the cursorOffset field is set.
     */
    boolean hasCursorOffset();
    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     * @return The cursorOffset.
     */
    int getCursorOffset();

    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> 
        getTokensList();
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getTokens(int index);
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    int getTokensCount();
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder> 
        getTokensOrBuilderList();
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder getTokensOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Result contains data to be submitted to the host application by the
   * ime client.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Result}
   */
  public static final class Result extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Result)
      ResultOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Result.newBuilder() to construct.
    private Result(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Result() {
      type_ = 0;
      value_ = "";
      key_ = "";
      tokens_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Result();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Result_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Result_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.Builder.class);
    }

    /**
     * Protobuf enum {@code mozc.commands.Result.ResultType}
     */
    public enum ResultType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NONE = 0;</code>
       */
      NONE(0),
      /**
       * <code>STRING = 1;</code>
       */
      STRING(1),
      ;

      /**
       * <code>NONE = 0;</code>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <code>STRING = 1;</code>
       */
      public static final int STRING_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ResultType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static ResultType forNumber(int value) {
        switch (value) {
          case 0: return NONE;
          case 1: return STRING;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ResultType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ResultType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ResultType>() {
              public ResultType findValueByNumber(int number) {
                return ResultType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDescriptor().getEnumTypes().get(0);
      }

      private static final ResultType[] VALUES = values();

      public static ResultType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private ResultType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Result.ResultType)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 0;
    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .mozc.commands.Result.ResultType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType getType() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType.forNumber(type_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType.NONE : result;
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object value_ = "";
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return The value.
     */
    @java.lang.Override
    public java.lang.String getValue() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          value_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The result of conversion.
     * </pre>
     *
     * <code>required string value = 2;</code>
     * @return The bytes for value.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValueBytes() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        value_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEY_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object key_ = "";
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          key_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Source of the value.  It is almost always the reading of the value.
     * </pre>
     *
     * <code>optional string key = 3;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CURSOR_OFFSET_FIELD_NUMBER = 4;
    private int cursorOffset_ = 0;
    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     * @return Whether the cursorOffset field is set.
     */
    @java.lang.Override
    public boolean hasCursorOffset() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The caret position after the result submission.
     * "0" means the end of the result, and a positive value means moving forward
     * and a negative value backward.
     * e.g.) "-s", where s is the length of value, means the caret position
     * after the committing should be the beginning of the committed value.
     * </pre>
     *
     * <code>optional int32 cursor_offset = 4 [default = 0];</code>
     * @return The cursorOffset.
     */
    @java.lang.Override
    public int getCursorOffset() {
      return cursorOffset_;
    }

    public static final int TOKENS_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> tokens_;
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> getTokensList() {
      return tokens_;
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder> 
        getTokensOrBuilderList() {
      return tokens_;
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    @java.lang.Override
    public int getTokensCount() {
      return tokens_.size();
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getTokens(int index) {
      return tokens_.get(index);
    }
    /**
     * <pre>
     * Additional information propagated from the internal status.
     * </pre>
     *
     * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder getTokensOrBuilder(
        int index) {
      return tokens_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasValue()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, value_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, key_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(4, cursorOffset_);
      }
      for (int i = 0; i < tokens_.size(); i++) {
        output.writeMessage(5, tokens_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, value_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, key_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, cursorOffset_);
      }
      for (int i = 0; i < tokens_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, tokens_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasValue() != other.hasValue()) return false;
      if (hasValue()) {
        if (!getValue()
            .equals(other.getValue())) return false;
      }
      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (hasCursorOffset() != other.hasCursorOffset()) return false;
      if (hasCursorOffset()) {
        if (getCursorOffset()
            != other.getCursorOffset()) return false;
      }
      if (!getTokensList()
          .equals(other.getTokensList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasValue()) {
        hash = (37 * hash) + VALUE_FIELD_NUMBER;
        hash = (53 * hash) + getValue().hashCode();
      }
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasCursorOffset()) {
        hash = (37 * hash) + CURSOR_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + getCursorOffset();
      }
      if (getTokensCount() > 0) {
        hash = (37 * hash) + TOKENS_FIELD_NUMBER;
        hash = (53 * hash) + getTokensList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Result contains data to be submitted to the host application by the
     * ime client.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Result}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Result)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Result_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Result_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 0;
        value_ = "";
        key_ = "";
        cursorOffset_ = 0;
        if (tokensBuilder_ == null) {
          tokens_ = java.util.Collections.emptyList();
        } else {
          tokens_ = null;
          tokensBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Result_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result result) {
        if (tokensBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            tokens_ = java.util.Collections.unmodifiableList(tokens_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.tokens_ = tokens_;
        } else {
          result.tokens_ = tokensBuilder_.build();
        }
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.value_ = value_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.key_ = key_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.cursorOffset_ = cursorOffset_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasValue()) {
          value_ = other.value_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasKey()) {
          key_ = other.key_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasCursorOffset()) {
          setCursorOffset(other.getCursorOffset());
        }
        if (tokensBuilder_ == null) {
          if (!other.tokens_.isEmpty()) {
            if (tokens_.isEmpty()) {
              tokens_ = other.tokens_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureTokensIsMutable();
              tokens_.addAll(other.tokens_);
            }
            onChanged();
          }
        } else {
          if (!other.tokens_.isEmpty()) {
            if (tokensBuilder_.isEmpty()) {
              tokensBuilder_.dispose();
              tokensBuilder_ = null;
              tokens_ = other.tokens_;
              bitField0_ = (bitField0_ & ~0x00000010);
              tokensBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTokensFieldBuilder() : null;
            } else {
              tokensBuilder_.addAllMessages(other.tokens_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasType()) {
          return false;
        }
        if (!hasValue()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  type_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 18: {
                value_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                key_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                cursorOffset_ = input.readInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 42: {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken m =
                    input.readMessage(
                        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.PARSER,
                        extensionRegistry);
                if (tokensBuilder_ == null) {
                  ensureTokensIsMutable();
                  tokens_.add(m);
                } else {
                  tokensBuilder_.addMessage(m);
                }
                break;
              } // case 42
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int type_ = 0;
      /**
       * <code>required .mozc.commands.Result.ResultType type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .mozc.commands.Result.ResultType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType getType() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType.forNumber(type_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType.NONE : result;
      }
      /**
       * <code>required .mozc.commands.Result.ResultType type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.ResultType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .mozc.commands.Result.ResultType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object value_ = "";
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @return Whether the value field is set.
       */
      public boolean hasValue() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @return The value.
       */
      public java.lang.String getValue() {
        java.lang.Object ref = value_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            value_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @return The bytes for value.
       */
      public com.google.protobuf.ByteString
          getValueBytes() {
        java.lang.Object ref = value_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          value_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        value_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        value_ = getDefaultInstance().getValue();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The result of conversion.
       * </pre>
       *
       * <code>required string value = 2;</code>
       * @param value The bytes for value to set.
       * @return This builder for chaining.
       */
      public Builder setValueBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        value_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object key_ = "";
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @return Whether the key field is set.
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @return The key.
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @return The bytes for key.
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        key_ = getDefaultInstance().getKey();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 3;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private int cursorOffset_ ;
      /**
       * <pre>
       * The caret position after the result submission.
       * "0" means the end of the result, and a positive value means moving forward
       * and a negative value backward.
       * e.g.) "-s", where s is the length of value, means the caret position
       * after the committing should be the beginning of the committed value.
       * </pre>
       *
       * <code>optional int32 cursor_offset = 4 [default = 0];</code>
       * @return Whether the cursorOffset field is set.
       */
      @java.lang.Override
      public boolean hasCursorOffset() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The caret position after the result submission.
       * "0" means the end of the result, and a positive value means moving forward
       * and a negative value backward.
       * e.g.) "-s", where s is the length of value, means the caret position
       * after the committing should be the beginning of the committed value.
       * </pre>
       *
       * <code>optional int32 cursor_offset = 4 [default = 0];</code>
       * @return The cursorOffset.
       */
      @java.lang.Override
      public int getCursorOffset() {
        return cursorOffset_;
      }
      /**
       * <pre>
       * The caret position after the result submission.
       * "0" means the end of the result, and a positive value means moving forward
       * and a negative value backward.
       * e.g.) "-s", where s is the length of value, means the caret position
       * after the committing should be the beginning of the committed value.
       * </pre>
       *
       * <code>optional int32 cursor_offset = 4 [default = 0];</code>
       * @param value The cursorOffset to set.
       * @return This builder for chaining.
       */
      public Builder setCursorOffset(int value) {
        
        cursorOffset_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The caret position after the result submission.
       * "0" means the end of the result, and a positive value means moving forward
       * and a negative value backward.
       * e.g.) "-s", where s is the length of value, means the caret position
       * after the committing should be the beginning of the committed value.
       * </pre>
       *
       * <code>optional int32 cursor_offset = 4 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearCursorOffset() {
        bitField0_ = (bitField0_ & ~0x00000008);
        cursorOffset_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> tokens_ =
        java.util.Collections.emptyList();
      private void ensureTokensIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          tokens_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken>(tokens_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder> tokensBuilder_;

      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> getTokensList() {
        if (tokensBuilder_ == null) {
          return java.util.Collections.unmodifiableList(tokens_);
        } else {
          return tokensBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public int getTokensCount() {
        if (tokensBuilder_ == null) {
          return tokens_.size();
        } else {
          return tokensBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken getTokens(int index) {
        if (tokensBuilder_ == null) {
          return tokens_.get(index);
        } else {
          return tokensBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder setTokens(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken value) {
        if (tokensBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTokensIsMutable();
          tokens_.set(index, value);
          onChanged();
        } else {
          tokensBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder setTokens(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder builderForValue) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          tokens_.set(index, builderForValue.build());
          onChanged();
        } else {
          tokensBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addTokens(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken value) {
        if (tokensBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTokensIsMutable();
          tokens_.add(value);
          onChanged();
        } else {
          tokensBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addTokens(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken value) {
        if (tokensBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTokensIsMutable();
          tokens_.add(index, value);
          onChanged();
        } else {
          tokensBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addTokens(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder builderForValue) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          tokens_.add(builderForValue.build());
          onChanged();
        } else {
          tokensBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addTokens(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder builderForValue) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          tokens_.add(index, builderForValue.build());
          onChanged();
        } else {
          tokensBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder addAllTokens(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken> values) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, tokens_);
          onChanged();
        } else {
          tokensBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder clearTokens() {
        if (tokensBuilder_ == null) {
          tokens_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          tokensBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public Builder removeTokens(int index) {
        if (tokensBuilder_ == null) {
          ensureTokensIsMutable();
          tokens_.remove(index);
          onChanged();
        } else {
          tokensBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder getTokensBuilder(
          int index) {
        return getTokensFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder getTokensOrBuilder(
          int index) {
        if (tokensBuilder_ == null) {
          return tokens_.get(index);  } else {
          return tokensBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder> 
           getTokensOrBuilderList() {
        if (tokensBuilder_ != null) {
          return tokensBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(tokens_);
        }
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder addTokensBuilder() {
        return getTokensFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.getDefaultInstance());
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder addTokensBuilder(
          int index) {
        return getTokensFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.getDefaultInstance());
      }
      /**
       * <pre>
       * Additional information propagated from the internal status.
       * </pre>
       *
       * <code>repeated .mozc.commands.ResultToken tokens = 5;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder> 
           getTokensBuilderList() {
        return getTokensFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder> 
          getTokensFieldBuilder() {
        if (tokensBuilder_ == null) {
          tokensBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultToken.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultTokenOrBuilder>(
                  tokens_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          tokens_ = null;
        }
        return tokensBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.Result)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.Result)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Result>
        PARSER = new com.google.protobuf.AbstractParser<Result>() {
      @java.lang.Override
      public Result parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Result> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Result> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PreeditOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Preedit)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required uint32 cursor = 1;</code>
     * @return Whether the cursor field is set.
     */
    boolean hasCursor();
    /**
     * <code>required uint32 cursor = 1;</code>
     * @return The cursor.
     */
    int getCursor();

    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> 
        getSegmentList();
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getSegment(int index);
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    int getSegmentCount();
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder> 
        getSegmentOrBuilderList();
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder getSegmentOrBuilder(
        int index);

    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     * @return Whether the highlightedPosition field is set.
     */
    boolean hasHighlightedPosition();
    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     * @return The highlightedPosition.
     */
    int getHighlightedPosition();

    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     * @return Whether the isToggleable field is set.
     */
    boolean hasIsToggleable();
    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     * @return The isToggleable.
     */
    boolean getIsToggleable();
  }
  /**
   * <pre>
   * Preedit represents a composition data, which is rendered on the
   * host application by the ime client.  On Japanese IME, the both
   * Preedit and Conversion statuses are represented by this message.
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Preedit}
   */
  public static final class Preedit extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Preedit)
      PreeditOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Preedit.newBuilder() to construct.
    private Preedit(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Preedit() {
      segment_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Preedit();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Builder.class);
    }

    public interface SegmentOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Preedit.Segment)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       * @return Whether the annotation field is set.
       */
      boolean hasAnnotation();
      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       * @return The annotation.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation getAnnotation();

      /**
       * <code>required string value = 4;</code>
       * @return Whether the value field is set.
       */
      boolean hasValue();
      /**
       * <code>required string value = 4;</code>
       * @return The value.
       */
      java.lang.String getValue();
      /**
       * <code>required string value = 4;</code>
       * @return The bytes for value.
       */
      com.google.protobuf.ByteString
          getValueBytes();

      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       * @return Whether the valueLength field is set.
       */
      boolean hasValueLength();
      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       * @return The valueLength.
       */
      int getValueLength();

      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return Whether the key field is set.
       */
      boolean hasKey();
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return The key.
       */
      java.lang.String getKey();
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return The bytes for key.
       */
      com.google.protobuf.ByteString
          getKeyBytes();
    }
    /**
     * <pre>
     * The string data of Preedit is separated into Segment messages
     * presenting the ime server's status.  On Preedit status of
     * Japanese IME, there are up to three segments; left side chars of
     * cursor, forcused char, right side chars of cursor.  On Conversion
     * status of Japanese IME, the messages literally represent the
     * segments of the conversion.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Preedit.Segment}
     */
    public static final class Segment extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Preedit.Segment)
        SegmentOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Segment.newBuilder() to construct.
      private Segment(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Segment() {
        annotation_ = 0;
        value_ = "";
        key_ = "";
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new Segment();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_Segment_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_Segment_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder.class);
      }

      /**
       * Protobuf enum {@code mozc.commands.Preedit.Segment.Annotation}
       */
      public enum Annotation
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>NONE = 0;</code>
         */
        NONE(0),
        /**
         * <code>UNDERLINE = 1;</code>
         */
        UNDERLINE(1),
        /**
         * <code>HIGHLIGHT = 2;</code>
         */
        HIGHLIGHT(2),
        ;

        /**
         * <code>NONE = 0;</code>
         */
        public static final int NONE_VALUE = 0;
        /**
         * <code>UNDERLINE = 1;</code>
         */
        public static final int UNDERLINE_VALUE = 1;
        /**
         * <code>HIGHLIGHT = 2;</code>
         */
        public static final int HIGHLIGHT_VALUE = 2;


        public final int getNumber() {
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Annotation valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static Annotation forNumber(int value) {
          switch (value) {
            case 0: return NONE;
            case 1: return UNDERLINE;
            case 2: return HIGHLIGHT;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Annotation>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Annotation> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Annotation>() {
                public Annotation findValueByNumber(int number) {
                  return Annotation.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.getDescriptor().getEnumTypes().get(0);
        }

        private static final Annotation[] VALUES = values();

        public static Annotation valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Annotation(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:mozc.commands.Preedit.Segment.Annotation)
      }

      private int bitField0_;
      public static final int ANNOTATION_FIELD_NUMBER = 3;
      private int annotation_ = 0;
      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       * @return Whether the annotation field is set.
       */
      @java.lang.Override public boolean hasAnnotation() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
       * @return The annotation.
       */
      @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation getAnnotation() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation.forNumber(annotation_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation.NONE : result;
      }

      public static final int VALUE_FIELD_NUMBER = 4;
      @SuppressWarnings("serial")
      private volatile java.lang.Object value_ = "";
      /**
       * <code>required string value = 4;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>required string value = 4;</code>
       * @return The value.
       */
      @java.lang.Override
      public java.lang.String getValue() {
        java.lang.Object ref = value_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            value_ = s;
          }
          return s;
        }
      }
      /**
       * <code>required string value = 4;</code>
       * @return The bytes for value.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getValueBytes() {
        java.lang.Object ref = value_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          value_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int VALUE_LENGTH_FIELD_NUMBER = 5;
      private int valueLength_ = 0;
      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       * @return Whether the valueLength field is set.
       */
      @java.lang.Override
      public boolean hasValueLength() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The length of value in characters.  This is NOT a number in
       * bytes or logical character units.  So, the length of "abc" and
       * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
       * should be 2.
       * </pre>
       *
       * <code>required uint32 value_length = 5;</code>
       * @return The valueLength.
       */
      @java.lang.Override
      public int getValueLength() {
        return valueLength_;
      }

      public static final int KEY_FIELD_NUMBER = 6;
      @SuppressWarnings("serial")
      private volatile java.lang.Object key_ = "";
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return Whether the key field is set.
       */
      @java.lang.Override
      public boolean hasKey() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return The key.
       */
      @java.lang.Override
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * Source of the value.  It is almost always the reading of the value.
       * </pre>
       *
       * <code>optional string key = 6;</code>
       * @return The bytes for key.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (!hasAnnotation()) {
          memoizedIsInitialized = 0;
          return false;
        }
        if (!hasValue()) {
          memoizedIsInitialized = 0;
          return false;
        }
        if (!hasValueLength()) {
          memoizedIsInitialized = 0;
          return false;
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeEnum(3, annotation_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 4, value_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeUInt32(5, valueLength_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 6, key_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(3, annotation_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, value_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(5, valueLength_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, key_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment) obj;

        if (hasAnnotation() != other.hasAnnotation()) return false;
        if (hasAnnotation()) {
          if (annotation_ != other.annotation_) return false;
        }
        if (hasValue() != other.hasValue()) return false;
        if (hasValue()) {
          if (!getValue()
              .equals(other.getValue())) return false;
        }
        if (hasValueLength() != other.hasValueLength()) return false;
        if (hasValueLength()) {
          if (getValueLength()
              != other.getValueLength()) return false;
        }
        if (hasKey() != other.hasKey()) return false;
        if (hasKey()) {
          if (!getKey()
              .equals(other.getKey())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasAnnotation()) {
          hash = (37 * hash) + ANNOTATION_FIELD_NUMBER;
          hash = (53 * hash) + annotation_;
        }
        if (hasValue()) {
          hash = (37 * hash) + VALUE_FIELD_NUMBER;
          hash = (53 * hash) + getValue().hashCode();
        }
        if (hasValueLength()) {
          hash = (37 * hash) + VALUE_LENGTH_FIELD_NUMBER;
          hash = (53 * hash) + getValueLength();
        }
        if (hasKey()) {
          hash = (37 * hash) + KEY_FIELD_NUMBER;
          hash = (53 * hash) + getKey().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * The string data of Preedit is separated into Segment messages
       * presenting the ime server's status.  On Preedit status of
       * Japanese IME, there are up to three segments; left side chars of
       * cursor, forcused char, right side chars of cursor.  On Conversion
       * status of Japanese IME, the messages literally represent the
       * segments of the conversion.
       * </pre>
       *
       * Protobuf type {@code mozc.commands.Preedit.Segment}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Preedit.Segment)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_Segment_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_Segment_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          annotation_ = 0;
          value_ = "";
          valueLength_ = 0;
          key_ = "";
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_Segment_descriptor;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.getDefaultInstance();
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.annotation_ = annotation_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.value_ = value_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.valueLength_ = valueLength_;
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.key_ = key_;
            to_bitField0_ |= 0x00000008;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.getDefaultInstance()) return this;
          if (other.hasAnnotation()) {
            setAnnotation(other.getAnnotation());
          }
          if (other.hasValue()) {
            value_ = other.value_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          if (other.hasValueLength()) {
            setValueLength(other.getValueLength());
          }
          if (other.hasKey()) {
            key_ = other.key_;
            bitField0_ |= 0x00000008;
            onChanged();
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (!hasAnnotation()) {
            return false;
          }
          if (!hasValue()) {
            return false;
          }
          if (!hasValueLength()) {
            return false;
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 24: {
                  int tmpRaw = input.readEnum();
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation tmpValue =
                      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(3, tmpRaw);
                  } else {
                    annotation_ = tmpRaw;
                    bitField0_ |= 0x00000001;
                  }
                  break;
                } // case 24
                case 34: {
                  value_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 34
                case 40: {
                  valueLength_ = input.readUInt32();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 40
                case 50: {
                  key_ = input.readBytes();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 50
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int annotation_ = 0;
        /**
         * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
         * @return Whether the annotation field is set.
         */
        @java.lang.Override public boolean hasAnnotation() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
         * @return The annotation.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation getAnnotation() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation.forNumber(annotation_);
          return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation.NONE : result;
        }
        /**
         * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
         * @param value The annotation to set.
         * @return This builder for chaining.
         */
        public Builder setAnnotation(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Annotation value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000001;
          annotation_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>required .mozc.commands.Preedit.Segment.Annotation annotation = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearAnnotation() {
          bitField0_ = (bitField0_ & ~0x00000001);
          annotation_ = 0;
          onChanged();
          return this;
        }

        private java.lang.Object value_ = "";
        /**
         * <code>required string value = 4;</code>
         * @return Whether the value field is set.
         */
        public boolean hasValue() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>required string value = 4;</code>
         * @return The value.
         */
        public java.lang.String getValue() {
          java.lang.Object ref = value_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              value_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <code>required string value = 4;</code>
         * @return The bytes for value.
         */
        public com.google.protobuf.ByteString
            getValueBytes() {
          java.lang.Object ref = value_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            value_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <code>required string value = 4;</code>
         * @param value The value to set.
         * @return This builder for chaining.
         */
        public Builder setValue(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          value_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <code>required string value = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearValue() {
          value_ = getDefaultInstance().getValue();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <code>required string value = 4;</code>
         * @param value The bytes for value to set.
         * @return This builder for chaining.
         */
        public Builder setValueBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          value_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }

        private int valueLength_ ;
        /**
         * <pre>
         * The length of value in characters.  This is NOT a number in
         * bytes or logical character units.  So, the length of "abc" and
         * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
         * should be 2.
         * </pre>
         *
         * <code>required uint32 value_length = 5;</code>
         * @return Whether the valueLength field is set.
         */
        @java.lang.Override
        public boolean hasValueLength() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The length of value in characters.  This is NOT a number in
         * bytes or logical character units.  So, the length of "abc" and
         * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
         * should be 2.
         * </pre>
         *
         * <code>required uint32 value_length = 5;</code>
         * @return The valueLength.
         */
        @java.lang.Override
        public int getValueLength() {
          return valueLength_;
        }
        /**
         * <pre>
         * The length of value in characters.  This is NOT a number in
         * bytes or logical character units.  So, the length of "abc" and
         * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
         * should be 2.
         * </pre>
         *
         * <code>required uint32 value_length = 5;</code>
         * @param value The valueLength to set.
         * @return This builder for chaining.
         */
        public Builder setValueLength(int value) {
          
          valueLength_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The length of value in characters.  This is NOT a number in
         * bytes or logical character units.  So, the length of "abc" and
         * "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
         * should be 2.
         * </pre>
         *
         * <code>required uint32 value_length = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearValueLength() {
          bitField0_ = (bitField0_ & ~0x00000004);
          valueLength_ = 0;
          onChanged();
          return this;
        }

        private java.lang.Object key_ = "";
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @return Whether the key field is set.
         */
        public boolean hasKey() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @return The key.
         */
        public java.lang.String getKey() {
          java.lang.Object ref = key_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              key_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @return The bytes for key.
         */
        public com.google.protobuf.ByteString
            getKeyBytes() {
          java.lang.Object ref = key_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            key_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @param value The key to set.
         * @return This builder for chaining.
         */
        public Builder setKey(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          key_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearKey() {
          key_ = getDefaultInstance().getKey();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Source of the value.  It is almost always the reading of the value.
         * </pre>
         *
         * <code>optional string key = 6;</code>
         * @param value The bytes for key to set.
         * @return This builder for chaining.
         */
        public Builder setKeyBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          key_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.commands.Preedit.Segment)
      }

      // @@protoc_insertion_point(class_scope:mozc.commands.Preedit.Segment)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<Segment>
          PARSER = new com.google.protobuf.AbstractParser<Segment>() {
        @java.lang.Override
        public Segment parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Segment> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Segment> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int CURSOR_FIELD_NUMBER = 1;
    private int cursor_ = 0;
    /**
     * <code>required uint32 cursor = 1;</code>
     * @return Whether the cursor field is set.
     */
    @java.lang.Override
    public boolean hasCursor() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required uint32 cursor = 1;</code>
     * @return The cursor.
     */
    @java.lang.Override
    public int getCursor() {
      return cursor_;
    }

    public static final int SEGMENT_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> segment_;
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> getSegmentList() {
      return segment_;
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder> 
        getSegmentOrBuilderList() {
      return segment_;
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    @java.lang.Override
    public int getSegmentCount() {
      return segment_.size();
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getSegment(int index) {
      return segment_.get(index);
    }
    /**
     * <code>repeated group Segment = 2 { ... }</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder getSegmentOrBuilder(
        int index) {
      return segment_.get(index);
    }

    public static final int HIGHLIGHTED_POSITION_FIELD_NUMBER = 3;
    private int highlightedPosition_ = 0;
    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     * @return Whether the highlightedPosition field is set.
     */
    @java.lang.Override
    public boolean hasHighlightedPosition() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
     * if there are no such segments.
     * </pre>
     *
     * <code>optional uint32 highlighted_position = 3;</code>
     * @return The highlightedPosition.
     */
    @java.lang.Override
    public int getHighlightedPosition() {
      return highlightedPosition_;
    }

    public static final int IS_TOGGLEABLE_FIELD_NUMBER = 4;
    private boolean isToggleable_ = false;
    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     * @return Whether the isToggleable field is set.
     */
    @java.lang.Override
    public boolean hasIsToggleable() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * This flag is set to true if the character at the cursor position
     * is in toggleable state.  For example, when the table is
     * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
     * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
     * flag is true during this cycle.  This state is reset when user
     * types another key or SessionCommand::STOP_KEY_TOGGLING is
     * received.
     * </pre>
     *
     * <code>optional bool is_toggleable = 4 [default = false];</code>
     * @return The isToggleable.
     */
    @java.lang.Override
    public boolean getIsToggleable() {
      return isToggleable_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasCursor()) {
        memoizedIsInitialized = 0;
        return false;
      }
      for (int i = 0; i < getSegmentCount(); i++) {
        if (!getSegment(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(1, cursor_);
      }
      for (int i = 0; i < segment_.size(); i++) {
        output.writeGroup(2, segment_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt32(3, highlightedPosition_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(4, isToggleable_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, cursor_);
      }
      for (int i = 0; i < segment_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeGroupSize(2, segment_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, highlightedPosition_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, isToggleable_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit) obj;

      if (hasCursor() != other.hasCursor()) return false;
      if (hasCursor()) {
        if (getCursor()
            != other.getCursor()) return false;
      }
      if (!getSegmentList()
          .equals(other.getSegmentList())) return false;
      if (hasHighlightedPosition() != other.hasHighlightedPosition()) return false;
      if (hasHighlightedPosition()) {
        if (getHighlightedPosition()
            != other.getHighlightedPosition()) return false;
      }
      if (hasIsToggleable() != other.hasIsToggleable()) return false;
      if (hasIsToggleable()) {
        if (getIsToggleable()
            != other.getIsToggleable()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCursor()) {
        hash = (37 * hash) + CURSOR_FIELD_NUMBER;
        hash = (53 * hash) + getCursor();
      }
      if (getSegmentCount() > 0) {
        hash = (37 * hash) + SEGMENT_FIELD_NUMBER;
        hash = (53 * hash) + getSegmentList().hashCode();
      }
      if (hasHighlightedPosition()) {
        hash = (37 * hash) + HIGHLIGHTED_POSITION_FIELD_NUMBER;
        hash = (53 * hash) + getHighlightedPosition();
      }
      if (hasIsToggleable()) {
        hash = (37 * hash) + IS_TOGGLEABLE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsToggleable());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Preedit represents a composition data, which is rendered on the
     * host application by the ime client.  On Japanese IME, the both
     * Preedit and Conversion statuses are represented by this message.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Preedit}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Preedit)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.PreeditOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        cursor_ = 0;
        if (segmentBuilder_ == null) {
          segment_ = java.util.Collections.emptyList();
        } else {
          segment_ = null;
          segmentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        highlightedPosition_ = 0;
        isToggleable_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Preedit_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit result) {
        if (segmentBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            segment_ = java.util.Collections.unmodifiableList(segment_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.segment_ = segment_;
        } else {
          result.segment_ = segmentBuilder_.build();
        }
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.cursor_ = cursor_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.highlightedPosition_ = highlightedPosition_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.isToggleable_ = isToggleable_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.getDefaultInstance()) return this;
        if (other.hasCursor()) {
          setCursor(other.getCursor());
        }
        if (segmentBuilder_ == null) {
          if (!other.segment_.isEmpty()) {
            if (segment_.isEmpty()) {
              segment_ = other.segment_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureSegmentIsMutable();
              segment_.addAll(other.segment_);
            }
            onChanged();
          }
        } else {
          if (!other.segment_.isEmpty()) {
            if (segmentBuilder_.isEmpty()) {
              segmentBuilder_.dispose();
              segmentBuilder_ = null;
              segment_ = other.segment_;
              bitField0_ = (bitField0_ & ~0x00000002);
              segmentBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSegmentFieldBuilder() : null;
            } else {
              segmentBuilder_.addAllMessages(other.segment_);
            }
          }
        }
        if (other.hasHighlightedPosition()) {
          setHighlightedPosition(other.getHighlightedPosition());
        }
        if (other.hasIsToggleable()) {
          setIsToggleable(other.getIsToggleable());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasCursor()) {
          return false;
        }
        for (int i = 0; i < getSegmentCount(); i++) {
          if (!getSegment(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                cursor_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 19: {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment m =
                    input.readGroup(2,
                        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.PARSER,
                        extensionRegistry);
                if (segmentBuilder_ == null) {
                  ensureSegmentIsMutable();
                  segment_.add(m);
                } else {
                  segmentBuilder_.addMessage(m);
                }
                break;
              } // case 19
              case 24: {
                highlightedPosition_ = input.readUInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                isToggleable_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int cursor_ ;
      /**
       * <code>required uint32 cursor = 1;</code>
       * @return Whether the cursor field is set.
       */
      @java.lang.Override
      public boolean hasCursor() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required uint32 cursor = 1;</code>
       * @return The cursor.
       */
      @java.lang.Override
      public int getCursor() {
        return cursor_;
      }
      /**
       * <code>required uint32 cursor = 1;</code>
       * @param value The cursor to set.
       * @return This builder for chaining.
       */
      public Builder setCursor(int value) {
        
        cursor_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>required uint32 cursor = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCursor() {
        bitField0_ = (bitField0_ & ~0x00000001);
        cursor_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> segment_ =
        java.util.Collections.emptyList();
      private void ensureSegmentIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          segment_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment>(segment_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder> segmentBuilder_;

      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> getSegmentList() {
        if (segmentBuilder_ == null) {
          return java.util.Collections.unmodifiableList(segment_);
        } else {
          return segmentBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public int getSegmentCount() {
        if (segmentBuilder_ == null) {
          return segment_.size();
        } else {
          return segmentBuilder_.getCount();
        }
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment getSegment(int index) {
        if (segmentBuilder_ == null) {
          return segment_.get(index);
        } else {
          return segmentBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder setSegment(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment value) {
        if (segmentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSegmentIsMutable();
          segment_.set(index, value);
          onChanged();
        } else {
          segmentBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder setSegment(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder builderForValue) {
        if (segmentBuilder_ == null) {
          ensureSegmentIsMutable();
          segment_.set(index, builderForValue.build());
          onChanged();
        } else {
          segmentBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addSegment(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment value) {
        if (segmentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSegmentIsMutable();
          segment_.add(value);
          onChanged();
        } else {
          segmentBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addSegment(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment value) {
        if (segmentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSegmentIsMutable();
          segment_.add(index, value);
          onChanged();
        } else {
          segmentBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addSegment(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder builderForValue) {
        if (segmentBuilder_ == null) {
          ensureSegmentIsMutable();
          segment_.add(builderForValue.build());
          onChanged();
        } else {
          segmentBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addSegment(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder builderForValue) {
        if (segmentBuilder_ == null) {
          ensureSegmentIsMutable();
          segment_.add(index, builderForValue.build());
          onChanged();
        } else {
          segmentBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder addAllSegment(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment> values) {
        if (segmentBuilder_ == null) {
          ensureSegmentIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, segment_);
          onChanged();
        } else {
          segmentBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder clearSegment() {
        if (segmentBuilder_ == null) {
          segment_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          segmentBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public Builder removeSegment(int index) {
        if (segmentBuilder_ == null) {
          ensureSegmentIsMutable();
          segment_.remove(index);
          onChanged();
        } else {
          segmentBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder getSegmentBuilder(
          int index) {
        return getSegmentFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder getSegmentOrBuilder(
          int index) {
        if (segmentBuilder_ == null) {
          return segment_.get(index);  } else {
          return segmentBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder> 
           getSegmentOrBuilderList() {
        if (segmentBuilder_ != null) {
          return segmentBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(segment_);
        }
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder addSegmentBuilder() {
        return getSegmentFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.getDefaultInstance());
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder addSegmentBuilder(
          int index) {
        return getSegmentFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.getDefaultInstance());
      }
      /**
       * <code>repeated group Segment = 2 { ... }</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder> 
           getSegmentBuilderList() {
        return getSegmentFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder> 
          getSegmentFieldBuilder() {
        if (segmentBuilder_ == null) {
          segmentBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Segment.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.SegmentOrBuilder>(
                  segment_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          segment_ = null;
        }
        return segmentBuilder_;
      }

      private int highlightedPosition_ ;
      /**
       * <pre>
       * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
       * if there are no such segments.
       * </pre>
       *
       * <code>optional uint32 highlighted_position = 3;</code>
       * @return Whether the highlightedPosition field is set.
       */
      @java.lang.Override
      public boolean hasHighlightedPosition() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
       * if there are no such segments.
       * </pre>
       *
       * <code>optional uint32 highlighted_position = 3;</code>
       * @return The highlightedPosition.
       */
      @java.lang.Override
      public int getHighlightedPosition() {
        return highlightedPosition_;
      }
      /**
       * <pre>
       * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
       * if there are no such segments.
       * </pre>
       *
       * <code>optional uint32 highlighted_position = 3;</code>
       * @param value The highlightedPosition to set.
       * @return This builder for chaining.
       */
      public Builder setHighlightedPosition(int value) {
        
        highlightedPosition_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
       * if there are no such segments.
       * </pre>
       *
       * <code>optional uint32 highlighted_position = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearHighlightedPosition() {
        bitField0_ = (bitField0_ & ~0x00000004);
        highlightedPosition_ = 0;
        onChanged();
        return this;
      }

      private boolean isToggleable_ ;
      /**
       * <pre>
       * This flag is set to true if the character at the cursor position
       * is in toggleable state.  For example, when the table is
       * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
       * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
       * flag is true during this cycle.  This state is reset when user
       * types another key or SessionCommand::STOP_KEY_TOGGLING is
       * received.
       * </pre>
       *
       * <code>optional bool is_toggleable = 4 [default = false];</code>
       * @return Whether the isToggleable field is set.
       */
      @java.lang.Override
      public boolean hasIsToggleable() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * This flag is set to true if the character at the cursor position
       * is in toggleable state.  For example, when the table is
       * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
       * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
       * flag is true during this cycle.  This state is reset when user
       * types another key or SessionCommand::STOP_KEY_TOGGLING is
       * received.
       * </pre>
       *
       * <code>optional bool is_toggleable = 4 [default = false];</code>
       * @return The isToggleable.
       */
      @java.lang.Override
      public boolean getIsToggleable() {
        return isToggleable_;
      }
      /**
       * <pre>
       * This flag is set to true if the character at the cursor position
       * is in toggleable state.  For example, when the table is
       * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
       * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
       * flag is true during this cycle.  This state is reset when user
       * types another key or SessionCommand::STOP_KEY_TOGGLING is
       * received.
       * </pre>
       *
       * <code>optional bool is_toggleable = 4 [default = false];</code>
       * @param value The isToggleable to set.
       * @return This builder for chaining.
       */
      public Builder setIsToggleable(boolean value) {
        
        isToggleable_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This flag is set to true if the character at the cursor position
       * is in toggleable state.  For example, when the table is
       * TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
       * repeatedly, the preedit toggles like あ -&gt; い -&gt; う -&gt; ....  This
       * flag is true during this cycle.  This state is reset when user
       * types another key or SessionCommand::STOP_KEY_TOGGLING is
       * received.
       * </pre>
       *
       * <code>optional bool is_toggleable = 4 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIsToggleable() {
        bitField0_ = (bitField0_ & ~0x00000008);
        isToggleable_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.Preedit)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.Preedit)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Preedit>
        PARSER = new com.google.protobuf.AbstractParser<Preedit>() {
      @java.lang.Override
      public Preedit parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Preedit> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Preedit> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Status)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     * @return Whether the activated field is set.
     */
    boolean hasActivated();
    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     * @return The activated.
     */
    boolean getActivated();

    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return Whether the mode field is set.
     */
    boolean hasMode();
    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return The mode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode();

    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     * @return Whether the comebackMode field is set.
     */
    boolean hasComebackMode();
    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     * @return The comebackMode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getComebackMode();

    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     * @return Whether the undoAvailable field is set.
     */
    boolean hasUndoAvailable();
    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     * @return The undoAvailable.
     */
    boolean getUndoAvailable();
  }
  /**
   * Protobuf type {@code mozc.commands.Status}
   */
  public static final class Status extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Status)
      StatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Status.newBuilder() to construct.
    private Status(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Status() {
      mode_ = 0;
      comebackMode_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Status();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Status_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Status_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.Builder.class);
    }

    private int bitField0_;
    public static final int ACTIVATED_FIELD_NUMBER = 1;
    private boolean activated_ = false;
    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     * @return Whether the activated field is set.
     */
    @java.lang.Override
    public boolean hasActivated() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Whether IME is ON or OFF
     * </pre>
     *
     * <code>optional bool activated = 1;</code>
     * @return The activated.
     */
    @java.lang.Override
    public boolean getActivated() {
      return activated_;
    }

    public static final int MODE_FIELD_NUMBER = 2;
    private int mode_ = 0;
    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return Whether the mode field is set.
     */
    @java.lang.Override public boolean hasMode() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Visible composition mode when IME is activated. This mode may come from a
     * temporary composition mode. See |comeback_mode|.
     * TODO(yukawa): Rename this field to "visible_mode".
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return The mode.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(mode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }

    public static final int COMEBACK_MODE_FIELD_NUMBER = 3;
    private int comebackMode_ = 0;
    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     * @return Whether the comebackMode field is set.
     */
    @java.lang.Override public boolean hasComebackMode() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * True composition mode that is suitable for system global and permanent
     * composition mode. When a temporary composition mode exists,
     * |comeback_mode| can be different from |mode|.
     * TODO(yukawa): Use more appropriate name.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
     * @return The comebackMode.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getComebackMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(comebackMode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }

    public static final int UNDO_AVAILABLE_FIELD_NUMBER = 26;
    private boolean undoAvailable_ = false;
    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     * @return Whether the undoAvailable field is set.
     */
    @java.lang.Override
    public boolean hasUndoAvailable() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Whether Undo operation is available.
     * The client may enable/disable the Undo key based on this value.
     * </pre>
     *
     * <code>optional bool undo_available = 26;</code>
     * @return The undoAvailable.
     */
    @java.lang.Override
    public boolean getUndoAvailable() {
      return undoAvailable_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(1, activated_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeEnum(2, mode_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeEnum(3, comebackMode_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(26, undoAvailable_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, activated_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, mode_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, comebackMode_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(26, undoAvailable_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status) obj;

      if (hasActivated() != other.hasActivated()) return false;
      if (hasActivated()) {
        if (getActivated()
            != other.getActivated()) return false;
      }
      if (hasMode() != other.hasMode()) return false;
      if (hasMode()) {
        if (mode_ != other.mode_) return false;
      }
      if (hasComebackMode() != other.hasComebackMode()) return false;
      if (hasComebackMode()) {
        if (comebackMode_ != other.comebackMode_) return false;
      }
      if (hasUndoAvailable() != other.hasUndoAvailable()) return false;
      if (hasUndoAvailable()) {
        if (getUndoAvailable()
            != other.getUndoAvailable()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasActivated()) {
        hash = (37 * hash) + ACTIVATED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getActivated());
      }
      if (hasMode()) {
        hash = (37 * hash) + MODE_FIELD_NUMBER;
        hash = (53 * hash) + mode_;
      }
      if (hasComebackMode()) {
        hash = (37 * hash) + COMEBACK_MODE_FIELD_NUMBER;
        hash = (53 * hash) + comebackMode_;
      }
      if (hasUndoAvailable()) {
        hash = (37 * hash) + UNDO_AVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUndoAvailable());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.commands.Status}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Status)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.StatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Status_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Status_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        activated_ = false;
        mode_ = 0;
        comebackMode_ = 0;
        undoAvailable_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Status_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.activated_ = activated_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.mode_ = mode_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.comebackMode_ = comebackMode_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.undoAvailable_ = undoAvailable_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.getDefaultInstance()) return this;
        if (other.hasActivated()) {
          setActivated(other.getActivated());
        }
        if (other.hasMode()) {
          setMode(other.getMode());
        }
        if (other.hasComebackMode()) {
          setComebackMode(other.getComebackMode());
        }
        if (other.hasUndoAvailable()) {
          setUndoAvailable(other.getUndoAvailable());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                activated_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(2, tmpRaw);
                } else {
                  mode_ = tmpRaw;
                  bitField0_ |= 0x00000002;
                }
                break;
              } // case 16
              case 24: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(3, tmpRaw);
                } else {
                  comebackMode_ = tmpRaw;
                  bitField0_ |= 0x00000004;
                }
                break;
              } // case 24
              case 208: {
                undoAvailable_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 208
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean activated_ ;
      /**
       * <pre>
       * Whether IME is ON or OFF
       * </pre>
       *
       * <code>optional bool activated = 1;</code>
       * @return Whether the activated field is set.
       */
      @java.lang.Override
      public boolean hasActivated() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Whether IME is ON or OFF
       * </pre>
       *
       * <code>optional bool activated = 1;</code>
       * @return The activated.
       */
      @java.lang.Override
      public boolean getActivated() {
        return activated_;
      }
      /**
       * <pre>
       * Whether IME is ON or OFF
       * </pre>
       *
       * <code>optional bool activated = 1;</code>
       * @param value The activated to set.
       * @return This builder for chaining.
       */
      public Builder setActivated(boolean value) {
        
        activated_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether IME is ON or OFF
       * </pre>
       *
       * <code>optional bool activated = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearActivated() {
        bitField0_ = (bitField0_ & ~0x00000001);
        activated_ = false;
        onChanged();
        return this;
      }

      private int mode_ = 0;
      /**
       * <pre>
       * Visible composition mode when IME is activated. This mode may come from a
       * temporary composition mode. See |comeback_mode|.
       * TODO(yukawa): Rename this field to "visible_mode".
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return Whether the mode field is set.
       */
      @java.lang.Override public boolean hasMode() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Visible composition mode when IME is activated. This mode may come from a
       * temporary composition mode. See |comeback_mode|.
       * TODO(yukawa): Rename this field to "visible_mode".
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return The mode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(mode_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
      }
      /**
       * <pre>
       * Visible composition mode when IME is activated. This mode may come from a
       * temporary composition mode. See |comeback_mode|.
       * TODO(yukawa): Rename this field to "visible_mode".
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @param value The mode to set.
       * @return This builder for chaining.
       */
      public Builder setMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        mode_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Visible composition mode when IME is activated. This mode may come from a
       * temporary composition mode. See |comeback_mode|.
       * TODO(yukawa): Rename this field to "visible_mode".
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMode() {
        bitField0_ = (bitField0_ & ~0x00000002);
        mode_ = 0;
        onChanged();
        return this;
      }

      private int comebackMode_ = 0;
      /**
       * <pre>
       * True composition mode that is suitable for system global and permanent
       * composition mode. When a temporary composition mode exists,
       * |comeback_mode| can be different from |mode|.
       * TODO(yukawa): Use more appropriate name.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
       * @return Whether the comebackMode field is set.
       */
      @java.lang.Override public boolean hasComebackMode() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * True composition mode that is suitable for system global and permanent
       * composition mode. When a temporary composition mode exists,
       * |comeback_mode| can be different from |mode|.
       * TODO(yukawa): Use more appropriate name.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
       * @return The comebackMode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getComebackMode() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(comebackMode_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
      }
      /**
       * <pre>
       * True composition mode that is suitable for system global and permanent
       * composition mode. When a temporary composition mode exists,
       * |comeback_mode| can be different from |mode|.
       * TODO(yukawa): Use more appropriate name.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
       * @param value The comebackMode to set.
       * @return This builder for chaining.
       */
      public Builder setComebackMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        comebackMode_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * True composition mode that is suitable for system global and permanent
       * composition mode. When a temporary composition mode exists,
       * |comeback_mode| can be different from |mode|.
       * TODO(yukawa): Use more appropriate name.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode comeback_mode = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearComebackMode() {
        bitField0_ = (bitField0_ & ~0x00000004);
        comebackMode_ = 0;
        onChanged();
        return this;
      }

      private boolean undoAvailable_ ;
      /**
       * <pre>
       * Whether Undo operation is available.
       * The client may enable/disable the Undo key based on this value.
       * </pre>
       *
       * <code>optional bool undo_available = 26;</code>
       * @return Whether the undoAvailable field is set.
       */
      @java.lang.Override
      public boolean hasUndoAvailable() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Whether Undo operation is available.
       * The client may enable/disable the Undo key based on this value.
       * </pre>
       *
       * <code>optional bool undo_available = 26;</code>
       * @return The undoAvailable.
       */
      @java.lang.Override
      public boolean getUndoAvailable() {
        return undoAvailable_;
      }
      /**
       * <pre>
       * Whether Undo operation is available.
       * The client may enable/disable the Undo key based on this value.
       * </pre>
       *
       * <code>optional bool undo_available = 26;</code>
       * @param value The undoAvailable to set.
       * @return This builder for chaining.
       */
      public Builder setUndoAvailable(boolean value) {
        
        undoAvailable_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether Undo operation is available.
       * The client may enable/disable the Undo key based on this value.
       * </pre>
       *
       * <code>optional bool undo_available = 26;</code>
       * @return This builder for chaining.
       */
      public Builder clearUndoAvailable() {
        bitField0_ = (bitField0_ & ~0x00000008);
        undoAvailable_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.Status)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.Status)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Status>
        PARSER = new com.google.protobuf.AbstractParser<Status>() {
      @java.lang.Override
      public Status parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Status> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Status> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeletionRangeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.DeletionRange)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     * @return Whether the offset field is set.
     */
    boolean hasOffset();
    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     * @return The offset.
     */
    int getOffset();

    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     * @return Whether the length field is set.
     */
    boolean hasLength();
    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     * @return The length.
     */
    int getLength();
  }
  /**
   * <pre>
   * This message contains which characters are to be deleted by client.
   * E.g. if current composition and surrounding text are
   *     "この感じは[漢字は]" ("漢字は" is the composition)
   * and we send DeletionRange with offset == -3 and length == 3, then they will
   * be rendered like:
   *     "この[漢字は]"
   * </pre>
   *
   * Protobuf type {@code mozc.commands.DeletionRange}
   */
  public static final class DeletionRange extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.DeletionRange)
      DeletionRangeOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeletionRange.newBuilder() to construct.
    private DeletionRange(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeletionRange() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DeletionRange();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DeletionRange_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DeletionRange_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.Builder.class);
    }

    private int bitField0_;
    public static final int OFFSET_FIELD_NUMBER = 1;
    private int offset_ = 0;
    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     * @return Whether the offset field is set.
     */
    @java.lang.Override
    public boolean hasOffset() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Offset of start of the deletion range.
     * Right now,
     * - Only nagative value is expected.
     *     In this case, the offset is counted from the beginning of the
     *     composition (see the message comment right above).
     * - Positive or 0 value is not sent.
     *     But not forbidden.
     *     Though its expectation is not decided yet,
     *     the client implementation should be prepared (at least, don't crash).
     * </pre>
     *
     * <code>optional int32 offset = 1;</code>
     * @return The offset.
     */
    @java.lang.Override
    public int getOffset() {
      return offset_;
    }

    public static final int LENGTH_FIELD_NUMBER = 2;
    private int length_ = 0;
    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     * @return Whether the length field is set.
     */
    @java.lang.Override
    public boolean hasLength() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Length of the range.
     * Right now offset==abs(length) is expected.
     * The expectation where the above condition doesn't meet
     * is not defined yet.
     * This may be defined in future (when positive offset becomes
     * supported?).
     * </pre>
     *
     * <code>optional int32 length = 2;</code>
     * @return The length.
     */
    @java.lang.Override
    public int getLength() {
      return length_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, offset_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, length_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, offset_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, length_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange) obj;

      if (hasOffset() != other.hasOffset()) return false;
      if (hasOffset()) {
        if (getOffset()
            != other.getOffset()) return false;
      }
      if (hasLength() != other.hasLength()) return false;
      if (hasLength()) {
        if (getLength()
            != other.getLength()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasOffset()) {
        hash = (37 * hash) + OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + getOffset();
      }
      if (hasLength()) {
        hash = (37 * hash) + LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + getLength();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * This message contains which characters are to be deleted by client.
     * E.g. if current composition and surrounding text are
     *     "この感じは[漢字は]" ("漢字は" is the composition)
     * and we send DeletionRange with offset == -3 and length == 3, then they will
     * be rendered like:
     *     "この[漢字は]"
     * </pre>
     *
     * Protobuf type {@code mozc.commands.DeletionRange}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.DeletionRange)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRangeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DeletionRange_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DeletionRange_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        offset_ = 0;
        length_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_DeletionRange_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.offset_ = offset_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.length_ = length_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.getDefaultInstance()) return this;
        if (other.hasOffset()) {
          setOffset(other.getOffset());
        }
        if (other.hasLength()) {
          setLength(other.getLength());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                offset_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                length_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int offset_ ;
      /**
       * <pre>
       * Offset of start of the deletion range.
       * Right now,
       * - Only nagative value is expected.
       *     In this case, the offset is counted from the beginning of the
       *     composition (see the message comment right above).
       * - Positive or 0 value is not sent.
       *     But not forbidden.
       *     Though its expectation is not decided yet,
       *     the client implementation should be prepared (at least, don't crash).
       * </pre>
       *
       * <code>optional int32 offset = 1;</code>
       * @return Whether the offset field is set.
       */
      @java.lang.Override
      public boolean hasOffset() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Offset of start of the deletion range.
       * Right now,
       * - Only nagative value is expected.
       *     In this case, the offset is counted from the beginning of the
       *     composition (see the message comment right above).
       * - Positive or 0 value is not sent.
       *     But not forbidden.
       *     Though its expectation is not decided yet,
       *     the client implementation should be prepared (at least, don't crash).
       * </pre>
       *
       * <code>optional int32 offset = 1;</code>
       * @return The offset.
       */
      @java.lang.Override
      public int getOffset() {
        return offset_;
      }
      /**
       * <pre>
       * Offset of start of the deletion range.
       * Right now,
       * - Only nagative value is expected.
       *     In this case, the offset is counted from the beginning of the
       *     composition (see the message comment right above).
       * - Positive or 0 value is not sent.
       *     But not forbidden.
       *     Though its expectation is not decided yet,
       *     the client implementation should be prepared (at least, don't crash).
       * </pre>
       *
       * <code>optional int32 offset = 1;</code>
       * @param value The offset to set.
       * @return This builder for chaining.
       */
      public Builder setOffset(int value) {
        
        offset_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Offset of start of the deletion range.
       * Right now,
       * - Only nagative value is expected.
       *     In this case, the offset is counted from the beginning of the
       *     composition (see the message comment right above).
       * - Positive or 0 value is not sent.
       *     But not forbidden.
       *     Though its expectation is not decided yet,
       *     the client implementation should be prepared (at least, don't crash).
       * </pre>
       *
       * <code>optional int32 offset = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearOffset() {
        bitField0_ = (bitField0_ & ~0x00000001);
        offset_ = 0;
        onChanged();
        return this;
      }

      private int length_ ;
      /**
       * <pre>
       * Length of the range.
       * Right now offset==abs(length) is expected.
       * The expectation where the above condition doesn't meet
       * is not defined yet.
       * This may be defined in future (when positive offset becomes
       * supported?).
       * </pre>
       *
       * <code>optional int32 length = 2;</code>
       * @return Whether the length field is set.
       */
      @java.lang.Override
      public boolean hasLength() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Length of the range.
       * Right now offset==abs(length) is expected.
       * The expectation where the above condition doesn't meet
       * is not defined yet.
       * This may be defined in future (when positive offset becomes
       * supported?).
       * </pre>
       *
       * <code>optional int32 length = 2;</code>
       * @return The length.
       */
      @java.lang.Override
      public int getLength() {
        return length_;
      }
      /**
       * <pre>
       * Length of the range.
       * Right now offset==abs(length) is expected.
       * The expectation where the above condition doesn't meet
       * is not defined yet.
       * This may be defined in future (when positive offset becomes
       * supported?).
       * </pre>
       *
       * <code>optional int32 length = 2;</code>
       * @param value The length to set.
       * @return This builder for chaining.
       */
      public Builder setLength(int value) {
        
        length_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Length of the range.
       * Right now offset==abs(length) is expected.
       * The expectation where the above condition doesn't meet
       * is not defined yet.
       * This may be defined in future (when positive offset becomes
       * supported?).
       * </pre>
       *
       * <code>optional int32 length = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLength() {
        bitField0_ = (bitField0_ & ~0x00000002);
        length_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.DeletionRange)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.DeletionRange)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DeletionRange>
        PARSER = new com.google.protobuf.AbstractParser<DeletionRange>() {
      @java.lang.Override
      public DeletionRange parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeletionRange> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeletionRange> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OutputOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Output)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     * @return Whether the id field is set.
     */
    boolean hasId();
    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     * @return The id.
     */
    long getId();

    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return Whether the mode field is set.
     */
    boolean hasMode();
    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return The mode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode();

    /**
     * <code>optional bool consumed = 3;</code>
     * @return Whether the consumed field is set.
     */
    boolean hasConsumed();
    /**
     * <code>optional bool consumed = 3;</code>
     * @return The consumed.
     */
    boolean getConsumed();

    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     * @return Whether the result field is set.
     */
    boolean hasResult();
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     * @return The result.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getResult();
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultOrBuilder getResultOrBuilder();

    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     * @return Whether the preedit field is set.
     */
    boolean hasPreedit();
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     * @return The preedit.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getPreedit();
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.PreeditOrBuilder getPreeditOrBuilder();

    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     * @return Whether the candidateWindow field is set.
     */
    boolean hasCandidateWindow();
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     * @return The candidateWindow.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow getCandidateWindow();
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindowOrBuilder getCandidateWindowOrBuilder();

    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     * @return The key.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey();
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder getKeyOrBuilder();

    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return Whether the url field is set.
     */
    boolean hasUrl();
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return The url.
     */
    java.lang.String getUrl();
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return The bytes for url.
     */
    com.google.protobuf.ByteString
        getUrlBytes();

    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     * @return Whether the config field is set.
     */
    boolean hasConfig();
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     * @return The config.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig();
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder getConfigOrBuilder();

    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     * @return Whether the preeditMethod field is set.
     */
    boolean hasPreeditMethod();
    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     * @return The preeditMethod.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod getPreeditMethod();

    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     * @return Whether the errorCode field is set.
     */
    boolean hasErrorCode();
    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     * @return The errorCode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode getErrorCode();

    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     * @return Whether the status field is set.
     */
    boolean hasStatus();
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     * @return The status.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getStatus();
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.StatusOrBuilder getStatusOrBuilder();

    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     * @return Whether the allCandidateWords field is set.
     */
    boolean hasAllCandidateWords();
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     * @return The allCandidateWords.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getAllCandidateWords();
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder getAllCandidateWordsOrBuilder();

    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     * @return Whether the deletionRange field is set.
     */
    boolean hasDeletionRange();
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     * @return The deletionRange.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDeletionRange();
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRangeOrBuilder getDeletionRangeOrBuilder();

    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     * @return Whether the launchToolMode field is set.
     */
    boolean hasLaunchToolMode();
    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     * @return The launchToolMode.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode getLaunchToolMode();

    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     * @return Whether the callback field is set.
     */
    boolean hasCallback();
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     * @return The callback.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getCallback();
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.CallbackOrBuilder getCallbackOrBuilder();

    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
     * @return Whether the userDictionaryCommandStatus field is set.
     */
    boolean hasUserDictionaryCommandStatus();
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
     * @return The userDictionaryCommandStatus.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus getUserDictionaryCommandStatus();
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatusOrBuilder getUserDictionaryCommandStatusOrBuilder();

    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     * @return Whether the engineReloadResponse field is set.
     */
    boolean hasEngineReloadResponse();
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     * @return The engineReloadResponse.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse getEngineReloadResponse();
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponseOrBuilder getEngineReloadResponseOrBuilder();

    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     * @return Whether the removedCandidateWordsForDebug field is set.
     */
    boolean hasRemovedCandidateWordsForDebug();
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     * @return The removedCandidateWordsForDebug.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getRemovedCandidateWordsForDebug();
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder getRemovedCandidateWordsForDebugOrBuilder();

    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     * @return Whether the incognitoCandidateWords field is set.
     */
    boolean hasIncognitoCandidateWords();
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     * @return The incognitoCandidateWords.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getIncognitoCandidateWords();
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder getIncognitoCandidateWordsOrBuilder();

    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     * @return Whether the serverVersion field is set.
     */
    boolean hasServerVersion();
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     * @return The serverVersion.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getServerVersion();
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfoOrBuilder getServerVersionOrBuilder();
  }
  /**
   * <pre>
   * Next ID: 27
   * </pre>
   *
   * Protobuf type {@code mozc.commands.Output}
   */
  public static final class Output extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Output)
      OutputOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Output.newBuilder() to construct.
    private Output(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Output() {
      mode_ = 0;
      url_ = "";
      preeditMethod_ = 0;
      errorCode_ = 0;
      launchToolMode_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Output();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Builder.class);
    }

    /**
     * <pre>
     * PreeditMethod: this is the default input mode of the session.
     * If the user's config is "kana-input", it returns KANA.  Only
     * CreateSession response will have this field.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Output.PreeditMethod}
     */
    public enum PreeditMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>ASCII = 0;</code>
       */
      ASCII(0),
      /**
       * <code>KANA = 1;</code>
       */
      KANA(1),
      ;

      /**
       * <code>ASCII = 0;</code>
       */
      public static final int ASCII_VALUE = 0;
      /**
       * <code>KANA = 1;</code>
       */
      public static final int KANA_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PreeditMethod valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static PreeditMethod forNumber(int value) {
        switch (value) {
          case 0: return ASCII;
          case 1: return KANA;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PreeditMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>() {
              public PreeditMethod findValueByNumber(int number) {
                return PreeditMethod.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDescriptor().getEnumTypes().get(0);
      }

      private static final PreeditMethod[] VALUES = values();

      public static PreeditMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private PreeditMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Output.PreeditMethod)
    }

    /**
     * <pre>
     * ErrorCode:
     * if SessionHandler::EvalCommand() returns false,
     * return output with error_code = SESSION_FAILURE;
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Output.ErrorCode}
     */
    public enum ErrorCode
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>SESSION_SUCCESS = 0;</code>
       */
      SESSION_SUCCESS(0),
      /**
       * <code>SESSION_FAILURE = 1;</code>
       */
      SESSION_FAILURE(1),
      ;

      /**
       * <code>SESSION_SUCCESS = 0;</code>
       */
      public static final int SESSION_SUCCESS_VALUE = 0;
      /**
       * <code>SESSION_FAILURE = 1;</code>
       */
      public static final int SESSION_FAILURE_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ErrorCode valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static ErrorCode forNumber(int value) {
        switch (value) {
          case 0: return SESSION_SUCCESS;
          case 1: return SESSION_FAILURE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ErrorCode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ErrorCode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ErrorCode>() {
              public ErrorCode findValueByNumber(int number) {
                return ErrorCode.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDescriptor().getEnumTypes().get(1);
      }

      private static final ErrorCode[] VALUES = values();

      public static ErrorCode valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private ErrorCode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Output.ErrorCode)
    }

    /**
     * <pre>
     * if launch_tool_mode is set, MozcTool is supposed to be launched
     * by client.
     * </pre>
     *
     * Protobuf enum {@code mozc.commands.Output.ToolMode}
     */
    public enum ToolMode
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * no need to launch tool
       * </pre>
       *
       * <code>NO_TOOL = 0;</code>
       */
      NO_TOOL(0),
      /**
       * <code>CONFIG_DIALOG = 1;</code>
       */
      CONFIG_DIALOG(1),
      /**
       * <code>DICTIONARY_TOOL = 2;</code>
       */
      DICTIONARY_TOOL(2),
      /**
       * <code>WORD_REGISTER_DIALOG = 3;</code>
       */
      WORD_REGISTER_DIALOG(3),
      ;

      /**
       * <pre>
       * no need to launch tool
       * </pre>
       *
       * <code>NO_TOOL = 0;</code>
       */
      public static final int NO_TOOL_VALUE = 0;
      /**
       * <code>CONFIG_DIALOG = 1;</code>
       */
      public static final int CONFIG_DIALOG_VALUE = 1;
      /**
       * <code>DICTIONARY_TOOL = 2;</code>
       */
      public static final int DICTIONARY_TOOL_VALUE = 2;
      /**
       * <code>WORD_REGISTER_DIALOG = 3;</code>
       */
      public static final int WORD_REGISTER_DIALOG_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ToolMode valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static ToolMode forNumber(int value) {
        switch (value) {
          case 0: return NO_TOOL;
          case 1: return CONFIG_DIALOG;
          case 2: return DICTIONARY_TOOL;
          case 3: return WORD_REGISTER_DIALOG;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ToolMode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ToolMode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ToolMode>() {
              public ToolMode findValueByNumber(int number) {
                return ToolMode.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDescriptor().getEnumTypes().get(2);
      }

      private static final ToolMode[] VALUES = values();

      public static ToolMode valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private ToolMode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.commands.Output.ToolMode)
    }

    public interface CallbackOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Output.Callback)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       * @return Whether the sessionCommand field is set.
       */
      boolean hasSessionCommand();
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       * @return The sessionCommand.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getSessionCommand();
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder getSessionCommandOrBuilder();

      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       * @return Whether the delayMillisec field is set.
       */
      boolean hasDelayMillisec();
      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       * @return The delayMillisec.
       */
      int getDelayMillisec();
    }
    /**
     * <pre>
     * Callback request to the client.
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Output.Callback}
     */
    public static final class Callback extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Output.Callback)
        CallbackOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Callback.newBuilder() to construct.
      private Callback(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Callback() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new Callback();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_Callback_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_Callback_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.Builder.class);
      }

      private int bitField0_;
      public static final int SESSION_COMMAND_FIELD_NUMBER = 1;
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand sessionCommand_;
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       * @return Whether the sessionCommand field is set.
       */
      @java.lang.Override
      public boolean hasSessionCommand() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       * @return The sessionCommand.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getSessionCommand() {
        return sessionCommand_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : sessionCommand_;
      }
      /**
       * <pre>
       * Callback command to be sent from the client to the server.  The
       * optional values such as id and composition_mode can be modified
       * or added by the client.
       * </pre>
       *
       * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder getSessionCommandOrBuilder() {
        return sessionCommand_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : sessionCommand_;
      }

      public static final int DELAY_MILLISEC_FIELD_NUMBER = 2;
      private int delayMillisec_ = 0;
      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       * @return Whether the delayMillisec field is set.
       */
      @java.lang.Override
      public boolean hasDelayMillisec() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Callback command should be sent after this delay.
       * </pre>
       *
       * <code>optional uint32 delay_millisec = 2;</code>
       * @return The delayMillisec.
       */
      @java.lang.Override
      public int getDelayMillisec() {
        return delayMillisec_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        if (hasSessionCommand()) {
          if (!getSessionCommand().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
          }
        }
        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeMessage(1, getSessionCommand());
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeUInt32(2, delayMillisec_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getSessionCommand());
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(2, delayMillisec_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback) obj;

        if (hasSessionCommand() != other.hasSessionCommand()) return false;
        if (hasSessionCommand()) {
          if (!getSessionCommand()
              .equals(other.getSessionCommand())) return false;
        }
        if (hasDelayMillisec() != other.hasDelayMillisec()) return false;
        if (hasDelayMillisec()) {
          if (getDelayMillisec()
              != other.getDelayMillisec()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasSessionCommand()) {
          hash = (37 * hash) + SESSION_COMMAND_FIELD_NUMBER;
          hash = (53 * hash) + getSessionCommand().hashCode();
        }
        if (hasDelayMillisec()) {
          hash = (37 * hash) + DELAY_MILLISEC_FIELD_NUMBER;
          hash = (53 * hash) + getDelayMillisec();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Callback request to the client.
       * </pre>
       *
       * Protobuf type {@code mozc.commands.Output.Callback}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Output.Callback)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.CallbackOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_Callback_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_Callback_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getSessionCommandFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          sessionCommand_ = null;
          if (sessionCommandBuilder_ != null) {
            sessionCommandBuilder_.dispose();
            sessionCommandBuilder_ = null;
          }
          delayMillisec_ = 0;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_Callback_descriptor;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.getDefaultInstance();
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.sessionCommand_ = sessionCommandBuilder_ == null
                ? sessionCommand_
                : sessionCommandBuilder_.build();
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.delayMillisec_ = delayMillisec_;
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.getDefaultInstance()) return this;
          if (other.hasSessionCommand()) {
            mergeSessionCommand(other.getSessionCommand());
          }
          if (other.hasDelayMillisec()) {
            setDelayMillisec(other.getDelayMillisec());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          if (hasSessionCommand()) {
            if (!getSessionCommand().isInitialized()) {
              return false;
            }
          }
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  input.readMessage(
                      getSessionCommandFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 16: {
                  delayMillisec_ = input.readUInt32();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand sessionCommand_;
        private com.google.protobuf.SingleFieldBuilderV3<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder> sessionCommandBuilder_;
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         * @return Whether the sessionCommand field is set.
         */
        public boolean hasSessionCommand() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         * @return The sessionCommand.
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand getSessionCommand() {
          if (sessionCommandBuilder_ == null) {
            return sessionCommand_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : sessionCommand_;
          } else {
            return sessionCommandBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public Builder setSessionCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
          if (sessionCommandBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            sessionCommand_ = value;
          } else {
            sessionCommandBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public Builder setSessionCommand(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder builderForValue) {
          if (sessionCommandBuilder_ == null) {
            sessionCommand_ = builderForValue.build();
          } else {
            sessionCommandBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public Builder mergeSessionCommand(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand value) {
          if (sessionCommandBuilder_ == null) {
            if (((bitField0_ & 0x00000001) != 0) &&
              sessionCommand_ != null &&
              sessionCommand_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance()) {
              getSessionCommandBuilder().mergeFrom(value);
            } else {
              sessionCommand_ = value;
            }
          } else {
            sessionCommandBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public Builder clearSessionCommand() {
          bitField0_ = (bitField0_ & ~0x00000001);
          sessionCommand_ = null;
          if (sessionCommandBuilder_ != null) {
            sessionCommandBuilder_.dispose();
            sessionCommandBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder getSessionCommandBuilder() {
          bitField0_ |= 0x00000001;
          onChanged();
          return getSessionCommandFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder getSessionCommandOrBuilder() {
          if (sessionCommandBuilder_ != null) {
            return sessionCommandBuilder_.getMessageOrBuilder();
          } else {
            return sessionCommand_ == null ?
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.getDefaultInstance() : sessionCommand_;
          }
        }
        /**
         * <pre>
         * Callback command to be sent from the client to the server.  The
         * optional values such as id and composition_mode can be modified
         * or added by the client.
         * </pre>
         *
         * <code>optional .mozc.commands.SessionCommand session_command = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder> 
            getSessionCommandFieldBuilder() {
          if (sessionCommandBuilder_ == null) {
            sessionCommandBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommand.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.SessionCommandOrBuilder>(
                    getSessionCommand(),
                    getParentForChildren(),
                    isClean());
            sessionCommand_ = null;
          }
          return sessionCommandBuilder_;
        }

        private int delayMillisec_ ;
        /**
         * <pre>
         * Callback command should be sent after this delay.
         * </pre>
         *
         * <code>optional uint32 delay_millisec = 2;</code>
         * @return Whether the delayMillisec field is set.
         */
        @java.lang.Override
        public boolean hasDelayMillisec() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Callback command should be sent after this delay.
         * </pre>
         *
         * <code>optional uint32 delay_millisec = 2;</code>
         * @return The delayMillisec.
         */
        @java.lang.Override
        public int getDelayMillisec() {
          return delayMillisec_;
        }
        /**
         * <pre>
         * Callback command should be sent after this delay.
         * </pre>
         *
         * <code>optional uint32 delay_millisec = 2;</code>
         * @param value The delayMillisec to set.
         * @return This builder for chaining.
         */
        public Builder setDelayMillisec(int value) {
          
          delayMillisec_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Callback command should be sent after this delay.
         * </pre>
         *
         * <code>optional uint32 delay_millisec = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearDelayMillisec() {
          bitField0_ = (bitField0_ & ~0x00000002);
          delayMillisec_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.commands.Output.Callback)
      }

      // @@protoc_insertion_point(class_scope:mozc.commands.Output.Callback)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<Callback>
          PARSER = new com.google.protobuf.AbstractParser<Callback>() {
        @java.lang.Override
        public Callback parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Callback> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Callback> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface VersionInfoOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.commands.Output.VersionInfo)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional string mozc_version = 1;</code>
       * @return Whether the mozcVersion field is set.
       */
      boolean hasMozcVersion();
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return The mozcVersion.
       */
      java.lang.String getMozcVersion();
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return The bytes for mozcVersion.
       */
      com.google.protobuf.ByteString
          getMozcVersionBytes();

      /**
       * <code>optional string data_version = 2;</code>
       * @return Whether the dataVersion field is set.
       */
      boolean hasDataVersion();
      /**
       * <code>optional string data_version = 2;</code>
       * @return The dataVersion.
       */
      java.lang.String getDataVersion();
      /**
       * <code>optional string data_version = 2;</code>
       * @return The bytes for dataVersion.
       */
      com.google.protobuf.ByteString
          getDataVersionBytes();
    }
    /**
     * Protobuf type {@code mozc.commands.Output.VersionInfo}
     */
    public static final class VersionInfo extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.commands.Output.VersionInfo)
        VersionInfoOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use VersionInfo.newBuilder() to construct.
      private VersionInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private VersionInfo() {
        mozcVersion_ = "";
        dataVersion_ = "";
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new VersionInfo();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_VersionInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_VersionInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.Builder.class);
      }

      private int bitField0_;
      public static final int MOZC_VERSION_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private volatile java.lang.Object mozcVersion_ = "";
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return Whether the mozcVersion field is set.
       */
      @java.lang.Override
      public boolean hasMozcVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return The mozcVersion.
       */
      @java.lang.Override
      public java.lang.String getMozcVersion() {
        java.lang.Object ref = mozcVersion_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            mozcVersion_ = s;
          }
          return s;
        }
      }
      /**
       * <code>optional string mozc_version = 1;</code>
       * @return The bytes for mozcVersion.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMozcVersionBytes() {
        java.lang.Object ref = mozcVersion_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          mozcVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int DATA_VERSION_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private volatile java.lang.Object dataVersion_ = "";
      /**
       * <code>optional string data_version = 2;</code>
       * @return Whether the dataVersion field is set.
       */
      @java.lang.Override
      public boolean hasDataVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string data_version = 2;</code>
       * @return The dataVersion.
       */
      @java.lang.Override
      public java.lang.String getDataVersion() {
        java.lang.Object ref = dataVersion_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            dataVersion_ = s;
          }
          return s;
        }
      }
      /**
       * <code>optional string data_version = 2;</code>
       * @return The bytes for dataVersion.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDataVersionBytes() {
        java.lang.Object ref = dataVersion_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          dataVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, mozcVersion_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 2, dataVersion_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, mozcVersion_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, dataVersion_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo) obj;

        if (hasMozcVersion() != other.hasMozcVersion()) return false;
        if (hasMozcVersion()) {
          if (!getMozcVersion()
              .equals(other.getMozcVersion())) return false;
        }
        if (hasDataVersion() != other.hasDataVersion()) return false;
        if (hasDataVersion()) {
          if (!getDataVersion()
              .equals(other.getDataVersion())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasMozcVersion()) {
          hash = (37 * hash) + MOZC_VERSION_FIELD_NUMBER;
          hash = (53 * hash) + getMozcVersion().hashCode();
        }
        if (hasDataVersion()) {
          hash = (37 * hash) + DATA_VERSION_FIELD_NUMBER;
          hash = (53 * hash) + getDataVersion().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code mozc.commands.Output.VersionInfo}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.commands.Output.VersionInfo)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfoOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_VersionInfo_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_VersionInfo_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          mozcVersion_ = "";
          dataVersion_ = "";
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_VersionInfo_descriptor;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.getDefaultInstance();
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.mozcVersion_ = mozcVersion_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.dataVersion_ = dataVersion_;
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.getDefaultInstance()) return this;
          if (other.hasMozcVersion()) {
            mozcVersion_ = other.mozcVersion_;
            bitField0_ |= 0x00000001;
            onChanged();
          }
          if (other.hasDataVersion()) {
            dataVersion_ = other.dataVersion_;
            bitField0_ |= 0x00000002;
            onChanged();
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  mozcVersion_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 18: {
                  dataVersion_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.lang.Object mozcVersion_ = "";
        /**
         * <code>optional string mozc_version = 1;</code>
         * @return Whether the mozcVersion field is set.
         */
        public boolean hasMozcVersion() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @return The mozcVersion.
         */
        public java.lang.String getMozcVersion() {
          java.lang.Object ref = mozcVersion_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              mozcVersion_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @return The bytes for mozcVersion.
         */
        public com.google.protobuf.ByteString
            getMozcVersionBytes() {
          java.lang.Object ref = mozcVersion_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            mozcVersion_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @param value The mozcVersion to set.
         * @return This builder for chaining.
         */
        public Builder setMozcVersion(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          mozcVersion_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearMozcVersion() {
          mozcVersion_ = getDefaultInstance().getMozcVersion();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <code>optional string mozc_version = 1;</code>
         * @param value The bytes for mozcVersion to set.
         * @return This builder for chaining.
         */
        public Builder setMozcVersionBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          mozcVersion_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        private java.lang.Object dataVersion_ = "";
        /**
         * <code>optional string data_version = 2;</code>
         * @return Whether the dataVersion field is set.
         */
        public boolean hasDataVersion() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @return The dataVersion.
         */
        public java.lang.String getDataVersion() {
          java.lang.Object ref = dataVersion_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              dataVersion_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @return The bytes for dataVersion.
         */
        public com.google.protobuf.ByteString
            getDataVersionBytes() {
          java.lang.Object ref = dataVersion_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            dataVersion_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @param value The dataVersion to set.
         * @return This builder for chaining.
         */
        public Builder setDataVersion(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          dataVersion_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearDataVersion() {
          dataVersion_ = getDefaultInstance().getDataVersion();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <code>optional string data_version = 2;</code>
         * @param value The bytes for dataVersion to set.
         * @return This builder for chaining.
         */
        public Builder setDataVersionBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          dataVersion_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.commands.Output.VersionInfo)
      }

      // @@protoc_insertion_point(class_scope:mozc.commands.Output.VersionInfo)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<VersionInfo>
          PARSER = new com.google.protobuf.AbstractParser<VersionInfo>() {
        @java.lang.Override
        public VersionInfo parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<VersionInfo> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<VersionInfo> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int ID_FIELD_NUMBER = 1;
    private long id_ = 0L;
    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     * @return Whether the id field is set.
     */
    @java.lang.Override
    public boolean hasId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
     * @return The id.
     */
    @java.lang.Override
    public long getId() {
      return id_;
    }

    public static final int MODE_FIELD_NUMBER = 2;
    private int mode_ = 0;
    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return Whether the mode field is set.
     */
    @java.lang.Override public boolean hasMode() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * This variable is going to be obsolete. Please use status(13) instead.
     * </pre>
     *
     * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
     * @return The mode.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(mode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
    }

    public static final int CONSUMED_FIELD_NUMBER = 3;
    private boolean consumed_ = false;
    /**
     * <code>optional bool consumed = 3;</code>
     * @return Whether the consumed field is set.
     */
    @java.lang.Override
    public boolean hasConsumed() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional bool consumed = 3;</code>
     * @return The consumed.
     */
    @java.lang.Override
    public boolean getConsumed() {
      return consumed_;
    }

    public static final int RESULT_FIELD_NUMBER = 4;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result result_;
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     * @return Whether the result field is set.
     */
    @java.lang.Override
    public boolean hasResult() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     * @return The result.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getResult() {
      return result_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDefaultInstance() : result_;
    }
    /**
     * <code>optional .mozc.commands.Result result = 4;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultOrBuilder getResultOrBuilder() {
      return result_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDefaultInstance() : result_;
    }

    public static final int PREEDIT_FIELD_NUMBER = 5;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit preedit_;
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     * @return Whether the preedit field is set.
     */
    @java.lang.Override
    public boolean hasPreedit() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     * @return The preedit.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getPreedit() {
      return preedit_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.getDefaultInstance() : preedit_;
    }
    /**
     * <code>optional .mozc.commands.Preedit preedit = 5;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.PreeditOrBuilder getPreeditOrBuilder() {
      return preedit_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.getDefaultInstance() : preedit_;
    }

    public static final int CANDIDATE_WINDOW_FIELD_NUMBER = 6;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow candidateWindow_;
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     * @return Whether the candidateWindow field is set.
     */
    @java.lang.Override
    public boolean hasCandidateWindow() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     * @return The candidateWindow.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow getCandidateWindow() {
      return candidateWindow_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.getDefaultInstance() : candidateWindow_;
    }
    /**
     * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindowOrBuilder getCandidateWindowOrBuilder() {
      return candidateWindow_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.getDefaultInstance() : candidateWindow_;
    }

    public static final int KEY_FIELD_NUMBER = 7;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent key_;
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     * @return The key.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey() {
      return key_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
    }
    /**
     * <code>optional .mozc.commands.KeyEvent key = 7;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder getKeyOrBuilder() {
      return key_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
    }

    public static final int URL_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object url_ = "";
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return Whether the url field is set.
     */
    @java.lang.Override
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return The url.
     */
    @java.lang.Override
    public java.lang.String getUrl() {
      java.lang.Object ref = url_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          url_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * when URL is non empty, UI can open the page with a browser,
     * after finishing the all rendering part.
     * We are using this feature for bug-report system.
     * </pre>
     *
     * <code>optional string url = 8;</code>
     * @return The bytes for url.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUrlBytes() {
      java.lang.Object ref = url_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        url_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CONFIG_FIELD_NUMBER = 9;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config config_;
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     * @return Whether the config field is set.
     */
    @java.lang.Override
    public boolean hasConfig() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     * @return The config.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig() {
      return config_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
    }
    /**
     * <pre>
     * Output config
     * </pre>
     *
     * <code>optional .mozc.config.Config config = 9;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder getConfigOrBuilder() {
      return config_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
    }

    public static final int PREEDIT_METHOD_FIELD_NUMBER = 10;
    private int preeditMethod_ = 0;
    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     * @return Whether the preeditMethod field is set.
     */
    @java.lang.Override public boolean hasPreeditMethod() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
     * @return The preeditMethod.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod getPreeditMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod.forNumber(preeditMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod.ASCII : result;
    }

    public static final int ERROR_CODE_FIELD_NUMBER = 11;
    private int errorCode_ = 0;
    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     * @return Whether the errorCode field is set.
     */
    @java.lang.Override public boolean hasErrorCode() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
     * @return The errorCode.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode getErrorCode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode.forNumber(errorCode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode.SESSION_SUCCESS : result;
    }

    public static final int STATUS_FIELD_NUMBER = 13;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status status_;
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     * @return Whether the status field is set.
     */
    @java.lang.Override
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     * @return The status.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getStatus() {
      return status_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * The current IME status.
     * </pre>
     *
     * <code>optional .mozc.commands.Status status = 13;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.StatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.getDefaultInstance() : status_;
    }

    public static final int ALL_CANDIDATE_WORDS_FIELD_NUMBER = 14;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList allCandidateWords_;
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     * @return Whether the allCandidateWords field is set.
     */
    @java.lang.Override
    public boolean hasAllCandidateWords() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     * @return The allCandidateWords.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getAllCandidateWords() {
      return allCandidateWords_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : allCandidateWords_;
    }
    /**
     * <pre>
     * All flatten candidate words stored in 1D array.  This value is
     * filled only when the content is changed.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder getAllCandidateWordsOrBuilder() {
      return allCandidateWords_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : allCandidateWords_;
    }

    public static final int DELETION_RANGE_FIELD_NUMBER = 16;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange deletionRange_;
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     * @return Whether the deletionRange field is set.
     */
    @java.lang.Override
    public boolean hasDeletionRange() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     * @return The deletionRange.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDeletionRange() {
      return deletionRange_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.getDefaultInstance() : deletionRange_;
    }
    /**
     * <pre>
     * Range of characters to be deleted by client.
     * </pre>
     *
     * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRangeOrBuilder getDeletionRangeOrBuilder() {
      return deletionRange_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.getDefaultInstance() : deletionRange_;
    }

    public static final int LAUNCH_TOOL_MODE_FIELD_NUMBER = 17;
    private int launchToolMode_ = 0;
    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     * @return Whether the launchToolMode field is set.
     */
    @java.lang.Override public boolean hasLaunchToolMode() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
     * @return The launchToolMode.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode getLaunchToolMode() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode.forNumber(launchToolMode_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode.NO_TOOL : result;
    }

    public static final int CALLBACK_FIELD_NUMBER = 18;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback callback_;
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     * @return Whether the callback field is set.
     */
    @java.lang.Override
    public boolean hasCallback() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     * @return The callback.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getCallback() {
      return callback_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.getDefaultInstance() : callback_;
    }
    /**
     * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.CallbackOrBuilder getCallbackOrBuilder() {
      return callback_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.getDefaultInstance() : callback_;
    }

    public static final int USER_DICTIONARY_COMMAND_STATUS_FIELD_NUMBER = 21;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus userDictionaryCommandStatus_;
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
     * @return Whether the userDictionaryCommandStatus field is set.
     */
    @java.lang.Override
    public boolean hasUserDictionaryCommandStatus() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
     * @return The userDictionaryCommandStatus.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus getUserDictionaryCommandStatus() {
      return userDictionaryCommandStatus_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.getDefaultInstance() : userDictionaryCommandStatus_;
    }
    /**
     * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatusOrBuilder getUserDictionaryCommandStatusOrBuilder() {
      return userDictionaryCommandStatus_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.getDefaultInstance() : userDictionaryCommandStatus_;
    }

    public static final int ENGINE_RELOAD_RESPONSE_FIELD_NUMBER = 22;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse engineReloadResponse_;
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     * @return Whether the engineReloadResponse field is set.
     */
    @java.lang.Override
    public boolean hasEngineReloadResponse() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     * @return The engineReloadResponse.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse getEngineReloadResponse() {
      return engineReloadResponse_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.getDefaultInstance() : engineReloadResponse_;
    }
    /**
     * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponseOrBuilder getEngineReloadResponseOrBuilder() {
      return engineReloadResponse_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.getDefaultInstance() : engineReloadResponse_;
    }

    public static final int REMOVED_CANDIDATE_WORDS_FOR_DEBUG_FIELD_NUMBER = 23;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList removedCandidateWordsForDebug_;
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     * @return Whether the removedCandidateWordsForDebug field is set.
     */
    @java.lang.Override
    public boolean hasRemovedCandidateWordsForDebug() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     * @return The removedCandidateWordsForDebug.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getRemovedCandidateWordsForDebug() {
      return removedCandidateWordsForDebug_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : removedCandidateWordsForDebug_;
    }
    /**
     * <pre>
     * For debug. Candidate words removed throuth the conversion process.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder getRemovedCandidateWordsForDebugOrBuilder() {
      return removedCandidateWordsForDebug_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : removedCandidateWordsForDebug_;
    }

    public static final int INCOGNITO_CANDIDATE_WORDS_FIELD_NUMBER = 25;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList incognitoCandidateWords_;
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     * @return Whether the incognitoCandidateWords field is set.
     */
    @java.lang.Override
    public boolean hasIncognitoCandidateWords() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     * @return The incognitoCandidateWords.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getIncognitoCandidateWords() {
      return incognitoCandidateWords_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : incognitoCandidateWords_;
    }
    /**
     * <pre>
     * Candidate words stored in 1D array. The field should be filled without
     * using any personal data.
     * </pre>
     *
     * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder getIncognitoCandidateWordsOrBuilder() {
      return incognitoCandidateWords_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : incognitoCandidateWords_;
    }

    public static final int SERVER_VERSION_FIELD_NUMBER = 26;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo serverVersion_;
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     * @return Whether the serverVersion field is set.
     */
    @java.lang.Override
    public boolean hasServerVersion() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     * @return The serverVersion.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getServerVersion() {
      return serverVersion_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.getDefaultInstance() : serverVersion_;
    }
    /**
     * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfoOrBuilder getServerVersionOrBuilder() {
      return serverVersion_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.getDefaultInstance() : serverVersion_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasResult()) {
        if (!getResult().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasPreedit()) {
        if (!getPreedit().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasCandidateWindow()) {
        if (!getCandidateWindow().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasCallback()) {
        if (!getCallback().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasUserDictionaryCommandStatus()) {
        if (!getUserDictionaryCommandStatus().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasEngineReloadResponse()) {
        if (!getEngineReloadResponse().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt64(1, id_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeEnum(2, mode_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(3, consumed_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getResult());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(5, getPreedit());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(6, getCandidateWindow());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(7, getKey());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, url_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(9, getConfig());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeEnum(10, preeditMethod_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeEnum(11, errorCode_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(13, getStatus());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeMessage(14, getAllCandidateWords());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeMessage(16, getDeletionRange());
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeEnum(17, launchToolMode_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeMessage(18, getCallback());
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeMessage(21, getUserDictionaryCommandStatus());
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        output.writeMessage(22, getEngineReloadResponse());
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        output.writeMessage(23, getRemovedCandidateWordsForDebug());
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        output.writeMessage(25, getIncognitoCandidateWords());
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        output.writeMessage(26, getServerVersion());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, id_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, mode_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, consumed_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getResult());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getPreedit());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getCandidateWindow());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getKey());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, url_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getConfig());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, preeditMethod_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(11, errorCode_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, getStatus());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, getAllCandidateWords());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, getDeletionRange());
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(17, launchToolMode_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(18, getCallback());
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(21, getUserDictionaryCommandStatus());
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(22, getEngineReloadResponse());
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(23, getRemovedCandidateWordsForDebug());
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(25, getIncognitoCandidateWords());
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(26, getServerVersion());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output) obj;

      if (hasId() != other.hasId()) return false;
      if (hasId()) {
        if (getId()
            != other.getId()) return false;
      }
      if (hasMode() != other.hasMode()) return false;
      if (hasMode()) {
        if (mode_ != other.mode_) return false;
      }
      if (hasConsumed() != other.hasConsumed()) return false;
      if (hasConsumed()) {
        if (getConsumed()
            != other.getConsumed()) return false;
      }
      if (hasResult() != other.hasResult()) return false;
      if (hasResult()) {
        if (!getResult()
            .equals(other.getResult())) return false;
      }
      if (hasPreedit() != other.hasPreedit()) return false;
      if (hasPreedit()) {
        if (!getPreedit()
            .equals(other.getPreedit())) return false;
      }
      if (hasCandidateWindow() != other.hasCandidateWindow()) return false;
      if (hasCandidateWindow()) {
        if (!getCandidateWindow()
            .equals(other.getCandidateWindow())) return false;
      }
      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (hasUrl() != other.hasUrl()) return false;
      if (hasUrl()) {
        if (!getUrl()
            .equals(other.getUrl())) return false;
      }
      if (hasConfig() != other.hasConfig()) return false;
      if (hasConfig()) {
        if (!getConfig()
            .equals(other.getConfig())) return false;
      }
      if (hasPreeditMethod() != other.hasPreeditMethod()) return false;
      if (hasPreeditMethod()) {
        if (preeditMethod_ != other.preeditMethod_) return false;
      }
      if (hasErrorCode() != other.hasErrorCode()) return false;
      if (hasErrorCode()) {
        if (errorCode_ != other.errorCode_) return false;
      }
      if (hasStatus() != other.hasStatus()) return false;
      if (hasStatus()) {
        if (!getStatus()
            .equals(other.getStatus())) return false;
      }
      if (hasAllCandidateWords() != other.hasAllCandidateWords()) return false;
      if (hasAllCandidateWords()) {
        if (!getAllCandidateWords()
            .equals(other.getAllCandidateWords())) return false;
      }
      if (hasDeletionRange() != other.hasDeletionRange()) return false;
      if (hasDeletionRange()) {
        if (!getDeletionRange()
            .equals(other.getDeletionRange())) return false;
      }
      if (hasLaunchToolMode() != other.hasLaunchToolMode()) return false;
      if (hasLaunchToolMode()) {
        if (launchToolMode_ != other.launchToolMode_) return false;
      }
      if (hasCallback() != other.hasCallback()) return false;
      if (hasCallback()) {
        if (!getCallback()
            .equals(other.getCallback())) return false;
      }
      if (hasUserDictionaryCommandStatus() != other.hasUserDictionaryCommandStatus()) return false;
      if (hasUserDictionaryCommandStatus()) {
        if (!getUserDictionaryCommandStatus()
            .equals(other.getUserDictionaryCommandStatus())) return false;
      }
      if (hasEngineReloadResponse() != other.hasEngineReloadResponse()) return false;
      if (hasEngineReloadResponse()) {
        if (!getEngineReloadResponse()
            .equals(other.getEngineReloadResponse())) return false;
      }
      if (hasRemovedCandidateWordsForDebug() != other.hasRemovedCandidateWordsForDebug()) return false;
      if (hasRemovedCandidateWordsForDebug()) {
        if (!getRemovedCandidateWordsForDebug()
            .equals(other.getRemovedCandidateWordsForDebug())) return false;
      }
      if (hasIncognitoCandidateWords() != other.hasIncognitoCandidateWords()) return false;
      if (hasIncognitoCandidateWords()) {
        if (!getIncognitoCandidateWords()
            .equals(other.getIncognitoCandidateWords())) return false;
      }
      if (hasServerVersion() != other.hasServerVersion()) return false;
      if (hasServerVersion()) {
        if (!getServerVersion()
            .equals(other.getServerVersion())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasId()) {
        hash = (37 * hash) + ID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getId());
      }
      if (hasMode()) {
        hash = (37 * hash) + MODE_FIELD_NUMBER;
        hash = (53 * hash) + mode_;
      }
      if (hasConsumed()) {
        hash = (37 * hash) + CONSUMED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getConsumed());
      }
      if (hasResult()) {
        hash = (37 * hash) + RESULT_FIELD_NUMBER;
        hash = (53 * hash) + getResult().hashCode();
      }
      if (hasPreedit()) {
        hash = (37 * hash) + PREEDIT_FIELD_NUMBER;
        hash = (53 * hash) + getPreedit().hashCode();
      }
      if (hasCandidateWindow()) {
        hash = (37 * hash) + CANDIDATE_WINDOW_FIELD_NUMBER;
        hash = (53 * hash) + getCandidateWindow().hashCode();
      }
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasUrl()) {
        hash = (37 * hash) + URL_FIELD_NUMBER;
        hash = (53 * hash) + getUrl().hashCode();
      }
      if (hasConfig()) {
        hash = (37 * hash) + CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getConfig().hashCode();
      }
      if (hasPreeditMethod()) {
        hash = (37 * hash) + PREEDIT_METHOD_FIELD_NUMBER;
        hash = (53 * hash) + preeditMethod_;
      }
      if (hasErrorCode()) {
        hash = (37 * hash) + ERROR_CODE_FIELD_NUMBER;
        hash = (53 * hash) + errorCode_;
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasAllCandidateWords()) {
        hash = (37 * hash) + ALL_CANDIDATE_WORDS_FIELD_NUMBER;
        hash = (53 * hash) + getAllCandidateWords().hashCode();
      }
      if (hasDeletionRange()) {
        hash = (37 * hash) + DELETION_RANGE_FIELD_NUMBER;
        hash = (53 * hash) + getDeletionRange().hashCode();
      }
      if (hasLaunchToolMode()) {
        hash = (37 * hash) + LAUNCH_TOOL_MODE_FIELD_NUMBER;
        hash = (53 * hash) + launchToolMode_;
      }
      if (hasCallback()) {
        hash = (37 * hash) + CALLBACK_FIELD_NUMBER;
        hash = (53 * hash) + getCallback().hashCode();
      }
      if (hasUserDictionaryCommandStatus()) {
        hash = (37 * hash) + USER_DICTIONARY_COMMAND_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getUserDictionaryCommandStatus().hashCode();
      }
      if (hasEngineReloadResponse()) {
        hash = (37 * hash) + ENGINE_RELOAD_RESPONSE_FIELD_NUMBER;
        hash = (53 * hash) + getEngineReloadResponse().hashCode();
      }
      if (hasRemovedCandidateWordsForDebug()) {
        hash = (37 * hash) + REMOVED_CANDIDATE_WORDS_FOR_DEBUG_FIELD_NUMBER;
        hash = (53 * hash) + getRemovedCandidateWordsForDebug().hashCode();
      }
      if (hasIncognitoCandidateWords()) {
        hash = (37 * hash) + INCOGNITO_CANDIDATE_WORDS_FIELD_NUMBER;
        hash = (53 * hash) + getIncognitoCandidateWords().hashCode();
      }
      if (hasServerVersion()) {
        hash = (37 * hash) + SERVER_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getServerVersion().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Next ID: 27
     * </pre>
     *
     * Protobuf type {@code mozc.commands.Output}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Output)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.OutputOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getResultFieldBuilder();
          getPreeditFieldBuilder();
          getCandidateWindowFieldBuilder();
          getKeyFieldBuilder();
          getConfigFieldBuilder();
          getStatusFieldBuilder();
          getAllCandidateWordsFieldBuilder();
          getDeletionRangeFieldBuilder();
          getCallbackFieldBuilder();
          getUserDictionaryCommandStatusFieldBuilder();
          getEngineReloadResponseFieldBuilder();
          getRemovedCandidateWordsForDebugFieldBuilder();
          getIncognitoCandidateWordsFieldBuilder();
          getServerVersionFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        id_ = 0L;
        mode_ = 0;
        consumed_ = false;
        result_ = null;
        if (resultBuilder_ != null) {
          resultBuilder_.dispose();
          resultBuilder_ = null;
        }
        preedit_ = null;
        if (preeditBuilder_ != null) {
          preeditBuilder_.dispose();
          preeditBuilder_ = null;
        }
        candidateWindow_ = null;
        if (candidateWindowBuilder_ != null) {
          candidateWindowBuilder_.dispose();
          candidateWindowBuilder_ = null;
        }
        key_ = null;
        if (keyBuilder_ != null) {
          keyBuilder_.dispose();
          keyBuilder_ = null;
        }
        url_ = "";
        config_ = null;
        if (configBuilder_ != null) {
          configBuilder_.dispose();
          configBuilder_ = null;
        }
        preeditMethod_ = 0;
        errorCode_ = 0;
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        allCandidateWords_ = null;
        if (allCandidateWordsBuilder_ != null) {
          allCandidateWordsBuilder_.dispose();
          allCandidateWordsBuilder_ = null;
        }
        deletionRange_ = null;
        if (deletionRangeBuilder_ != null) {
          deletionRangeBuilder_.dispose();
          deletionRangeBuilder_ = null;
        }
        launchToolMode_ = 0;
        callback_ = null;
        if (callbackBuilder_ != null) {
          callbackBuilder_.dispose();
          callbackBuilder_ = null;
        }
        userDictionaryCommandStatus_ = null;
        if (userDictionaryCommandStatusBuilder_ != null) {
          userDictionaryCommandStatusBuilder_.dispose();
          userDictionaryCommandStatusBuilder_ = null;
        }
        engineReloadResponse_ = null;
        if (engineReloadResponseBuilder_ != null) {
          engineReloadResponseBuilder_.dispose();
          engineReloadResponseBuilder_ = null;
        }
        removedCandidateWordsForDebug_ = null;
        if (removedCandidateWordsForDebugBuilder_ != null) {
          removedCandidateWordsForDebugBuilder_.dispose();
          removedCandidateWordsForDebugBuilder_ = null;
        }
        incognitoCandidateWords_ = null;
        if (incognitoCandidateWordsBuilder_ != null) {
          incognitoCandidateWordsBuilder_.dispose();
          incognitoCandidateWordsBuilder_ = null;
        }
        serverVersion_ = null;
        if (serverVersionBuilder_ != null) {
          serverVersionBuilder_.dispose();
          serverVersionBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Output_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.id_ = id_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.mode_ = mode_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.consumed_ = consumed_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.result_ = resultBuilder_ == null
              ? result_
              : resultBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.preedit_ = preeditBuilder_ == null
              ? preedit_
              : preeditBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.candidateWindow_ = candidateWindowBuilder_ == null
              ? candidateWindow_
              : candidateWindowBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.key_ = keyBuilder_ == null
              ? key_
              : keyBuilder_.build();
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.url_ = url_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.config_ = configBuilder_ == null
              ? config_
              : configBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.preeditMethod_ = preeditMethod_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.errorCode_ = errorCode_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.status_ = statusBuilder_ == null
              ? status_
              : statusBuilder_.build();
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.allCandidateWords_ = allCandidateWordsBuilder_ == null
              ? allCandidateWords_
              : allCandidateWordsBuilder_.build();
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.deletionRange_ = deletionRangeBuilder_ == null
              ? deletionRange_
              : deletionRangeBuilder_.build();
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.launchToolMode_ = launchToolMode_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.callback_ = callbackBuilder_ == null
              ? callback_
              : callbackBuilder_.build();
          to_bitField0_ |= 0x00008000;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.userDictionaryCommandStatus_ = userDictionaryCommandStatusBuilder_ == null
              ? userDictionaryCommandStatus_
              : userDictionaryCommandStatusBuilder_.build();
          to_bitField0_ |= 0x00010000;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.engineReloadResponse_ = engineReloadResponseBuilder_ == null
              ? engineReloadResponse_
              : engineReloadResponseBuilder_.build();
          to_bitField0_ |= 0x00020000;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.removedCandidateWordsForDebug_ = removedCandidateWordsForDebugBuilder_ == null
              ? removedCandidateWordsForDebug_
              : removedCandidateWordsForDebugBuilder_.build();
          to_bitField0_ |= 0x00040000;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          result.incognitoCandidateWords_ = incognitoCandidateWordsBuilder_ == null
              ? incognitoCandidateWords_
              : incognitoCandidateWordsBuilder_.build();
          to_bitField0_ |= 0x00080000;
        }
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.serverVersion_ = serverVersionBuilder_ == null
              ? serverVersion_
              : serverVersionBuilder_.build();
          to_bitField0_ |= 0x00100000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDefaultInstance()) return this;
        if (other.hasId()) {
          setId(other.getId());
        }
        if (other.hasMode()) {
          setMode(other.getMode());
        }
        if (other.hasConsumed()) {
          setConsumed(other.getConsumed());
        }
        if (other.hasResult()) {
          mergeResult(other.getResult());
        }
        if (other.hasPreedit()) {
          mergePreedit(other.getPreedit());
        }
        if (other.hasCandidateWindow()) {
          mergeCandidateWindow(other.getCandidateWindow());
        }
        if (other.hasKey()) {
          mergeKey(other.getKey());
        }
        if (other.hasUrl()) {
          url_ = other.url_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (other.hasConfig()) {
          mergeConfig(other.getConfig());
        }
        if (other.hasPreeditMethod()) {
          setPreeditMethod(other.getPreeditMethod());
        }
        if (other.hasErrorCode()) {
          setErrorCode(other.getErrorCode());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        if (other.hasAllCandidateWords()) {
          mergeAllCandidateWords(other.getAllCandidateWords());
        }
        if (other.hasDeletionRange()) {
          mergeDeletionRange(other.getDeletionRange());
        }
        if (other.hasLaunchToolMode()) {
          setLaunchToolMode(other.getLaunchToolMode());
        }
        if (other.hasCallback()) {
          mergeCallback(other.getCallback());
        }
        if (other.hasUserDictionaryCommandStatus()) {
          mergeUserDictionaryCommandStatus(other.getUserDictionaryCommandStatus());
        }
        if (other.hasEngineReloadResponse()) {
          mergeEngineReloadResponse(other.getEngineReloadResponse());
        }
        if (other.hasRemovedCandidateWordsForDebug()) {
          mergeRemovedCandidateWordsForDebug(other.getRemovedCandidateWordsForDebug());
        }
        if (other.hasIncognitoCandidateWords()) {
          mergeIncognitoCandidateWords(other.getIncognitoCandidateWords());
        }
        if (other.hasServerVersion()) {
          mergeServerVersion(other.getServerVersion());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (hasResult()) {
          if (!getResult().isInitialized()) {
            return false;
          }
        }
        if (hasPreedit()) {
          if (!getPreedit().isInitialized()) {
            return false;
          }
        }
        if (hasCandidateWindow()) {
          if (!getCandidateWindow().isInitialized()) {
            return false;
          }
        }
        if (hasCallback()) {
          if (!getCallback().isInitialized()) {
            return false;
          }
        }
        if (hasUserDictionaryCommandStatus()) {
          if (!getUserDictionaryCommandStatus().isInitialized()) {
            return false;
          }
        }
        if (hasEngineReloadResponse()) {
          if (!getEngineReloadResponse().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                id_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(2, tmpRaw);
                } else {
                  mode_ = tmpRaw;
                  bitField0_ |= 0x00000002;
                }
                break;
              } // case 16
              case 24: {
                consumed_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                input.readMessage(
                    getResultFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getPreeditFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    getCandidateWindowFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    getKeyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 66: {
                url_ = input.readBytes();
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              case 74: {
                input.readMessage(
                    getConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 74
              case 80: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(10, tmpRaw);
                } else {
                  preeditMethod_ = tmpRaw;
                  bitField0_ |= 0x00000200;
                }
                break;
              } // case 80
              case 88: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(11, tmpRaw);
                } else {
                  errorCode_ = tmpRaw;
                  bitField0_ |= 0x00000400;
                }
                break;
              } // case 88
              case 106: {
                input.readMessage(
                    getStatusFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000800;
                break;
              } // case 106
              case 114: {
                input.readMessage(
                    getAllCandidateWordsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00001000;
                break;
              } // case 114
              case 130: {
                input.readMessage(
                    getDeletionRangeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00002000;
                break;
              } // case 130
              case 136: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(17, tmpRaw);
                } else {
                  launchToolMode_ = tmpRaw;
                  bitField0_ |= 0x00004000;
                }
                break;
              } // case 136
              case 146: {
                input.readMessage(
                    getCallbackFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00008000;
                break;
              } // case 146
              case 170: {
                input.readMessage(
                    getUserDictionaryCommandStatusFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00010000;
                break;
              } // case 170
              case 178: {
                input.readMessage(
                    getEngineReloadResponseFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00020000;
                break;
              } // case 178
              case 186: {
                input.readMessage(
                    getRemovedCandidateWordsForDebugFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00040000;
                break;
              } // case 186
              case 202: {
                input.readMessage(
                    getIncognitoCandidateWordsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00080000;
                break;
              } // case 202
              case 210: {
                input.readMessage(
                    getServerVersionFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00100000;
                break;
              } // case 210
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long id_ ;
      /**
       * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
       * @return Whether the id field is set.
       */
      @java.lang.Override
      public boolean hasId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
       * @return The id.
       */
      @java.lang.Override
      public long getId() {
        return id_;
      }
      /**
       * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(long value) {
        
        id_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        id_ = 0L;
        onChanged();
        return this;
      }

      private int mode_ = 0;
      /**
       * <pre>
       * This variable is going to be obsolete. Please use status(13) instead.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return Whether the mode field is set.
       */
      @java.lang.Override public boolean hasMode() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * This variable is going to be obsolete. Please use status(13) instead.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return The mode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode getMode() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.forNumber(mode_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode.DIRECT : result;
      }
      /**
       * <pre>
       * This variable is going to be obsolete. Please use status(13) instead.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @param value The mode to set.
       * @return This builder for chaining.
       */
      public Builder setMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CompositionMode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        mode_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This variable is going to be obsolete. Please use status(13) instead.
       * </pre>
       *
       * <code>optional .mozc.commands.CompositionMode mode = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMode() {
        bitField0_ = (bitField0_ & ~0x00000002);
        mode_ = 0;
        onChanged();
        return this;
      }

      private boolean consumed_ ;
      /**
       * <code>optional bool consumed = 3;</code>
       * @return Whether the consumed field is set.
       */
      @java.lang.Override
      public boolean hasConsumed() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional bool consumed = 3;</code>
       * @return The consumed.
       */
      @java.lang.Override
      public boolean getConsumed() {
        return consumed_;
      }
      /**
       * <code>optional bool consumed = 3;</code>
       * @param value The consumed to set.
       * @return This builder for chaining.
       */
      public Builder setConsumed(boolean value) {
        
        consumed_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool consumed = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearConsumed() {
        bitField0_ = (bitField0_ & ~0x00000004);
        consumed_ = false;
        onChanged();
        return this;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result result_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultOrBuilder> resultBuilder_;
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       * @return Whether the result field is set.
       */
      public boolean hasResult() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       * @return The result.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result getResult() {
        if (resultBuilder_ == null) {
          return result_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDefaultInstance() : result_;
        } else {
          return resultBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public Builder setResult(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result value) {
        if (resultBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          result_ = value;
        } else {
          resultBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public Builder setResult(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.Builder builderForValue) {
        if (resultBuilder_ == null) {
          result_ = builderForValue.build();
        } else {
          resultBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public Builder mergeResult(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result value) {
        if (resultBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            result_ != null &&
            result_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDefaultInstance()) {
            getResultBuilder().mergeFrom(value);
          } else {
            result_ = value;
          }
        } else {
          resultBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public Builder clearResult() {
        bitField0_ = (bitField0_ & ~0x00000008);
        result_ = null;
        if (resultBuilder_ != null) {
          resultBuilder_.dispose();
          resultBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.Builder getResultBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getResultFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultOrBuilder getResultOrBuilder() {
        if (resultBuilder_ != null) {
          return resultBuilder_.getMessageOrBuilder();
        } else {
          return result_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.getDefaultInstance() : result_;
        }
      }
      /**
       * <code>optional .mozc.commands.Result result = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultOrBuilder> 
          getResultFieldBuilder() {
        if (resultBuilder_ == null) {
          resultBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Result.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.ResultOrBuilder>(
                  getResult(),
                  getParentForChildren(),
                  isClean());
          result_ = null;
        }
        return resultBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit preedit_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.PreeditOrBuilder> preeditBuilder_;
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       * @return Whether the preedit field is set.
       */
      public boolean hasPreedit() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       * @return The preedit.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit getPreedit() {
        if (preeditBuilder_ == null) {
          return preedit_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.getDefaultInstance() : preedit_;
        } else {
          return preeditBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public Builder setPreedit(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit value) {
        if (preeditBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          preedit_ = value;
        } else {
          preeditBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public Builder setPreedit(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Builder builderForValue) {
        if (preeditBuilder_ == null) {
          preedit_ = builderForValue.build();
        } else {
          preeditBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public Builder mergePreedit(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit value) {
        if (preeditBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            preedit_ != null &&
            preedit_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.getDefaultInstance()) {
            getPreeditBuilder().mergeFrom(value);
          } else {
            preedit_ = value;
          }
        } else {
          preeditBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public Builder clearPreedit() {
        bitField0_ = (bitField0_ & ~0x00000010);
        preedit_ = null;
        if (preeditBuilder_ != null) {
          preeditBuilder_.dispose();
          preeditBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Builder getPreeditBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getPreeditFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.PreeditOrBuilder getPreeditOrBuilder() {
        if (preeditBuilder_ != null) {
          return preeditBuilder_.getMessageOrBuilder();
        } else {
          return preedit_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.getDefaultInstance() : preedit_;
        }
      }
      /**
       * <code>optional .mozc.commands.Preedit preedit = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.PreeditOrBuilder> 
          getPreeditFieldBuilder() {
        if (preeditBuilder_ == null) {
          preeditBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Preedit.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.PreeditOrBuilder>(
                  getPreedit(),
                  getParentForChildren(),
                  isClean());
          preedit_ = null;
        }
        return preeditBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow candidateWindow_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindowOrBuilder> candidateWindowBuilder_;
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       * @return Whether the candidateWindow field is set.
       */
      public boolean hasCandidateWindow() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       * @return The candidateWindow.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow getCandidateWindow() {
        if (candidateWindowBuilder_ == null) {
          return candidateWindow_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.getDefaultInstance() : candidateWindow_;
        } else {
          return candidateWindowBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public Builder setCandidateWindow(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow value) {
        if (candidateWindowBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          candidateWindow_ = value;
        } else {
          candidateWindowBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public Builder setCandidateWindow(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.Builder builderForValue) {
        if (candidateWindowBuilder_ == null) {
          candidateWindow_ = builderForValue.build();
        } else {
          candidateWindowBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public Builder mergeCandidateWindow(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow value) {
        if (candidateWindowBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            candidateWindow_ != null &&
            candidateWindow_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.getDefaultInstance()) {
            getCandidateWindowBuilder().mergeFrom(value);
          } else {
            candidateWindow_ = value;
          }
        } else {
          candidateWindowBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public Builder clearCandidateWindow() {
        bitField0_ = (bitField0_ & ~0x00000020);
        candidateWindow_ = null;
        if (candidateWindowBuilder_ != null) {
          candidateWindowBuilder_.dispose();
          candidateWindowBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.Builder getCandidateWindowBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getCandidateWindowFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindowOrBuilder getCandidateWindowOrBuilder() {
        if (candidateWindowBuilder_ != null) {
          return candidateWindowBuilder_.getMessageOrBuilder();
        } else {
          return candidateWindow_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.getDefaultInstance() : candidateWindow_;
        }
      }
      /**
       * <code>optional .mozc.commands.CandidateWindow candidate_window = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindowOrBuilder> 
          getCandidateWindowFieldBuilder() {
        if (candidateWindowBuilder_ == null) {
          candidateWindowBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindow.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateWindowOrBuilder>(
                  getCandidateWindow(),
                  getParentForChildren(),
                  isClean());
          candidateWindow_ = null;
        }
        return candidateWindowBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent key_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder> keyBuilder_;
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       * @return Whether the key field is set.
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       * @return The key.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent getKey() {
        if (keyBuilder_ == null) {
          return key_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
        } else {
          return keyBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public Builder setKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
        if (keyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          key_ = value;
        } else {
          keyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public Builder setKey(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder builderForValue) {
        if (keyBuilder_ == null) {
          key_ = builderForValue.build();
        } else {
          keyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public Builder mergeKey(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent value) {
        if (keyBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            key_ != null &&
            key_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance()) {
            getKeyBuilder().mergeFrom(value);
          } else {
            key_ = value;
          }
        } else {
          keyBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000040);
        key_ = null;
        if (keyBuilder_ != null) {
          keyBuilder_.dispose();
          keyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder getKeyBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getKeyFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder getKeyOrBuilder() {
        if (keyBuilder_ != null) {
          return keyBuilder_.getMessageOrBuilder();
        } else {
          return key_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.getDefaultInstance() : key_;
        }
      }
      /**
       * <code>optional .mozc.commands.KeyEvent key = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder> 
          getKeyFieldBuilder() {
        if (keyBuilder_ == null) {
          keyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEvent.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.KeyEventOrBuilder>(
                  getKey(),
                  getParentForChildren(),
                  isClean());
          key_ = null;
        }
        return keyBuilder_;
      }

      private java.lang.Object url_ = "";
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @return Whether the url field is set.
       */
      public boolean hasUrl() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @return The url.
       */
      public java.lang.String getUrl() {
        java.lang.Object ref = url_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            url_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @return The bytes for url.
       */
      public com.google.protobuf.ByteString
          getUrlBytes() {
        java.lang.Object ref = url_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          url_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @param value The url to set.
       * @return This builder for chaining.
       */
      public Builder setUrl(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        url_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearUrl() {
        url_ = getDefaultInstance().getUrl();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * when URL is non empty, UI can open the page with a browser,
       * after finishing the all rendering part.
       * We are using this feature for bug-report system.
       * </pre>
       *
       * <code>optional string url = 8;</code>
       * @param value The bytes for url to set.
       * @return This builder for chaining.
       */
      public Builder setUrlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        url_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config config_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder> configBuilder_;
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       * @return Whether the config field is set.
       */
      public boolean hasConfig() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       * @return The config.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getConfig() {
        if (configBuilder_ == null) {
          return config_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
        } else {
          return configBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public Builder setConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
        if (configBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          config_ = value;
        } else {
          configBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public Builder setConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder builderForValue) {
        if (configBuilder_ == null) {
          config_ = builderForValue.build();
        } else {
          configBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public Builder mergeConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config value) {
        if (configBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
            config_ != null &&
            config_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance()) {
            getConfigBuilder().mergeFrom(value);
          } else {
            config_ = value;
          }
        } else {
          configBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public Builder clearConfig() {
        bitField0_ = (bitField0_ & ~0x00000100);
        config_ = null;
        if (configBuilder_ != null) {
          configBuilder_.dispose();
          configBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder getConfigBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder getConfigOrBuilder() {
        if (configBuilder_ != null) {
          return configBuilder_.getMessageOrBuilder();
        } else {
          return config_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance() : config_;
        }
      }
      /**
       * <pre>
       * Output config
       * </pre>
       *
       * <code>optional .mozc.config.Config config = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder> 
          getConfigFieldBuilder() {
        if (configBuilder_ == null) {
          configBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder>(
                  getConfig(),
                  getParentForChildren(),
                  isClean());
          config_ = null;
        }
        return configBuilder_;
      }

      private int preeditMethod_ = 0;
      /**
       * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
       * @return Whether the preeditMethod field is set.
       */
      @java.lang.Override public boolean hasPreeditMethod() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
       * @return The preeditMethod.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod getPreeditMethod() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod.forNumber(preeditMethod_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod.ASCII : result;
      }
      /**
       * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
       * @param value The preeditMethod to set.
       * @return This builder for chaining.
       */
      public Builder setPreeditMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.PreeditMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000200;
        preeditMethod_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];</code>
       * @return This builder for chaining.
       */
      public Builder clearPreeditMethod() {
        bitField0_ = (bitField0_ & ~0x00000200);
        preeditMethod_ = 0;
        onChanged();
        return this;
      }

      private int errorCode_ = 0;
      /**
       * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
       * @return Whether the errorCode field is set.
       */
      @java.lang.Override public boolean hasErrorCode() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
       * @return The errorCode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode getErrorCode() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode.forNumber(errorCode_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode.SESSION_SUCCESS : result;
      }
      /**
       * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
       * @param value The errorCode to set.
       * @return This builder for chaining.
       */
      public Builder setErrorCode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ErrorCode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000400;
        errorCode_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];</code>
       * @return This builder for chaining.
       */
      public Builder clearErrorCode() {
        bitField0_ = (bitField0_ & ~0x00000400);
        errorCode_ = 0;
        onChanged();
        return this;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status status_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.StatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       * @return Whether the status field is set.
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       * @return The status.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public Builder setStatus(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public Builder setStatus(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public Builder mergeStatus(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000800) != 0) &&
            status_ != null &&
            status_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.getDefaultInstance()) {
            getStatusBuilder().mergeFrom(value);
          } else {
            status_ = value;
          }
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000800);
        status_ = null;
        if (statusBuilder_ != null) {
          statusBuilder_.dispose();
          statusBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.Builder getStatusBuilder() {
        bitField0_ |= 0x00000800;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.StatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * The current IME status.
       * </pre>
       *
       * <code>optional .mozc.commands.Status status = 13;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.StatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Status.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.StatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList allCandidateWords_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder> allCandidateWordsBuilder_;
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       * @return Whether the allCandidateWords field is set.
       */
      public boolean hasAllCandidateWords() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       * @return The allCandidateWords.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getAllCandidateWords() {
        if (allCandidateWordsBuilder_ == null) {
          return allCandidateWords_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : allCandidateWords_;
        } else {
          return allCandidateWordsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public Builder setAllCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        if (allCandidateWordsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          allCandidateWords_ = value;
        } else {
          allCandidateWordsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public Builder setAllCandidateWords(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder builderForValue) {
        if (allCandidateWordsBuilder_ == null) {
          allCandidateWords_ = builderForValue.build();
        } else {
          allCandidateWordsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public Builder mergeAllCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        if (allCandidateWordsBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0) &&
            allCandidateWords_ != null &&
            allCandidateWords_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance()) {
            getAllCandidateWordsBuilder().mergeFrom(value);
          } else {
            allCandidateWords_ = value;
          }
        } else {
          allCandidateWordsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public Builder clearAllCandidateWords() {
        bitField0_ = (bitField0_ & ~0x00001000);
        allCandidateWords_ = null;
        if (allCandidateWordsBuilder_ != null) {
          allCandidateWordsBuilder_.dispose();
          allCandidateWordsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder getAllCandidateWordsBuilder() {
        bitField0_ |= 0x00001000;
        onChanged();
        return getAllCandidateWordsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder getAllCandidateWordsOrBuilder() {
        if (allCandidateWordsBuilder_ != null) {
          return allCandidateWordsBuilder_.getMessageOrBuilder();
        } else {
          return allCandidateWords_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : allCandidateWords_;
        }
      }
      /**
       * <pre>
       * All flatten candidate words stored in 1D array.  This value is
       * filled only when the content is changed.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList all_candidate_words = 14;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder> 
          getAllCandidateWordsFieldBuilder() {
        if (allCandidateWordsBuilder_ == null) {
          allCandidateWordsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder>(
                  getAllCandidateWords(),
                  getParentForChildren(),
                  isClean());
          allCandidateWords_ = null;
        }
        return allCandidateWordsBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange deletionRange_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRangeOrBuilder> deletionRangeBuilder_;
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       * @return Whether the deletionRange field is set.
       */
      public boolean hasDeletionRange() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       * @return The deletionRange.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange getDeletionRange() {
        if (deletionRangeBuilder_ == null) {
          return deletionRange_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.getDefaultInstance() : deletionRange_;
        } else {
          return deletionRangeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public Builder setDeletionRange(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange value) {
        if (deletionRangeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          deletionRange_ = value;
        } else {
          deletionRangeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public Builder setDeletionRange(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.Builder builderForValue) {
        if (deletionRangeBuilder_ == null) {
          deletionRange_ = builderForValue.build();
        } else {
          deletionRangeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public Builder mergeDeletionRange(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange value) {
        if (deletionRangeBuilder_ == null) {
          if (((bitField0_ & 0x00002000) != 0) &&
            deletionRange_ != null &&
            deletionRange_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.getDefaultInstance()) {
            getDeletionRangeBuilder().mergeFrom(value);
          } else {
            deletionRange_ = value;
          }
        } else {
          deletionRangeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public Builder clearDeletionRange() {
        bitField0_ = (bitField0_ & ~0x00002000);
        deletionRange_ = null;
        if (deletionRangeBuilder_ != null) {
          deletionRangeBuilder_.dispose();
          deletionRangeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.Builder getDeletionRangeBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getDeletionRangeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRangeOrBuilder getDeletionRangeOrBuilder() {
        if (deletionRangeBuilder_ != null) {
          return deletionRangeBuilder_.getMessageOrBuilder();
        } else {
          return deletionRange_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.getDefaultInstance() : deletionRange_;
        }
      }
      /**
       * <pre>
       * Range of characters to be deleted by client.
       * </pre>
       *
       * <code>optional .mozc.commands.DeletionRange deletion_range = 16;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRangeOrBuilder> 
          getDeletionRangeFieldBuilder() {
        if (deletionRangeBuilder_ == null) {
          deletionRangeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRange.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.DeletionRangeOrBuilder>(
                  getDeletionRange(),
                  getParentForChildren(),
                  isClean());
          deletionRange_ = null;
        }
        return deletionRangeBuilder_;
      }

      private int launchToolMode_ = 0;
      /**
       * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
       * @return Whether the launchToolMode field is set.
       */
      @java.lang.Override public boolean hasLaunchToolMode() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
       * @return The launchToolMode.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode getLaunchToolMode() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode result = org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode.forNumber(launchToolMode_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode.NO_TOOL : result;
      }
      /**
       * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
       * @param value The launchToolMode to set.
       * @return This builder for chaining.
       */
      public Builder setLaunchToolMode(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.ToolMode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00004000;
        launchToolMode_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];</code>
       * @return This builder for chaining.
       */
      public Builder clearLaunchToolMode() {
        bitField0_ = (bitField0_ & ~0x00004000);
        launchToolMode_ = 0;
        onChanged();
        return this;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback callback_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.CallbackOrBuilder> callbackBuilder_;
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       * @return Whether the callback field is set.
       */
      public boolean hasCallback() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       * @return The callback.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback getCallback() {
        if (callbackBuilder_ == null) {
          return callback_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.getDefaultInstance() : callback_;
        } else {
          return callbackBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public Builder setCallback(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback value) {
        if (callbackBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          callback_ = value;
        } else {
          callbackBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public Builder setCallback(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.Builder builderForValue) {
        if (callbackBuilder_ == null) {
          callback_ = builderForValue.build();
        } else {
          callbackBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public Builder mergeCallback(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback value) {
        if (callbackBuilder_ == null) {
          if (((bitField0_ & 0x00008000) != 0) &&
            callback_ != null &&
            callback_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.getDefaultInstance()) {
            getCallbackBuilder().mergeFrom(value);
          } else {
            callback_ = value;
          }
        } else {
          callbackBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public Builder clearCallback() {
        bitField0_ = (bitField0_ & ~0x00008000);
        callback_ = null;
        if (callbackBuilder_ != null) {
          callbackBuilder_.dispose();
          callbackBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.Builder getCallbackBuilder() {
        bitField0_ |= 0x00008000;
        onChanged();
        return getCallbackFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.CallbackOrBuilder getCallbackOrBuilder() {
        if (callbackBuilder_ != null) {
          return callbackBuilder_.getMessageOrBuilder();
        } else {
          return callback_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.getDefaultInstance() : callback_;
        }
      }
      /**
       * <code>optional .mozc.commands.Output.Callback callback = 18;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.CallbackOrBuilder> 
          getCallbackFieldBuilder() {
        if (callbackBuilder_ == null) {
          callbackBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Callback.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.CallbackOrBuilder>(
                  getCallback(),
                  getParentForChildren(),
                  isClean());
          callback_ = null;
        }
        return callbackBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus userDictionaryCommandStatus_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatusOrBuilder> userDictionaryCommandStatusBuilder_;
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
       * @return Whether the userDictionaryCommandStatus field is set.
       */
      public boolean hasUserDictionaryCommandStatus() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
       * @return The userDictionaryCommandStatus.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus getUserDictionaryCommandStatus() {
        if (userDictionaryCommandStatusBuilder_ == null) {
          return userDictionaryCommandStatus_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.getDefaultInstance() : userDictionaryCommandStatus_;
        } else {
          return userDictionaryCommandStatusBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
       */
      public Builder setUserDictionaryCommandStatus(org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus value) {
        if (userDictionaryCommandStatusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          userDictionaryCommandStatus_ = value;
        } else {
          userDictionaryCommandStatusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
       */
      public Builder setUserDictionaryCommandStatus(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.Builder builderForValue) {
        if (userDictionaryCommandStatusBuilder_ == null) {
          userDictionaryCommandStatus_ = builderForValue.build();
        } else {
          userDictionaryCommandStatusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
       */
      public Builder mergeUserDictionaryCommandStatus(org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus value) {
        if (userDictionaryCommandStatusBuilder_ == null) {
          if (((bitField0_ & 0x00010000) != 0) &&
            userDictionaryCommandStatus_ != null &&
            userDictionaryCommandStatus_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.getDefaultInstance()) {
            getUserDictionaryCommandStatusBuilder().mergeFrom(value);
          } else {
            userDictionaryCommandStatus_ = value;
          }
        } else {
          userDictionaryCommandStatusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
       */
      public Builder clearUserDictionaryCommandStatus() {
        bitField0_ = (bitField0_ & ~0x00010000);
        userDictionaryCommandStatus_ = null;
        if (userDictionaryCommandStatusBuilder_ != null) {
          userDictionaryCommandStatusBuilder_.dispose();
          userDictionaryCommandStatusBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.Builder getUserDictionaryCommandStatusBuilder() {
        bitField0_ |= 0x00010000;
        onChanged();
        return getUserDictionaryCommandStatusFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatusOrBuilder getUserDictionaryCommandStatusOrBuilder() {
        if (userDictionaryCommandStatusBuilder_ != null) {
          return userDictionaryCommandStatusBuilder_.getMessageOrBuilder();
        } else {
          return userDictionaryCommandStatus_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.getDefaultInstance() : userDictionaryCommandStatus_;
        }
      }
      /**
       * <code>optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatusOrBuilder> 
          getUserDictionaryCommandStatusFieldBuilder() {
        if (userDictionaryCommandStatusBuilder_ == null) {
          userDictionaryCommandStatusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatus.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.UserDictionaryCommandStatusOrBuilder>(
                  getUserDictionaryCommandStatus(),
                  getParentForChildren(),
                  isClean());
          userDictionaryCommandStatus_ = null;
        }
        return userDictionaryCommandStatusBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse engineReloadResponse_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponseOrBuilder> engineReloadResponseBuilder_;
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       * @return Whether the engineReloadResponse field is set.
       */
      public boolean hasEngineReloadResponse() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       * @return The engineReloadResponse.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse getEngineReloadResponse() {
        if (engineReloadResponseBuilder_ == null) {
          return engineReloadResponse_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.getDefaultInstance() : engineReloadResponse_;
        } else {
          return engineReloadResponseBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public Builder setEngineReloadResponse(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse value) {
        if (engineReloadResponseBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          engineReloadResponse_ = value;
        } else {
          engineReloadResponseBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public Builder setEngineReloadResponse(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.Builder builderForValue) {
        if (engineReloadResponseBuilder_ == null) {
          engineReloadResponse_ = builderForValue.build();
        } else {
          engineReloadResponseBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public Builder mergeEngineReloadResponse(org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse value) {
        if (engineReloadResponseBuilder_ == null) {
          if (((bitField0_ & 0x00020000) != 0) &&
            engineReloadResponse_ != null &&
            engineReloadResponse_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.getDefaultInstance()) {
            getEngineReloadResponseBuilder().mergeFrom(value);
          } else {
            engineReloadResponse_ = value;
          }
        } else {
          engineReloadResponseBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public Builder clearEngineReloadResponse() {
        bitField0_ = (bitField0_ & ~0x00020000);
        engineReloadResponse_ = null;
        if (engineReloadResponseBuilder_ != null) {
          engineReloadResponseBuilder_.dispose();
          engineReloadResponseBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.Builder getEngineReloadResponseBuilder() {
        bitField0_ |= 0x00020000;
        onChanged();
        return getEngineReloadResponseFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponseOrBuilder getEngineReloadResponseOrBuilder() {
        if (engineReloadResponseBuilder_ != null) {
          return engineReloadResponseBuilder_.getMessageOrBuilder();
        } else {
          return engineReloadResponse_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.getDefaultInstance() : engineReloadResponse_;
        }
      }
      /**
       * <code>optional .mozc.EngineReloadResponse engine_reload_response = 22;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponseOrBuilder> 
          getEngineReloadResponseFieldBuilder() {
        if (engineReloadResponseBuilder_ == null) {
          engineReloadResponseBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponse.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.EngineReloadResponseOrBuilder>(
                  getEngineReloadResponse(),
                  getParentForChildren(),
                  isClean());
          engineReloadResponse_ = null;
        }
        return engineReloadResponseBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList removedCandidateWordsForDebug_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder> removedCandidateWordsForDebugBuilder_;
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       * @return Whether the removedCandidateWordsForDebug field is set.
       */
      public boolean hasRemovedCandidateWordsForDebug() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       * @return The removedCandidateWordsForDebug.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getRemovedCandidateWordsForDebug() {
        if (removedCandidateWordsForDebugBuilder_ == null) {
          return removedCandidateWordsForDebug_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : removedCandidateWordsForDebug_;
        } else {
          return removedCandidateWordsForDebugBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public Builder setRemovedCandidateWordsForDebug(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        if (removedCandidateWordsForDebugBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          removedCandidateWordsForDebug_ = value;
        } else {
          removedCandidateWordsForDebugBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public Builder setRemovedCandidateWordsForDebug(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder builderForValue) {
        if (removedCandidateWordsForDebugBuilder_ == null) {
          removedCandidateWordsForDebug_ = builderForValue.build();
        } else {
          removedCandidateWordsForDebugBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public Builder mergeRemovedCandidateWordsForDebug(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        if (removedCandidateWordsForDebugBuilder_ == null) {
          if (((bitField0_ & 0x00040000) != 0) &&
            removedCandidateWordsForDebug_ != null &&
            removedCandidateWordsForDebug_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance()) {
            getRemovedCandidateWordsForDebugBuilder().mergeFrom(value);
          } else {
            removedCandidateWordsForDebug_ = value;
          }
        } else {
          removedCandidateWordsForDebugBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public Builder clearRemovedCandidateWordsForDebug() {
        bitField0_ = (bitField0_ & ~0x00040000);
        removedCandidateWordsForDebug_ = null;
        if (removedCandidateWordsForDebugBuilder_ != null) {
          removedCandidateWordsForDebugBuilder_.dispose();
          removedCandidateWordsForDebugBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder getRemovedCandidateWordsForDebugBuilder() {
        bitField0_ |= 0x00040000;
        onChanged();
        return getRemovedCandidateWordsForDebugFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder getRemovedCandidateWordsForDebugOrBuilder() {
        if (removedCandidateWordsForDebugBuilder_ != null) {
          return removedCandidateWordsForDebugBuilder_.getMessageOrBuilder();
        } else {
          return removedCandidateWordsForDebug_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : removedCandidateWordsForDebug_;
        }
      }
      /**
       * <pre>
       * For debug. Candidate words removed throuth the conversion process.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList removed_candidate_words_for_debug = 23;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder> 
          getRemovedCandidateWordsForDebugFieldBuilder() {
        if (removedCandidateWordsForDebugBuilder_ == null) {
          removedCandidateWordsForDebugBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder>(
                  getRemovedCandidateWordsForDebug(),
                  getParentForChildren(),
                  isClean());
          removedCandidateWordsForDebug_ = null;
        }
        return removedCandidateWordsForDebugBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList incognitoCandidateWords_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder> incognitoCandidateWordsBuilder_;
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       * @return Whether the incognitoCandidateWords field is set.
       */
      public boolean hasIncognitoCandidateWords() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       * @return The incognitoCandidateWords.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList getIncognitoCandidateWords() {
        if (incognitoCandidateWordsBuilder_ == null) {
          return incognitoCandidateWords_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : incognitoCandidateWords_;
        } else {
          return incognitoCandidateWordsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public Builder setIncognitoCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        if (incognitoCandidateWordsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          incognitoCandidateWords_ = value;
        } else {
          incognitoCandidateWordsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00080000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public Builder setIncognitoCandidateWords(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder builderForValue) {
        if (incognitoCandidateWordsBuilder_ == null) {
          incognitoCandidateWords_ = builderForValue.build();
        } else {
          incognitoCandidateWordsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00080000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public Builder mergeIncognitoCandidateWords(org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList value) {
        if (incognitoCandidateWordsBuilder_ == null) {
          if (((bitField0_ & 0x00080000) != 0) &&
            incognitoCandidateWords_ != null &&
            incognitoCandidateWords_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance()) {
            getIncognitoCandidateWordsBuilder().mergeFrom(value);
          } else {
            incognitoCandidateWords_ = value;
          }
        } else {
          incognitoCandidateWordsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00080000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public Builder clearIncognitoCandidateWords() {
        bitField0_ = (bitField0_ & ~0x00080000);
        incognitoCandidateWords_ = null;
        if (incognitoCandidateWordsBuilder_ != null) {
          incognitoCandidateWordsBuilder_.dispose();
          incognitoCandidateWordsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder getIncognitoCandidateWordsBuilder() {
        bitField0_ |= 0x00080000;
        onChanged();
        return getIncognitoCandidateWordsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder getIncognitoCandidateWordsOrBuilder() {
        if (incognitoCandidateWordsBuilder_ != null) {
          return incognitoCandidateWordsBuilder_.getMessageOrBuilder();
        } else {
          return incognitoCandidateWords_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.getDefaultInstance() : incognitoCandidateWords_;
        }
      }
      /**
       * <pre>
       * Candidate words stored in 1D array. The field should be filled without
       * using any personal data.
       * </pre>
       *
       * <code>optional .mozc.commands.CandidateList incognito_candidate_words = 25;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder> 
          getIncognitoCandidateWordsFieldBuilder() {
        if (incognitoCandidateWordsBuilder_ == null) {
          incognitoCandidateWordsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateList.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.CandidateListOrBuilder>(
                  getIncognitoCandidateWords(),
                  getParentForChildren(),
                  isClean());
          incognitoCandidateWords_ = null;
        }
        return incognitoCandidateWordsBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo serverVersion_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfoOrBuilder> serverVersionBuilder_;
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       * @return Whether the serverVersion field is set.
       */
      public boolean hasServerVersion() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       * @return The serverVersion.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo getServerVersion() {
        if (serverVersionBuilder_ == null) {
          return serverVersion_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.getDefaultInstance() : serverVersion_;
        } else {
          return serverVersionBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public Builder setServerVersion(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo value) {
        if (serverVersionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          serverVersion_ = value;
        } else {
          serverVersionBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public Builder setServerVersion(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.Builder builderForValue) {
        if (serverVersionBuilder_ == null) {
          serverVersion_ = builderForValue.build();
        } else {
          serverVersionBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public Builder mergeServerVersion(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo value) {
        if (serverVersionBuilder_ == null) {
          if (((bitField0_ & 0x00100000) != 0) &&
            serverVersion_ != null &&
            serverVersion_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.getDefaultInstance()) {
            getServerVersionBuilder().mergeFrom(value);
          } else {
            serverVersion_ = value;
          }
        } else {
          serverVersionBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public Builder clearServerVersion() {
        bitField0_ = (bitField0_ & ~0x00100000);
        serverVersion_ = null;
        if (serverVersionBuilder_ != null) {
          serverVersionBuilder_.dispose();
          serverVersionBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.Builder getServerVersionBuilder() {
        bitField0_ |= 0x00100000;
        onChanged();
        return getServerVersionFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfoOrBuilder getServerVersionOrBuilder() {
        if (serverVersionBuilder_ != null) {
          return serverVersionBuilder_.getMessageOrBuilder();
        } else {
          return serverVersion_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.getDefaultInstance() : serverVersion_;
        }
      }
      /**
       * <code>optional .mozc.commands.Output.VersionInfo server_version = 26;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfoOrBuilder> 
          getServerVersionFieldBuilder() {
        if (serverVersionBuilder_ == null) {
          serverVersionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfo.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.VersionInfoOrBuilder>(
                  getServerVersion(),
                  getParentForChildren(),
                  isClean());
          serverVersion_ = null;
        }
        return serverVersionBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.Output)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.Output)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Output>
        PARSER = new com.google.protobuf.AbstractParser<Output>() {
      @java.lang.Override
      public Output parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Output> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Output> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CommandOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.Command)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     * @return Whether the input field is set.
     */
    boolean hasInput();
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     * @return The input.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getInput();
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.InputOrBuilder getInputOrBuilder();

    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     * @return Whether the output field is set.
     */
    boolean hasOutput();
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     * @return The output.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getOutput();
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.OutputOrBuilder getOutputOrBuilder();
  }
  /**
   * Protobuf type {@code mozc.commands.Command}
   */
  public static final class Command extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.Command)
      CommandOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Command.newBuilder() to construct.
    private Command(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Command() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Command();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Command_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Command_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder.class);
    }

    private int bitField0_;
    public static final int INPUT_FIELD_NUMBER = 1;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input input_;
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     * @return Whether the input field is set.
     */
    @java.lang.Override
    public boolean hasInput() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     * @return The input.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getInput() {
      return input_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDefaultInstance() : input_;
    }
    /**
     * <code>required .mozc.commands.Input input = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.InputOrBuilder getInputOrBuilder() {
      return input_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDefaultInstance() : input_;
    }

    public static final int OUTPUT_FIELD_NUMBER = 2;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output output_;
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     * @return Whether the output field is set.
     */
    @java.lang.Override
    public boolean hasOutput() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     * @return The output.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getOutput() {
      return output_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDefaultInstance() : output_;
    }
    /**
     * <code>optional .mozc.commands.Output output = 2;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.OutputOrBuilder getOutputOrBuilder() {
      return output_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDefaultInstance() : output_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasInput()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!getInput().isInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (hasOutput()) {
        if (!getOutput().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getInput());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getOutput());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getInput());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getOutput());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command) obj;

      if (hasInput() != other.hasInput()) return false;
      if (hasInput()) {
        if (!getInput()
            .equals(other.getInput())) return false;
      }
      if (hasOutput() != other.hasOutput()) return false;
      if (hasOutput()) {
        if (!getOutput()
            .equals(other.getOutput())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasInput()) {
        hash = (37 * hash) + INPUT_FIELD_NUMBER;
        hash = (53 * hash) + getInput().hashCode();
      }
      if (hasOutput()) {
        hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
        hash = (53 * hash) + getOutput().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.commands.Command}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.Command)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Command_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Command_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getInputFieldBuilder();
          getOutputFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        input_ = null;
        if (inputBuilder_ != null) {
          inputBuilder_.dispose();
          inputBuilder_ = null;
        }
        output_ = null;
        if (outputBuilder_ != null) {
          outputBuilder_.dispose();
          outputBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_Command_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.input_ = inputBuilder_ == null
              ? input_
              : inputBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.output_ = outputBuilder_ == null
              ? output_
              : outputBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.getDefaultInstance()) return this;
        if (other.hasInput()) {
          mergeInput(other.getInput());
        }
        if (other.hasOutput()) {
          mergeOutput(other.getOutput());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasInput()) {
          return false;
        }
        if (!getInput().isInitialized()) {
          return false;
        }
        if (hasOutput()) {
          if (!getOutput().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getInputFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getOutputFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input input_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.InputOrBuilder> inputBuilder_;
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       * @return Whether the input field is set.
       */
      public boolean hasInput() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       * @return The input.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input getInput() {
        if (inputBuilder_ == null) {
          return input_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDefaultInstance() : input_;
        } else {
          return inputBuilder_.getMessage();
        }
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public Builder setInput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input value) {
        if (inputBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          input_ = value;
        } else {
          inputBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public Builder setInput(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.Builder builderForValue) {
        if (inputBuilder_ == null) {
          input_ = builderForValue.build();
        } else {
          inputBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public Builder mergeInput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input value) {
        if (inputBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            input_ != null &&
            input_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDefaultInstance()) {
            getInputBuilder().mergeFrom(value);
          } else {
            input_ = value;
          }
        } else {
          inputBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public Builder clearInput() {
        bitField0_ = (bitField0_ & ~0x00000001);
        input_ = null;
        if (inputBuilder_ != null) {
          inputBuilder_.dispose();
          inputBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.Builder getInputBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getInputFieldBuilder().getBuilder();
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.InputOrBuilder getInputOrBuilder() {
        if (inputBuilder_ != null) {
          return inputBuilder_.getMessageOrBuilder();
        } else {
          return input_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.getDefaultInstance() : input_;
        }
      }
      /**
       * <code>required .mozc.commands.Input input = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.InputOrBuilder> 
          getInputFieldBuilder() {
        if (inputBuilder_ == null) {
          inputBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Input.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.InputOrBuilder>(
                  getInput(),
                  getParentForChildren(),
                  isClean());
          input_ = null;
        }
        return inputBuilder_;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output output_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.OutputOrBuilder> outputBuilder_;
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       * @return Whether the output field is set.
       */
      public boolean hasOutput() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       * @return The output.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output getOutput() {
        if (outputBuilder_ == null) {
          return output_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDefaultInstance() : output_;
        } else {
          return outputBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public Builder setOutput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output value) {
        if (outputBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          output_ = value;
        } else {
          outputBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public Builder setOutput(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Builder builderForValue) {
        if (outputBuilder_ == null) {
          output_ = builderForValue.build();
        } else {
          outputBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public Builder mergeOutput(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output value) {
        if (outputBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            output_ != null &&
            output_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDefaultInstance()) {
            getOutputBuilder().mergeFrom(value);
          } else {
            output_ = value;
          }
        } else {
          outputBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public Builder clearOutput() {
        bitField0_ = (bitField0_ & ~0x00000002);
        output_ = null;
        if (outputBuilder_ != null) {
          outputBuilder_.dispose();
          outputBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Builder getOutputBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getOutputFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.OutputOrBuilder getOutputOrBuilder() {
        if (outputBuilder_ != null) {
          return outputBuilder_.getMessageOrBuilder();
        } else {
          return output_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.getDefaultInstance() : output_;
        }
      }
      /**
       * <code>optional .mozc.commands.Output output = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.OutputOrBuilder> 
          getOutputFieldBuilder() {
        if (outputBuilder_ == null) {
          outputBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Output.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.OutputOrBuilder>(
                  getOutput(),
                  getParentForChildren(),
                  isClean());
          output_ = null;
        }
        return outputBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.Command)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.Command)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Command>
        PARSER = new com.google.protobuf.AbstractParser<Command>() {
      @java.lang.Override
      public Command parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Command> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Command> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MozcCommandsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.MozcCommands)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> 
        getCommandsList();
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index);
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    int getCommandsCount();
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
        getCommandsOrBuilderList();
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder getCommandsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Message used by ProtoXDB as "mozc_commands".
   * </pre>
   *
   * Protobuf type {@code mozc.commands.MozcCommands}
   */
  public static final class MozcCommands extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.MozcCommands)
      MozcCommandsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MozcCommands.newBuilder() to construct.
    private MozcCommands(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MozcCommands() {
      commands_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MozcCommands();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_MozcCommands_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_MozcCommands_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands.Builder.class);
    }

    public static final int COMMANDS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> commands_;
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> getCommandsList() {
      return commands_;
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
        getCommandsOrBuilderList() {
      return commands_;
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public int getCommandsCount() {
      return commands_.size();
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index) {
      return commands_.get(index);
    }
    /**
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder getCommandsOrBuilder(
        int index) {
      return commands_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getCommandsCount(); i++) {
        if (!getCommands(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < commands_.size(); i++) {
        output.writeMessage(1, commands_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < commands_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, commands_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands) obj;

      if (!getCommandsList()
          .equals(other.getCommandsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getCommandsCount() > 0) {
        hash = (37 * hash) + COMMANDS_FIELD_NUMBER;
        hash = (53 * hash) + getCommandsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Message used by ProtoXDB as "mozc_commands".
     * </pre>
     *
     * Protobuf type {@code mozc.commands.MozcCommands}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.MozcCommands)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommandsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_MozcCommands_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_MozcCommands_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (commandsBuilder_ == null) {
          commands_ = java.util.Collections.emptyList();
        } else {
          commands_ = null;
          commandsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_MozcCommands_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands result) {
        if (commandsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            commands_ = java.util.Collections.unmodifiableList(commands_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.commands_ = commands_;
        } else {
          result.commands_ = commandsBuilder_.build();
        }
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands.getDefaultInstance()) return this;
        if (commandsBuilder_ == null) {
          if (!other.commands_.isEmpty()) {
            if (commands_.isEmpty()) {
              commands_ = other.commands_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureCommandsIsMutable();
              commands_.addAll(other.commands_);
            }
            onChanged();
          }
        } else {
          if (!other.commands_.isEmpty()) {
            if (commandsBuilder_.isEmpty()) {
              commandsBuilder_.dispose();
              commandsBuilder_ = null;
              commands_ = other.commands_;
              bitField0_ = (bitField0_ & ~0x00000001);
              commandsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCommandsFieldBuilder() : null;
            } else {
              commandsBuilder_.addAllMessages(other.commands_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getCommandsCount(); i++) {
          if (!getCommands(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command m =
                    input.readMessage(
                        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.PARSER,
                        extensionRegistry);
                if (commandsBuilder_ == null) {
                  ensureCommandsIsMutable();
                  commands_.add(m);
                } else {
                  commandsBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> commands_ =
        java.util.Collections.emptyList();
      private void ensureCommandsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          commands_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command>(commands_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> commandsBuilder_;

      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> getCommandsList() {
        if (commandsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(commands_);
        } else {
          return commandsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public int getCommandsCount() {
        if (commandsBuilder_ == null) {
          return commands_.size();
        } else {
          return commandsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index) {
        if (commandsBuilder_ == null) {
          return commands_.get(index);
        } else {
          return commandsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder setCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        if (commandsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCommandsIsMutable();
          commands_.set(index, value);
          onChanged();
        } else {
          commandsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder setCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          commands_.set(index, builderForValue.build());
          onChanged();
        } else {
          commandsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        if (commandsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCommandsIsMutable();
          commands_.add(value);
          onChanged();
        } else {
          commandsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        if (commandsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCommandsIsMutable();
          commands_.add(index, value);
          onChanged();
        } else {
          commandsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          commands_.add(builderForValue.build());
          onChanged();
        } else {
          commandsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          commands_.add(index, builderForValue.build());
          onChanged();
        } else {
          commandsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addAllCommands(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> values) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, commands_);
          onChanged();
        } else {
          commandsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder clearCommands() {
        if (commandsBuilder_ == null) {
          commands_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          commandsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder removeCommands(int index) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          commands_.remove(index);
          onChanged();
        } else {
          commandsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder getCommandsBuilder(
          int index) {
        return getCommandsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder getCommandsOrBuilder(
          int index) {
        if (commandsBuilder_ == null) {
          return commands_.get(index);  } else {
          return commandsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
           getCommandsOrBuilderList() {
        if (commandsBuilder_ != null) {
          return commandsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(commands_);
        }
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder addCommandsBuilder() {
        return getCommandsFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder addCommandsBuilder(
          int index) {
        return getCommandsFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder> 
           getCommandsBuilderList() {
        return getCommandsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
          getCommandsFieldBuilder() {
        if (commandsBuilder_ == null) {
          commandsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder>(
                  commands_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          commands_ = null;
        }
        return commandsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.MozcCommands)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.MozcCommands)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MozcCommands>
        PARSER = new com.google.protobuf.AbstractParser<MozcCommands>() {
      @java.lang.Override
      public MozcCommands parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MozcCommands> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MozcCommands> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.MozcCommands getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CommandListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.commands.CommandList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> 
        getCommandsList();
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index);
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    int getCommandsCount();
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
        getCommandsOrBuilderList();
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder getCommandsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code mozc.commands.CommandList}
   */
  public static final class CommandList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.commands.CommandList)
      CommandListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CommandList.newBuilder() to construct.
    private CommandList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CommandList() {
      commands_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CommandList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_CommandList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_CommandList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList.Builder.class);
    }

    public static final int COMMANDS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> commands_;
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> getCommandsList() {
      return commands_;
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
        getCommandsOrBuilderList() {
      return commands_;
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public int getCommandsCount() {
      return commands_.size();
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index) {
      return commands_.get(index);
    }
    /**
     * <pre>
     * This message is used for unittest.
     * </pre>
     *
     * <code>repeated .mozc.commands.Command commands = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder getCommandsOrBuilder(
        int index) {
      return commands_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getCommandsCount(); i++) {
        if (!getCommands(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < commands_.size(); i++) {
        output.writeMessage(1, commands_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < commands_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, commands_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList) obj;

      if (!getCommandsList()
          .equals(other.getCommandsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getCommandsCount() > 0) {
        hash = (37 * hash) + COMMANDS_FIELD_NUMBER;
        hash = (53 * hash) + getCommandsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.commands.CommandList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.commands.CommandList)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_CommandList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_CommandList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (commandsBuilder_ == null) {
          commands_ = java.util.Collections.emptyList();
        } else {
          commands_ = null;
          commandsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.internal_static_mozc_commands_CommandList_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList result) {
        if (commandsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            commands_ = java.util.Collections.unmodifiableList(commands_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.commands_ = commands_;
        } else {
          result.commands_ = commandsBuilder_.build();
        }
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList.getDefaultInstance()) return this;
        if (commandsBuilder_ == null) {
          if (!other.commands_.isEmpty()) {
            if (commands_.isEmpty()) {
              commands_ = other.commands_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureCommandsIsMutable();
              commands_.addAll(other.commands_);
            }
            onChanged();
          }
        } else {
          if (!other.commands_.isEmpty()) {
            if (commandsBuilder_.isEmpty()) {
              commandsBuilder_.dispose();
              commandsBuilder_ = null;
              commands_ = other.commands_;
              bitField0_ = (bitField0_ & ~0x00000001);
              commandsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCommandsFieldBuilder() : null;
            } else {
              commandsBuilder_.addAllMessages(other.commands_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getCommandsCount(); i++) {
          if (!getCommands(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command m =
                    input.readMessage(
                        org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.PARSER,
                        extensionRegistry);
                if (commandsBuilder_ == null) {
                  ensureCommandsIsMutable();
                  commands_.add(m);
                } else {
                  commandsBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> commands_ =
        java.util.Collections.emptyList();
      private void ensureCommandsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          commands_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command>(commands_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> commandsBuilder_;

      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> getCommandsList() {
        if (commandsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(commands_);
        } else {
          return commandsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public int getCommandsCount() {
        if (commandsBuilder_ == null) {
          return commands_.size();
        } else {
          return commandsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command getCommands(int index) {
        if (commandsBuilder_ == null) {
          return commands_.get(index);
        } else {
          return commandsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder setCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        if (commandsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCommandsIsMutable();
          commands_.set(index, value);
          onChanged();
        } else {
          commandsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder setCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          commands_.set(index, builderForValue.build());
          onChanged();
        } else {
          commandsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        if (commandsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCommandsIsMutable();
          commands_.add(value);
          onChanged();
        } else {
          commandsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command value) {
        if (commandsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCommandsIsMutable();
          commands_.add(index, value);
          onChanged();
        } else {
          commandsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          commands_.add(builderForValue.build());
          onChanged();
        } else {
          commandsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addCommands(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder builderForValue) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          commands_.add(index, builderForValue.build());
          onChanged();
        } else {
          commandsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder addAllCommands(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command> values) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, commands_);
          onChanged();
        } else {
          commandsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder clearCommands() {
        if (commandsBuilder_ == null) {
          commands_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          commandsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public Builder removeCommands(int index) {
        if (commandsBuilder_ == null) {
          ensureCommandsIsMutable();
          commands_.remove(index);
          onChanged();
        } else {
          commandsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder getCommandsBuilder(
          int index) {
        return getCommandsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder getCommandsOrBuilder(
          int index) {
        if (commandsBuilder_ == null) {
          return commands_.get(index);  } else {
          return commandsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
           getCommandsOrBuilderList() {
        if (commandsBuilder_ != null) {
          return commandsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(commands_);
        }
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder addCommandsBuilder() {
        return getCommandsFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.getDefaultInstance());
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder addCommandsBuilder(
          int index) {
        return getCommandsFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.getDefaultInstance());
      }
      /**
       * <pre>
       * This message is used for unittest.
       * </pre>
       *
       * <code>repeated .mozc.commands.Command commands = 1;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder> 
           getCommandsBuilderList() {
        return getCommandsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder> 
          getCommandsFieldBuilder() {
        if (commandsBuilder_ == null) {
          commandsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.Command.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandOrBuilder>(
                  commands_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          commands_ = null;
        }
        return commandsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.commands.CommandList)
    }

    // @@protoc_insertion_point(class_scope:mozc.commands.CommandList)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CommandList>
        PARSER = new com.google.protobuf.AbstractParser<CommandList>() {
      @java.lang.Override
      public CommandList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CommandList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CommandList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands.CommandList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_KeyEvent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_KeyEvent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_SessionCommand_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_SessionCommand_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_SessionCommand_CompositionEvent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_SessionCommand_CompositionEvent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Context_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Context_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Capability_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Capability_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_DecoderExperimentParams_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_DecoderExperimentParams_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Request_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Request_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_ApplicationInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_ApplicationInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Input_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Input_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Input_TouchPosition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Input_TouchPosition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Input_TouchEvent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Input_TouchEvent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_ResultToken_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_ResultToken_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Result_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Result_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Preedit_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Preedit_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Preedit_Segment_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Preedit_Segment_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Status_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Status_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_DeletionRange_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_DeletionRange_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Output_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Output_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Output_Callback_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Output_Callback_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Output_VersionInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Output_VersionInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_Command_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_Command_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_MozcCommands_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_MozcCommands_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_commands_CommandList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_commands_CommandList_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\027protocol/commands.proto\022\rmozc.commands" +
      "\032\037protocol/candidate_window.proto\032\025proto" +
      "col/config.proto\032\035protocol/engine_builde" +
      "r.proto\032&protocol/user_dictionary_storag" +
      "e.proto\"\326\r\n\010KeyEvent\022\020\n\010key_code\030\001 \001(\r\022\021" +
      "\n\tmodifiers\030\002 \001(\r\0227\n\013special_key\030\003 \001(\0162\"" +
      ".mozc.commands.KeyEvent.SpecialKey\022:\n\rmo" +
      "difier_keys\030\004 \003(\0162#.mozc.commands.KeyEve" +
      "nt.ModifierKey\022\022\n\nkey_string\030\005 \001(\t\022D\n\013in" +
      "put_style\030\006 \001(\0162\".mozc.commands.KeyEvent" +
      ".InputStyle:\013FOLLOW_MODE\022,\n\004mode\030\007 \001(\0162\036" +
      ".mozc.commands.CompositionMode\022D\n\022probab" +
      "le_key_event\030\010 \003(\0132(.mozc.commands.KeyEv" +
      "ent.ProbableKeyEvent\022\021\n\tactivated\030\t \001(\010\022" +
      "\026\n\016timestamp_msec\030\n \001(\003\032\256\001\n\020ProbableKeyE" +
      "vent\022\020\n\010key_code\030\001 \001(\r\0227\n\013special_key\030\003 " +
      "\001(\0162\".mozc.commands.KeyEvent.SpecialKey\022" +
      ":\n\rmodifier_keys\030\004 \003(\0162#.mozc.commands.K" +
      "eyEvent.ModifierKey\022\023\n\013probability\030\n \001(\001" +
      "\"\225\007\n\nSpecialKey\022\021\n\rNO_SPECIALKEY\020\000\022\t\n\005DI" +
      "GIT\020\001\022\006\n\002ON\020\002\022\007\n\003OFF\020\003\022\t\n\005SPACE\020\004\022\t\n\005ENT" +
      "ER\020\005\022\010\n\004LEFT\020\006\022\t\n\005RIGHT\020\007\022\006\n\002UP\020\010\022\010\n\004DOW" +
      "N\020\t\022\n\n\006ESCAPE\020\n\022\007\n\003DEL\020\013\022\r\n\tBACKSPACE\020\014\022" +
      "\n\n\006HENKAN\020\r\022\014\n\010MUHENKAN\020\016\022\010\n\004KANA\020\017\022\010\n\004H" +
      "OME\020\020\022\007\n\003END\020\021\022\007\n\003TAB\020\022\022\006\n\002F1\020\023\022\006\n\002F2\020\024\022" +
      "\006\n\002F3\020\025\022\006\n\002F4\020\026\022\006\n\002F5\020\027\022\006\n\002F6\020\030\022\006\n\002F7\020\031\022" +
      "\006\n\002F8\020\032\022\006\n\002F9\020\033\022\007\n\003F10\020\034\022\007\n\003F11\020\035\022\007\n\003F12" +
      "\020\036\022\013\n\007PAGE_UP\020\037\022\r\n\tPAGE_DOWN\020 \022\n\n\006INSERT" +
      "\020!\022\007\n\003F13\020\"\022\007\n\003F14\020#\022\007\n\003F15\020$\022\007\n\003F16\020%\022\007" +
      "\n\003F17\020&\022\007\n\003F18\020\'\022\007\n\003F19\020(\022\007\n\003F20\020)\022\007\n\003F2" +
      "1\020*\022\007\n\003F22\020+\022\007\n\003F23\020,\022\007\n\003F24\020-\022\010\n\004EISU\020." +
      "\022\013\n\007NUMPAD0\020/\022\013\n\007NUMPAD1\0200\022\013\n\007NUMPAD2\0201\022" +
      "\013\n\007NUMPAD3\0202\022\013\n\007NUMPAD4\0203\022\013\n\007NUMPAD5\0204\022\013" +
      "\n\007NUMPAD6\0205\022\013\n\007NUMPAD7\0206\022\013\n\007NUMPAD8\0207\022\013\n" +
      "\007NUMPAD9\0208\022\014\n\010MULTIPLY\0209\022\007\n\003ADD\020:\022\r\n\tSEP" +
      "ARATOR\020;\022\014\n\010SUBTRACT\020<\022\013\n\007DECIMAL\020=\022\n\n\006D" +
      "IVIDE\020>\022\n\n\006EQUALS\020?\022\016\n\nTEXT_INPUT\020@\022\013\n\007H" +
      "ANKAKU\020A\022\t\n\005KANJI\020B\022\014\n\010KATAKANA\020C\022\r\n\tCAP" +
      "S_LOCK\020D\022\021\n\rUNDEFINED_KEY\020E\022\t\n\005COMMA\020F\022\t" +
      "\n\005CLEAR\020G\022\020\n\014VIRTUAL_LEFT\020H\022\021\n\rVIRTUAL_R" +
      "IGHT\020I\022\021\n\rVIRTUAL_ENTER\020J\022\016\n\nVIRTUAL_UP\020" +
      "K\022\020\n\014VIRTUAL_DOWN\020L\022\023\n\017NUM_SPECIALKEYS\020M" +
      "\"\261\001\n\013ModifierKey\022\010\n\004CTRL\020\001\022\007\n\003ALT\020\002\022\t\n\005S" +
      "HIFT\020\004\022\014\n\010KEY_DOWN\020\010\022\n\n\006KEY_UP\020\020\022\r\n\tLEFT" +
      "_CTRL\020 \022\014\n\010LEFT_ALT\020@\022\017\n\nLEFT_SHIFT\020\200\001\022\017" +
      "\n\nRIGHT_CTRL\020\200\002\022\016\n\tRIGHT_ALT\020\200\004\022\020\n\013RIGHT" +
      "_SHIFT\020\200\010\022\t\n\004CAPS\020\200\020\":\n\nInputStyle\022\017\n\013FO" +
      "LLOW_MODE\020\000\022\t\n\005AS_IS\020\001\022\020\n\014DIRECT_INPUT\020\002" +
      "\"\265\007\n\016SessionCommand\0227\n\004type\030\001 \002(\0162).mozc" +
      ".commands.SessionCommand.CommandType\022\n\n\002" +
      "id\030\002 \001(\005\0228\n\020composition_mode\030\003 \001(\0162\036.moz" +
      "c.commands.CompositionMode\022\014\n\004text\030\004 \001(\t" +
      "\022\027\n\017cursor_position\030\005 \001(\r\022J\n\022composition" +
      "_events\030\013 \003(\0132..mozc.commands.SessionCom" +
      "mand.CompositionEvent\032C\n\020CompositionEven" +
      "t\022\032\n\022composition_string\030\001 \001(\t\022\023\n\013probabi" +
      "lity\030\002 \001(\001\"\315\004\n\013CommandType\022\010\n\004NONE\020\000\022\n\n\006" +
      "REVERT\020\001\022\n\n\006SUBMIT\020\002\022\024\n\020SELECT_CANDIDATE" +
      "\020\003\022\027\n\023HIGHLIGHT_CANDIDATE\020\004\022\025\n\021SWITCH_IN" +
      "PUT_MODE\020\005\022\016\n\nGET_STATUS\020\006\022\024\n\020SUBMIT_CAN" +
      "DIDATE\020\007\022\023\n\017CONVERT_REVERSE\020\010\022\010\n\004UNDO\020\t\022" +
      "\021\n\rRESET_CONTEXT\020\n\022\017\n\013MOVE_CURSOR\020\013\022\033\n\027S" +
      "WITCH_INPUT_FIELD_TYPE\020\014\022\022\n\016UNDO_OR_REWI" +
      "ND\020\016\022\023\n\017COMMIT_RAW_TEXT\020\023\022\025\n\021CONVERT_PRE" +
      "V_PAGE\020\024\022\025\n\021CONVERT_NEXT_PAGE\020\025\022\017\n\013TURN_" +
      "ON_IME\020\026\022\020\n\014TURN_OFF_IME\020\027\022!\n\035DELETE_CAN" +
      "DIDATE_FROM_HISTORY\020\030\022\025\n\021STOP_KEY_TOGGLI" +
      "NG\020\031\022\026\n\022UPDATE_COMPOSITION\020\032\"\004\010\r\020\r\"\004\010\017\020\017" +
      "\"\004\010\020\020\020\"\004\010\021\020\021\"\004\010\022\020\022*\021USAGE_STATS_EVENT*\021E" +
      "XPAND_SUGGESTION*\023SEND_CARET_LOCATION*\031S" +
      "END_LANGUAGE_BAR_COMMAND*\020GET_ASYNC_RESU" +
      "LTJ\004\010\006\020\007J\004\010\007\020\010J\004\010\t\020\nJ\004\010\010\020\tJ\004\010\n\020\013\"\223\002\n\007Con" +
      "text\022\026\n\016preceding_text\030\001 \001(\t\022\026\n\016followin" +
      "g_text\030\002 \001(\t\022\"\n\023suppress_suggestion\030\003 \001(" +
      "\010:\005false\022?\n\020input_field_type\030\004 \001(\0162%.moz" +
      "c.commands.Context.InputFieldType\022\023\n\010rev" +
      "ision\030\005 \001(\005:\0010\022\035\n\025experimental_features\030" +
      "d \003(\t\"?\n\016InputFieldType\022\n\n\006NORMAL\020\001\022\014\n\010P" +
      "ASSWORD\020\002\022\007\n\003TEL\020\003\022\n\n\006NUMBER\020\004\"\320\001\n\nCapab" +
      "ility\022h\n\rtext_deletion\030\001 \001(\01624.mozc.comm" +
      "ands.Capability.TextDeletionCapabilityTy" +
      "pe:\033NO_TEXT_DELETION_CAPABILITY\"X\n\032TextD" +
      "eletionCapabilityType\022\037\n\033NO_TEXT_DELETIO" +
      "N_CAPABILITY\020\000\022\031\n\025DELETE_PRECEDING_TEXT\020" +
      "\001\"\201\010\n\027DecoderExperimentParams\022$\n\031variati" +
      "on_character_types\030\010 \001(\r:\0010\0221\n&typing_co" +
      "rrection_result_reranker_mode\030_ \001(\005:\0010\022A" +
      "\n6typing_correction_result_reranker_inte" +
      "rpolation_weight\030d \001(\002:\0010\022B\n7typing_corr" +
      "ection_result_reranker_literal_on_top_we" +
      "ight\030e \001(\002:\0010\0224\n)typing_correction_apply" +
      "_user_history_size\030U \001(\005:\0010\0223\n$disable_z" +
      "ero_query_suffix_prediction\030$ \001(\010:\005false" +
      "\0224\n)user_history_prediction_max_char_cov" +
      "erage\030R \001(\005:\0010\0221\n&english_variation_spac" +
      "e_insertion_mode\0307 \001(\005:\0010\022.\n#candidate_c" +
      "onsistency_cost_max_diff\030? \001(\005:\0010\022+\n max" +
      "_composition_event_to_process\030@ \001(\005:\0012\022$" +
      "\n\031katakana_promotion_offset\030S \001(\005:\0015\022:\n," +
      "handwriting_conversion_candidate_cost_of" +
      "fset\030f \001(\005:\0041151\022/\n$suffix_nwp_transitio" +
      "n_cost_threshold\030k \001(\005:\0010\022,\n!user_histor" +
      "y_max_suggestion_trial\030l \001(\005:\0010\022+\n user_" +
      "history_entry_lifetime_days\030m \001(\005:\0010\022(\n\035" +
      "user_history_cache_store_size\030n \001(\005:\0010\022+" +
      "\n user_history_partial_revert_mode\030} \001(\005" +
      ":\0010\"<\n\026VariationCharacterType\022\020\n\014NO_VARI" +
      "ATION\020\000\022\020\n\014SVS_JAPANESE\020\001\"L\n\026BigramNwpFi" +
      "lteringMode\022\013\n\007DEFAULT\020\000\022\025\n\021FILTER_SAME_" +
      "CTYPE\020\001\022\016\n\nFILTER_ALL\020\002J\004\010\001\020\002\"\274\025\n\007Reques" +
      "t\022$\n\025zero_query_suggestion\030\001 \001(\010:\005false\022" +
      "\037\n\020mixed_conversion\030\002 \001(\010:\005false\022X\n\025spec" +
      "ial_romanji_table\030\004 \001(\0162*.mozc.commands." +
      "Request.SpecialRomanjiTable:\rDEFAULT_TAB" +
      "LE\022o\n\025space_on_alphanumeric\030\006 \001(\0162*.mozc" +
      ".commands.Request.SpaceOnAlphanumeric:$S" +
      "PACE_OR_CONVERT_KEEPING_COMPOSITION\022\025\n\rk" +
      "eyboard_name\030\007 \001(\t\0225\n\'update_input_mode_" +
      "from_surrounding_text\030\010 \001(\010:\004true\0223\n$kan" +
      "a_modifier_insensitive_conversion\030\t \001(\010:" +
      "\005false\022&\n\027auto_partial_suggestion\030\n \001(\010:" +
      "\005false\022$\n\031emoji_rewriter_capability\030\014 \001(" +
      "\005:\0011\022W\n\026crossing_edge_behavior\030\r \001(\0162+.m" +
      "ozc.commands.Request.CrossingEdgeBehavio" +
      "r:\nDO_NOTHING\022p\n\024language_aware_input\030\016 " +
      "\001(\01621.mozc.commands.Request.LanguageAwar" +
      "eInputBehavior:\037DEFAULT_LANGUAGE_AWARE_B" +
      "EHAVIOR\022\036\n\023candidate_page_size\030\017 \001(\005:\0019\022" +
      "\035\n\025candidates_size_limit\030\020 \001(\005\022I\n\031decode" +
      "r_experiment_params\030\021 \001(\0132&.mozc.command" +
      "s.DecoderExperimentParams\022-\n\036fill_incogn" +
      "ito_candidate_words\030\022 \001(\010:\005false\022&\n\027enab" +
      "le_a11y_description\030\024 \001(\010:\005false\022m\n&addi" +
      "tional_renderable_character_groups\030\025 \003(\016" +
      "29.mozc.commands.Request.AdditionalRende" +
      "rableCharacterGroupB\002\020\001\022\035\n\016is_handwritin" +
      "g\030\026 \001(\010:\005false\022 \n\021is_incognito_mode\030\027 \001(" +
      "\010:\005false\"\205\007\n\023SpecialRomanjiTable\022\021\n\rDEFA" +
      "ULT_TABLE\020\000\022\033\n\027TWELVE_KEYS_TO_HIRAGANA\020\n" +
      "\022&\n!TWELVE_KEYS_TO_HIRAGANA_INTUITIVE\020\220N" +
      "\022!\n\035TWELVE_KEYS_TO_HALFWIDTHASCII\020\013\022\025\n\021F" +
      "LICK_TO_HIRAGANA\020\r\022 \n\033FLICK_TO_HIRAGANA_" +
      "INTUITIVE\020\222N\022\033\n\027FLICK_TO_HALFWIDTHASCII\020" +
      "\016\022\037\n\033FLICK_TO_HALFWIDTHASCII_IOS\020,\022\023\n\017FL" +
      "ICK_TO_NUMBER\020+\022\034\n\030TOGGLE_FLICK_TO_HIRAG" +
      "ANA\020\020\022\'\n\"TOGGLE_FLICK_TO_HIRAGANA_INTUIT" +
      "IVE\020\221N\022\032\n\026TOGGLE_FLICK_TO_NUMBER\020*\022&\n\"TO" +
      "GGLE_FLICK_TO_HALFWIDTHASCII_IOS\020-\022\"\n\036TO" +
      "GGLE_FLICK_TO_HALFWIDTHASCII\020\021\022\035\n\031QWERTY" +
      "_MOBILE_TO_HIRAGANA\020\024\022#\n\037QWERTY_MOBILE_T" +
      "O_HALFWIDTHASCII\020\026\022\025\n\021GODAN_TO_HIRAGANA\020" +
      "\036\022\033\n\027GODAN_TO_HALFWIDTHASCII\020\037\022\027\n\023NOTOUC" +
      "H_TO_HIRAGANA\020(\022\035\n\031NOTOUCH_TO_HALFWIDTHA" +
      "SCII\020)\022\032\n\026FIFTY_KEYS_TO_HIRAGANA\020.\"\004\010\014\020\014" +
      "\"\004\010\017\020\017\"\004\010 \020 \"\004\010\025\020\025\"\004\010\022\020\022\"\004\010/\0202*\025TWELVE_K" +
      "EYS_TO_NUMBER*\017GODAN_TO_NUMBER* QWERTY_M" +
      "OBILE_TO_HIRAGANA_NUMBER*\022TWELVE_KEYS_TA" +
      "BLET*\030TWELVE_KEYS_TABLET_FLICK*$TWELVE_K" +
      "EYS_TABLET_TO_HALFWIDTHASCII**TWELVE_KEY" +
      "S_TABLET_FLICK_TO_HALFWIDTHASCII\"x\n\023Spac" +
      "eOnAlphanumeric\022(\n$SPACE_OR_CONVERT_KEEP" +
      "ING_COMPOSITION\020\000\022+\n\'SPACE_OR_CONVERT_CO" +
      "MMITTING_COMPOSITION\020\001\022\n\n\006COMMIT\020\002\"`\n\022Re" +
      "writerCapability\022\021\n\rNOT_AVAILABLE\020\000\022\016\n\nC" +
      "ONVERSION\020\001\022\016\n\nPREDICTION\020\002\022\016\n\nSUGGESTIO" +
      "N\020\004\022\007\n\003ALL\020\007\"D\n\024CrossingEdgeBehavior\022\016\n\n" +
      "DO_NOTHING\020\000\022\034\n\030COMMIT_WITHOUT_CONSUMING" +
      "\020\001\"}\n\032LanguageAwareInputBehavior\022#\n\037DEFA" +
      "ULT_LANGUAGE_AWARE_BEHAVIOR\020\000\022\033\n\027NO_LANG" +
      "UAGE_AWARE_INPUT\020\001\022\035\n\031LANGUAGE_AWARE_SUG" +
      "GESTION\020\002\"\266\002\n\"AdditionalRenderableCharac" +
      "terGroup\022\t\n\005EMPTY\020\000\022\027\n\023KANA_SUPPLEMENT_6" +
      "_0\020\002\022,\n(KANA_SUPPLEMENT_AND_KANA_EXTENDE" +
      "D_A_10_0\020\003\022\030\n\024KANA_EXTENDED_A_14_0\020\004\022\016\n\n" +
      "EMOJI_12_1\020\005\022\016\n\nEMOJI_13_0\020\006\022\016\n\nEMOJI_13" +
      "_1\020\007\022\016\n\nEMOJI_14_0\020\010\022\016\n\nEMOJI_15_0\020\t\022\016\n\n" +
      "EMOJI_15_1\020\014\022\016\n\nEMOJI_16_0\020\r\022\033\n\027EGYPTIAN" +
      "_HIEROGLYPH_5_2\020\n\022\021\n\rIVS_CHARACTER\020\013\"\004\010\001" +
      "\020\001J\004\010\003\020\004J\004\010\013\020\014J\004\010\023\020\024\">\n\017ApplicationInfo\022" +
      "\022\n\nprocess_id\030\001 \001(\r\022\021\n\tthread_id\030\002 \001(\rJ\004" +
      "\010\003\020\004\"\265\014\n\005Input\022.\n\004type\030\001 \002(\0162 .mozc.comm" +
      "ands.Input.CommandType\022\016\n\002id\030\002 \001(\004B\0020\001\022$" +
      "\n\003key\030\003 \001(\0132\027.mozc.commands.KeyEvent\022.\n\007" +
      "command\030\004 \001(\0132\035.mozc.commands.SessionCom" +
      "mand\022#\n\006config\030\005 \001(\0132\023.mozc.config.Confi" +
      "g\022\'\n\007context\030\006 \001(\0132\026.mozc.commands.Conte" +
      "xt\022-\n\ncapability\030\007 \001(\0132\031.mozc.commands.C" +
      "apability\0228\n\020application_info\030\010 \001(\0132\036.mo" +
      "zc.commands.ApplicationInfo\022\'\n\007request\030\t" +
      " \001(\0132\026.mozc.commands.Request\0225\n\014touch_ev" +
      "ents\030\014 \003(\0132\037.mozc.commands.Input.TouchEv" +
      "ent\022L\n\027user_dictionary_command\030\r \001(\0132+.m" +
      "ozc.user_dictionary.UserDictionaryComman" +
      "d\022 \n\022request_suggestion\030\016 \001(\010:\004true\0228\n\025e" +
      "ngine_reload_request\030\017 \001(\0132\031.mozc.Engine" +
      "ReloadRequest\032j\n\rTouchPosition\0220\n\006action" +
      "\030\001 \001(\0162 .mozc.commands.Input.TouchAction" +
      "\022\t\n\001x\030\002 \001(\002\022\t\n\001y\030\003 \001(\002\022\021\n\ttimestamp\030\004 \001(" +
      "\003\032S\n\nTouchEvent\022\021\n\tsource_id\030\001 \001(\r\0222\n\006st" +
      "roke\030\002 \003(\0132\".mozc.commands.Input.TouchPo" +
      "sition\"\304\005\n\013CommandType\022\010\n\004NONE\020\000\022\022\n\016CREA" +
      "TE_SESSION\020\001\022\022\n\016DELETE_SESSION\020\002\022\014\n\010SEND" +
      "_KEY\020\003\022\021\n\rTEST_SEND_KEY\020\004\022\020\n\014SEND_COMMAN" +
      "D\020\005\022\016\n\nGET_CONFIG\020\006\022\016\n\nSET_CONFIG\020\007\022\017\n\013S" +
      "ET_REQUEST\020\021\022\r\n\tSYNC_DATA\020\010\022\014\n\010SHUTDOWN\020" +
      "\t\022\n\n\006RELOAD\020\n\022\023\n\017RELOAD_AND_WAIT\020\017\022\026\n\022CL" +
      "EAR_USER_HISTORY\020\013\022\031\n\025CLEAR_USER_PREDICT" +
      "ION\020\014\022 \n\034CLEAR_UNUSED_USER_PREDICTION\020\020\022" +
      "\013\n\007CLEANUP\020\r\022\020\n\014NO_OPERATION\020\016\022 \n\034SEND_U" +
      "SER_DICTIONARY_COMMAND\020\032\022\036\n\032SEND_ENGINE_" +
      "RELOAD_REQUEST\020\033\022\035\n\031RELOAD_SUPPLEMENTAL_" +
      "MODEL\020\036\022\026\n\022GET_SERVER_VERSION\020\023\022\023\n\017NUM_O" +
      "F_COMMANDS\020\037\"\004\010\026\020\026\"\004\010\022\020\022\"\004\010\027\020\027\"\004\010\030\020\030\"\004\010\024" +
      "\020\024\"\004\010\025\020\025\"\004\010\031\020\031\"\004\010\034\020\034\"\004\010\035\020\035*\022SET_IMPOSED_" +
      "CONFIG*\020START_CLOUD_SYNC*\025GET_CLOUD_SYNC" +
      "_STATUS*\rADD_AUTH_CODE*\021INSERT_TO_STORAG" +
      "E*\025READ_ALL_FROM_STORAGE*\rCLEAR_STORAGE*" +
      "\016CHECK_SPELLING*\024RELOAD_SPELL_CHECKER\";\n" +
      "\013TouchAction\022\016\n\nTOUCH_DOWN\020\001\022\016\n\nTOUCH_MO" +
      "VE\020\002\022\014\n\010TOUCH_UP\020\003J\004\010\n\020\013J\004\010\013\020\014J\004\010\020\020\021\"K\n\013" +
      "ResultToken\022\r\n\005value\030\001 \001(\t\022\013\n\003key\030\002 \001(\t\022" +
      "\017\n\003lid\030\003 \001(\005:\002-1\022\017\n\003rid\030\004 \001(\005:\002-1\"\276\001\n\006Re" +
      "sult\022.\n\004type\030\001 \002(\0162 .mozc.commands.Resul" +
      "t.ResultType\022\r\n\005value\030\002 \002(\t\022\013\n\003key\030\003 \001(\t" +
      "\022\030\n\rcursor_offset\030\004 \001(\005:\0010\022*\n\006tokens\030\005 \003" +
      "(\0132\032.mozc.commands.ResultToken\"\"\n\nResult" +
      "Type\022\010\n\004NONE\020\000\022\n\n\006STRING\020\001\"\271\002\n\007Preedit\022\016" +
      "\n\006cursor\030\001 \002(\r\022/\n\007segment\030\002 \003(\n2\036.mozc.c" +
      "ommands.Preedit.Segment\022\034\n\024highlighted_p" +
      "osition\030\003 \001(\r\022\034\n\ris_toggleable\030\004 \001(\010:\005fa" +
      "lse\032\260\001\n\007Segment\022=\n\nannotation\030\003 \002(\0162).mo" +
      "zc.commands.Preedit.Segment.Annotation\022\r" +
      "\n\005value\030\004 \002(\t\022\024\n\014value_length\030\005 \002(\r\022\013\n\003k" +
      "ey\030\006 \001(\t\"4\n\nAnnotation\022\010\n\004NONE\020\000\022\r\n\tUNDE" +
      "RLINE\020\001\022\r\n\tHIGHLIGHT\020\002\"\230\001\n\006Status\022\021\n\tact" +
      "ivated\030\001 \001(\010\022,\n\004mode\030\002 \001(\0162\036.mozc.comman" +
      "ds.CompositionMode\0225\n\rcomeback_mode\030\003 \001(" +
      "\0162\036.mozc.commands.CompositionMode\022\026\n\016und" +
      "o_available\030\032 \001(\010\"/\n\rDeletionRange\022\016\n\006of" +
      "fset\030\001 \001(\005\022\016\n\006length\030\002 \001(\005\"\232\013\n\006Output\022\016\n" +
      "\002id\030\001 \001(\004B\0020\001\022,\n\004mode\030\002 \001(\0162\036.mozc.comma" +
      "nds.CompositionMode\022\020\n\010consumed\030\003 \001(\010\022%\n" +
      "\006result\030\004 \001(\0132\025.mozc.commands.Result\022\'\n\007" +
      "preedit\030\005 \001(\0132\026.mozc.commands.Preedit\0228\n" +
      "\020candidate_window\030\006 \001(\0132\036.mozc.commands." +
      "CandidateWindow\022$\n\003key\030\007 \001(\0132\027.mozc.comm" +
      "ands.KeyEvent\022\013\n\003url\030\010 \001(\t\022#\n\006config\030\t \001" +
      "(\0132\023.mozc.config.Config\022B\n\016preedit_metho" +
      "d\030\n \001(\0162#.mozc.commands.Output.PreeditMe" +
      "thod:\005ASCII\022D\n\nerror_code\030\013 \001(\0162\037.mozc.c" +
      "ommands.Output.ErrorCode:\017SESSION_SUCCES" +
      "S\022%\n\006status\030\r \001(\0132\025.mozc.commands.Status" +
      "\0229\n\023all_candidate_words\030\016 \001(\0132\034.mozc.com" +
      "mands.CandidateList\0224\n\016deletion_range\030\020 " +
      "\001(\0132\034.mozc.commands.DeletionRange\022A\n\020lau" +
      "nch_tool_mode\030\021 \001(\0162\036.mozc.commands.Outp" +
      "ut.ToolMode:\007NO_TOOL\0220\n\010callback\030\022 \001(\0132\036" +
      ".mozc.commands.Output.Callback\022Y\n\036user_d" +
      "ictionary_command_status\030\025 \001(\01321.mozc.us" +
      "er_dictionary.UserDictionaryCommandStatu" +
      "s\022:\n\026engine_reload_response\030\026 \001(\0132\032.mozc" +
      ".EngineReloadResponse\022G\n!removed_candida" +
      "te_words_for_debug\030\027 \001(\0132\034.mozc.commands" +
      ".CandidateList\022?\n\031incognito_candidate_wo" +
      "rds\030\031 \001(\0132\034.mozc.commands.CandidateList\022" +
      "9\n\016server_version\030\032 \001(\0132!.mozc.commands." +
      "Output.VersionInfo\032Z\n\010Callback\0226\n\017sessio" +
      "n_command\030\001 \001(\0132\035.mozc.commands.SessionC" +
      "ommand\022\026\n\016delay_millisec\030\002 \001(\r\0329\n\013Versio" +
      "nInfo\022\024\n\014mozc_version\030\001 \001(\t\022\024\n\014data_vers" +
      "ion\030\002 \001(\t\"$\n\rPreeditMethod\022\t\n\005ASCII\020\000\022\010\n" +
      "\004KANA\020\001\"5\n\tErrorCode\022\023\n\017SESSION_SUCCESS\020" +
      "\000\022\023\n\017SESSION_FAILURE\020\001\"Y\n\010ToolMode\022\013\n\007NO" +
      "_TOOL\020\000\022\021\n\rCONFIG_DIALOG\020\001\022\023\n\017DICTIONARY" +
      "_TOOL\020\002\022\030\n\024WORD_REGISTER_DIALOG\020\003J\004\010\014\020\rJ" +
      "\004\010\017\020\020J\004\010\023\020\024J\004\010\024\020\025J\004\010\030\020\031\"U\n\007Command\022#\n\005in" +
      "put\030\001 \002(\0132\024.mozc.commands.Input\022%\n\006outpu" +
      "t\030\002 \001(\0132\025.mozc.commands.Output\"8\n\014MozcCo" +
      "mmands\022(\n\010commands\030\001 \003(\0132\026.mozc.commands" +
      ".Command\"7\n\013CommandList\022(\n\010commands\030\001 \003(" +
      "\0132\026.mozc.commands.Command*\212\001\n\017Compositio" +
      "nMode\022\n\n\006DIRECT\020\000\022\014\n\010HIRAGANA\020\001\022\021\n\rFULL_" +
      "KATAKANA\020\002\022\016\n\nHALF_ASCII\020\003\022\016\n\nFULL_ASCII" +
      "\020\004\022\021\n\rHALF_KATAKANA\020\005\022\027\n\023NUM_OF_COMPOSIT" +
      "IONS\020\006B?\n.org.mozc.android.inputmethod.j" +
      "apanese.protobufB\rProtoCommands"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.getDescriptor(),
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.getDescriptor(),
          org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.getDescriptor(),
          org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.getDescriptor(),
        });
    internal_static_mozc_commands_KeyEvent_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_mozc_commands_KeyEvent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_KeyEvent_descriptor,
        new java.lang.String[] { "KeyCode", "Modifiers", "SpecialKey", "ModifierKeys", "KeyString", "InputStyle", "Mode", "ProbableKeyEvent", "Activated", "TimestampMsec", });
    internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_descriptor =
      internal_static_mozc_commands_KeyEvent_descriptor.getNestedTypes().get(0);
    internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_KeyEvent_ProbableKeyEvent_descriptor,
        new java.lang.String[] { "KeyCode", "SpecialKey", "ModifierKeys", "Probability", });
    internal_static_mozc_commands_SessionCommand_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_mozc_commands_SessionCommand_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_SessionCommand_descriptor,
        new java.lang.String[] { "Type", "Id", "CompositionMode", "Text", "CursorPosition", "CompositionEvents", });
    internal_static_mozc_commands_SessionCommand_CompositionEvent_descriptor =
      internal_static_mozc_commands_SessionCommand_descriptor.getNestedTypes().get(0);
    internal_static_mozc_commands_SessionCommand_CompositionEvent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_SessionCommand_CompositionEvent_descriptor,
        new java.lang.String[] { "CompositionString", "Probability", });
    internal_static_mozc_commands_Context_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_mozc_commands_Context_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Context_descriptor,
        new java.lang.String[] { "PrecedingText", "FollowingText", "SuppressSuggestion", "InputFieldType", "Revision", "ExperimentalFeatures", });
    internal_static_mozc_commands_Capability_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_mozc_commands_Capability_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Capability_descriptor,
        new java.lang.String[] { "TextDeletion", });
    internal_static_mozc_commands_DecoderExperimentParams_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_mozc_commands_DecoderExperimentParams_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_DecoderExperimentParams_descriptor,
        new java.lang.String[] { "VariationCharacterTypes", "TypingCorrectionResultRerankerMode", "TypingCorrectionResultRerankerInterpolationWeight", "TypingCorrectionResultRerankerLiteralOnTopWeight", "TypingCorrectionApplyUserHistorySize", "DisableZeroQuerySuffixPrediction", "UserHistoryPredictionMaxCharCoverage", "EnglishVariationSpaceInsertionMode", "CandidateConsistencyCostMaxDiff", "MaxCompositionEventToProcess", "KatakanaPromotionOffset", "HandwritingConversionCandidateCostOffset", "SuffixNwpTransitionCostThreshold", "UserHistoryMaxSuggestionTrial", "UserHistoryEntryLifetimeDays", "UserHistoryCacheStoreSize", "UserHistoryPartialRevertMode", });
    internal_static_mozc_commands_Request_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_mozc_commands_Request_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Request_descriptor,
        new java.lang.String[] { "ZeroQuerySuggestion", "MixedConversion", "SpecialRomanjiTable", "SpaceOnAlphanumeric", "KeyboardName", "UpdateInputModeFromSurroundingText", "KanaModifierInsensitiveConversion", "AutoPartialSuggestion", "EmojiRewriterCapability", "CrossingEdgeBehavior", "LanguageAwareInput", "CandidatePageSize", "CandidatesSizeLimit", "DecoderExperimentParams", "FillIncognitoCandidateWords", "EnableA11YDescription", "AdditionalRenderableCharacterGroups", "IsHandwriting", "IsIncognitoMode", });
    internal_static_mozc_commands_ApplicationInfo_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_mozc_commands_ApplicationInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_ApplicationInfo_descriptor,
        new java.lang.String[] { "ProcessId", "ThreadId", });
    internal_static_mozc_commands_Input_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_mozc_commands_Input_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Input_descriptor,
        new java.lang.String[] { "Type", "Id", "Key", "Command", "Config", "Context", "Capability", "ApplicationInfo", "Request", "TouchEvents", "UserDictionaryCommand", "RequestSuggestion", "EngineReloadRequest", });
    internal_static_mozc_commands_Input_TouchPosition_descriptor =
      internal_static_mozc_commands_Input_descriptor.getNestedTypes().get(0);
    internal_static_mozc_commands_Input_TouchPosition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Input_TouchPosition_descriptor,
        new java.lang.String[] { "Action", "X", "Y", "Timestamp", });
    internal_static_mozc_commands_Input_TouchEvent_descriptor =
      internal_static_mozc_commands_Input_descriptor.getNestedTypes().get(1);
    internal_static_mozc_commands_Input_TouchEvent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Input_TouchEvent_descriptor,
        new java.lang.String[] { "SourceId", "Stroke", });
    internal_static_mozc_commands_ResultToken_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_mozc_commands_ResultToken_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_ResultToken_descriptor,
        new java.lang.String[] { "Value", "Key", "Lid", "Rid", });
    internal_static_mozc_commands_Result_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_mozc_commands_Result_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Result_descriptor,
        new java.lang.String[] { "Type", "Value", "Key", "CursorOffset", "Tokens", });
    internal_static_mozc_commands_Preedit_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_mozc_commands_Preedit_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Preedit_descriptor,
        new java.lang.String[] { "Cursor", "Segment", "HighlightedPosition", "IsToggleable", });
    internal_static_mozc_commands_Preedit_Segment_descriptor =
      internal_static_mozc_commands_Preedit_descriptor.getNestedTypes().get(0);
    internal_static_mozc_commands_Preedit_Segment_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Preedit_Segment_descriptor,
        new java.lang.String[] { "Annotation", "Value", "ValueLength", "Key", });
    internal_static_mozc_commands_Status_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_mozc_commands_Status_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Status_descriptor,
        new java.lang.String[] { "Activated", "Mode", "ComebackMode", "UndoAvailable", });
    internal_static_mozc_commands_DeletionRange_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_mozc_commands_DeletionRange_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_DeletionRange_descriptor,
        new java.lang.String[] { "Offset", "Length", });
    internal_static_mozc_commands_Output_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_mozc_commands_Output_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Output_descriptor,
        new java.lang.String[] { "Id", "Mode", "Consumed", "Result", "Preedit", "CandidateWindow", "Key", "Url", "Config", "PreeditMethod", "ErrorCode", "Status", "AllCandidateWords", "DeletionRange", "LaunchToolMode", "Callback", "UserDictionaryCommandStatus", "EngineReloadResponse", "RemovedCandidateWordsForDebug", "IncognitoCandidateWords", "ServerVersion", });
    internal_static_mozc_commands_Output_Callback_descriptor =
      internal_static_mozc_commands_Output_descriptor.getNestedTypes().get(0);
    internal_static_mozc_commands_Output_Callback_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Output_Callback_descriptor,
        new java.lang.String[] { "SessionCommand", "DelayMillisec", });
    internal_static_mozc_commands_Output_VersionInfo_descriptor =
      internal_static_mozc_commands_Output_descriptor.getNestedTypes().get(1);
    internal_static_mozc_commands_Output_VersionInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Output_VersionInfo_descriptor,
        new java.lang.String[] { "MozcVersion", "DataVersion", });
    internal_static_mozc_commands_Command_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_mozc_commands_Command_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_Command_descriptor,
        new java.lang.String[] { "Input", "Output", });
    internal_static_mozc_commands_MozcCommands_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_mozc_commands_MozcCommands_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_MozcCommands_descriptor,
        new java.lang.String[] { "Commands", });
    internal_static_mozc_commands_CommandList_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_mozc_commands_CommandList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_commands_CommandList_descriptor,
        new java.lang.String[] { "Commands", });
    org.mozc.android.inputmethod.japanese.protobuf.ProtoCandidateWindow.getDescriptor();
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.getDescriptor();
    org.mozc.android.inputmethod.japanese.protobuf.ProtoEngineBuilder.getDescriptor();
    org.mozc.android.inputmethod.japanese.protobuf.ProtoUserDictionaryStorage.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
