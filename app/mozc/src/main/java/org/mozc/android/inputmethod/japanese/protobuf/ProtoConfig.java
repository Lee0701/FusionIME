// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/config.proto

package org.mozc.android.inputmethod.japanese.protobuf;

public final class ProtoConfig {
  private ProtoConfig() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface GeneralConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.config.GeneralConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     * @return Whether the configVersion field is set.
     */
    boolean hasConfigVersion();
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     * @return The configVersion.
     */
    int getConfigVersion();

    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return Whether the lastModifiedProductVersion field is set.
     */
    boolean hasLastModifiedProductVersion();
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return The lastModifiedProductVersion.
     */
    java.lang.String getLastModifiedProductVersion();
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return The bytes for lastModifiedProductVersion.
     */
    com.google.protobuf.ByteString
        getLastModifiedProductVersionBytes();

    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     * @return Whether the lastModifiedTime field is set.
     */
    boolean hasLastModifiedTime();
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     * @return The lastModifiedTime.
     */
    long getLastModifiedTime();

    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return Whether the platform field is set.
     */
    boolean hasPlatform();
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return The platform.
     */
    java.lang.String getPlatform();
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return The bytes for platform.
     */
    com.google.protobuf.ByteString
        getPlatformBytes();

    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return Whether the uiLocale field is set.
     */
    boolean hasUiLocale();
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return The uiLocale.
     */
    java.lang.String getUiLocale();
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return The bytes for uiLocale.
     */
    com.google.protobuf.ByteString
        getUiLocaleBytes();

    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     * @return Whether the uploadUsageStats field is set.
     */
    boolean hasUploadUsageStats();
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     * @return The uploadUsageStats.
     */
    boolean getUploadUsageStats();
  }
  /**
   * <pre>
   *&#47;///////////////////////////////////////////////////////////
   * General config (1-9)
   * </pre>
   *
   * Protobuf type {@code mozc.config.GeneralConfig}
   */
  public static final class GeneralConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.config.GeneralConfig)
      GeneralConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GeneralConfig.newBuilder() to construct.
    private GeneralConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GeneralConfig() {
      lastModifiedProductVersion_ = "0.0.0.0";
      platform_ = "";
      uiLocale_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new GeneralConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder.class);
    }

    private int bitField0_;
    public static final int CONFIG_VERSION_FIELD_NUMBER = 1;
    private int configVersion_ = 0;
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     * @return Whether the configVersion field is set.
     */
    @java.lang.Override
    public boolean hasConfigVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     * @return The configVersion.
     */
    @java.lang.Override
    public int getConfigVersion() {
      return configVersion_;
    }

    public static final int LAST_MODIFIED_PRODUCT_VERSION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object lastModifiedProductVersion_ = "0.0.0.0";
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return Whether the lastModifiedProductVersion field is set.
     */
    @java.lang.Override
    public boolean hasLastModifiedProductVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return The lastModifiedProductVersion.
     */
    @java.lang.Override
    public java.lang.String getLastModifiedProductVersion() {
      java.lang.Object ref = lastModifiedProductVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          lastModifiedProductVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     * @return The bytes for lastModifiedProductVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLastModifiedProductVersionBytes() {
      java.lang.Object ref = lastModifiedProductVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        lastModifiedProductVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LAST_MODIFIED_TIME_FIELD_NUMBER = 3;
    private long lastModifiedTime_ = 0L;
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     * @return Whether the lastModifiedTime field is set.
     */
    @java.lang.Override
    public boolean hasLastModifiedTime() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
     * @return The lastModifiedTime.
     */
    @java.lang.Override
    public long getLastModifiedTime() {
      return lastModifiedTime_;
    }

    public static final int PLATFORM_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object platform_ = "";
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return Whether the platform field is set.
     */
    @java.lang.Override
    public boolean hasPlatform() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return The platform.
     */
    @java.lang.Override
    public java.lang.String getPlatform() {
      java.lang.Object ref = platform_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          platform_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * These fields are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     * @return The bytes for platform.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPlatformBytes() {
      java.lang.Object ref = platform_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        platform_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UI_LOCALE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object uiLocale_ = "";
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return Whether the uiLocale field is set.
     */
    @java.lang.Override
    public boolean hasUiLocale() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return The uiLocale.
     */
    @java.lang.Override
    public java.lang.String getUiLocale() {
      java.lang.Object ref = uiLocale_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          uiLocale_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     * @return The bytes for uiLocale.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUiLocaleBytes() {
      java.lang.Object ref = uiLocale_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uiLocale_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UPLOAD_USAGE_STATS_FIELD_NUMBER = 6;
    private boolean uploadUsageStats_ = false;
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     * @return Whether the uploadUsageStats field is set.
     */
    @java.lang.Override
    public boolean hasUploadUsageStats() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     * @return The uploadUsageStats.
     */
    @java.lang.Override
    public boolean getUploadUsageStats() {
      return uploadUsageStats_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(1, configVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, lastModifiedProductVersion_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(3, lastModifiedTime_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, platform_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, uiLocale_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(6, uploadUsageStats_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, configVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, lastModifiedProductVersion_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, lastModifiedTime_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, platform_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, uiLocale_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, uploadUsageStats_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig) obj;

      if (hasConfigVersion() != other.hasConfigVersion()) return false;
      if (hasConfigVersion()) {
        if (getConfigVersion()
            != other.getConfigVersion()) return false;
      }
      if (hasLastModifiedProductVersion() != other.hasLastModifiedProductVersion()) return false;
      if (hasLastModifiedProductVersion()) {
        if (!getLastModifiedProductVersion()
            .equals(other.getLastModifiedProductVersion())) return false;
      }
      if (hasLastModifiedTime() != other.hasLastModifiedTime()) return false;
      if (hasLastModifiedTime()) {
        if (getLastModifiedTime()
            != other.getLastModifiedTime()) return false;
      }
      if (hasPlatform() != other.hasPlatform()) return false;
      if (hasPlatform()) {
        if (!getPlatform()
            .equals(other.getPlatform())) return false;
      }
      if (hasUiLocale() != other.hasUiLocale()) return false;
      if (hasUiLocale()) {
        if (!getUiLocale()
            .equals(other.getUiLocale())) return false;
      }
      if (hasUploadUsageStats() != other.hasUploadUsageStats()) return false;
      if (hasUploadUsageStats()) {
        if (getUploadUsageStats()
            != other.getUploadUsageStats()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasConfigVersion()) {
        hash = (37 * hash) + CONFIG_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getConfigVersion();
      }
      if (hasLastModifiedProductVersion()) {
        hash = (37 * hash) + LAST_MODIFIED_PRODUCT_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getLastModifiedProductVersion().hashCode();
      }
      if (hasLastModifiedTime()) {
        hash = (37 * hash) + LAST_MODIFIED_TIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getLastModifiedTime());
      }
      if (hasPlatform()) {
        hash = (37 * hash) + PLATFORM_FIELD_NUMBER;
        hash = (53 * hash) + getPlatform().hashCode();
      }
      if (hasUiLocale()) {
        hash = (37 * hash) + UI_LOCALE_FIELD_NUMBER;
        hash = (53 * hash) + getUiLocale().hashCode();
      }
      if (hasUploadUsageStats()) {
        hash = (37 * hash) + UPLOAD_USAGE_STATS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUploadUsageStats());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * General config (1-9)
     * </pre>
     *
     * Protobuf type {@code mozc.config.GeneralConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.config.GeneralConfig)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        configVersion_ = 0;
        lastModifiedProductVersion_ = "0.0.0.0";
        lastModifiedTime_ = 0L;
        platform_ = "";
        uiLocale_ = "";
        uploadUsageStats_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.configVersion_ = configVersion_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.lastModifiedProductVersion_ = lastModifiedProductVersion_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.lastModifiedTime_ = lastModifiedTime_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.platform_ = platform_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.uiLocale_ = uiLocale_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.uploadUsageStats_ = uploadUsageStats_;
          to_bitField0_ |= 0x00000020;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance()) return this;
        if (other.hasConfigVersion()) {
          setConfigVersion(other.getConfigVersion());
        }
        if (other.hasLastModifiedProductVersion()) {
          lastModifiedProductVersion_ = other.lastModifiedProductVersion_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasLastModifiedTime()) {
          setLastModifiedTime(other.getLastModifiedTime());
        }
        if (other.hasPlatform()) {
          platform_ = other.platform_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasUiLocale()) {
          uiLocale_ = other.uiLocale_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasUploadUsageStats()) {
          setUploadUsageStats(other.getUploadUsageStats());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                configVersion_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                lastModifiedProductVersion_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                lastModifiedTime_ = input.readUInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                platform_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                uiLocale_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 48: {
                uploadUsageStats_ = input.readBool();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int configVersion_ ;
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       * @return Whether the configVersion field is set.
       */
      @java.lang.Override
      public boolean hasConfigVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       * @return The configVersion.
       */
      @java.lang.Override
      public int getConfigVersion() {
        return configVersion_;
      }
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       * @param value The configVersion to set.
       * @return This builder for chaining.
       */
      public Builder setConfigVersion(int value) {
        
        configVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearConfigVersion() {
        bitField0_ = (bitField0_ & ~0x00000001);
        configVersion_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object lastModifiedProductVersion_ = "0.0.0.0";
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @return Whether the lastModifiedProductVersion field is set.
       */
      public boolean hasLastModifiedProductVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @return The lastModifiedProductVersion.
       */
      public java.lang.String getLastModifiedProductVersion() {
        java.lang.Object ref = lastModifiedProductVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            lastModifiedProductVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @return The bytes for lastModifiedProductVersion.
       */
      public com.google.protobuf.ByteString
          getLastModifiedProductVersionBytes() {
        java.lang.Object ref = lastModifiedProductVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          lastModifiedProductVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @param value The lastModifiedProductVersion to set.
       * @return This builder for chaining.
       */
      public Builder setLastModifiedProductVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        lastModifiedProductVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @return This builder for chaining.
       */
      public Builder clearLastModifiedProductVersion() {
        lastModifiedProductVersion_ = getDefaultInstance().getLastModifiedProductVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       * @param value The bytes for lastModifiedProductVersion to set.
       * @return This builder for chaining.
       */
      public Builder setLastModifiedProductVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        lastModifiedProductVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private long lastModifiedTime_ ;
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
       * @return Whether the lastModifiedTime field is set.
       */
      @java.lang.Override
      public boolean hasLastModifiedTime() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
       * @return The lastModifiedTime.
       */
      @java.lang.Override
      public long getLastModifiedTime() {
        return lastModifiedTime_;
      }
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
       * @param value The lastModifiedTime to set.
       * @return This builder for chaining.
       */
      public Builder setLastModifiedTime(long value) {
        
        lastModifiedTime_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0, jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearLastModifiedTime() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lastModifiedTime_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object platform_ = "";
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @return Whether the platform field is set.
       */
      public boolean hasPlatform() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @return The platform.
       */
      public java.lang.String getPlatform() {
        java.lang.Object ref = platform_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            platform_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @return The bytes for platform.
       */
      public com.google.protobuf.ByteString
          getPlatformBytes() {
        java.lang.Object ref = platform_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          platform_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @param value The platform to set.
       * @return This builder for chaining.
       */
      public Builder setPlatform(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        platform_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @return This builder for chaining.
       */
      public Builder clearPlatform() {
        platform_ = getDefaultInstance().getPlatform();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * These fields are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       * @param value The bytes for platform to set.
       * @return This builder for chaining.
       */
      public Builder setPlatformBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        platform_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object uiLocale_ = "";
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @return Whether the uiLocale field is set.
       */
      public boolean hasUiLocale() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @return The uiLocale.
       */
      public java.lang.String getUiLocale() {
        java.lang.Object ref = uiLocale_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            uiLocale_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @return The bytes for uiLocale.
       */
      public com.google.protobuf.ByteString
          getUiLocaleBytes() {
        java.lang.Object ref = uiLocale_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          uiLocale_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @param value The uiLocale to set.
       * @return This builder for chaining.
       */
      public Builder setUiLocale(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        uiLocale_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @return This builder for chaining.
       */
      public Builder clearUiLocale() {
        uiLocale_ = getDefaultInstance().getUiLocale();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       * @param value The bytes for uiLocale to set.
       * @return This builder for chaining.
       */
      public Builder setUiLocaleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        uiLocale_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private boolean uploadUsageStats_ ;
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       * @return Whether the uploadUsageStats field is set.
       */
      @java.lang.Override
      public boolean hasUploadUsageStats() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       * @return The uploadUsageStats.
       */
      @java.lang.Override
      public boolean getUploadUsageStats() {
        return uploadUsageStats_;
      }
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       * @param value The uploadUsageStats to set.
       * @return This builder for chaining.
       */
      public Builder setUploadUsageStats(boolean value) {
        
        uploadUsageStats_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUploadUsageStats() {
        bitField0_ = (bitField0_ & ~0x00000020);
        uploadUsageStats_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.config.GeneralConfig)
    }

    // @@protoc_insertion_point(class_scope:mozc.config.GeneralConfig)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<GeneralConfig>
        PARSER = new com.google.protobuf.AbstractParser<GeneralConfig>() {
      @java.lang.Override
      public GeneralConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GeneralConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GeneralConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.config.Config)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     * @return Whether the generalConfig field is set.
     */
    boolean hasGeneralConfig();
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     * @return The generalConfig.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig();
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder getGeneralConfigOrBuilder();

    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     * @return Whether the verboseLevel field is set.
     */
    boolean hasVerboseLevel();
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     * @return The verboseLevel.
     */
    int getVerboseLevel();

    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     * @return Whether the incognitoMode field is set.
     */
    boolean hasIncognitoMode();
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     * @return The incognitoMode.
     */
    boolean getIncognitoMode();

    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     * @return Whether the checkDefault field is set.
     */
    boolean hasCheckDefault();
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     * @return The checkDefault.
     */
    boolean getCheckDefault();

    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     * @return Whether the presentationMode field is set.
     */
    boolean hasPresentationMode();
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     * @return The presentationMode.
     */
    boolean getPresentationMode();

    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     * @return Whether the preeditMethod field is set.
     */
    boolean hasPreeditMethod();
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     * @return The preeditMethod.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod();

    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     * @return Whether the sessionKeymap field is set.
     */
    boolean hasSessionKeymap();
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     * @return The sessionKeymap.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap();

    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     * @return Whether the customKeymapTable field is set.
     */
    boolean hasCustomKeymapTable();
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     * @return The customKeymapTable.
     */
    com.google.protobuf.ByteString getCustomKeymapTable();

    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     * @return Whether the customRomanTable field is set.
     */
    boolean hasCustomRomanTable();
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     * @return The customRomanTable.
     */
    com.google.protobuf.ByteString getCustomRomanTable();

    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     * @return Whether the punctuationMethod field is set.
     */
    boolean hasPunctuationMethod();
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     * @return The punctuationMethod.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod();

    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     * @return Whether the symbolMethod field is set.
     */
    boolean hasSymbolMethod();
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     * @return The symbolMethod.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod();

    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     * @return Whether the spaceCharacterForm field is set.
     */
    boolean hasSpaceCharacterForm();
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     * @return The spaceCharacterForm.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm();

    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     * @return Whether the useKeyboardToChangePreeditMethod field is set.
     */
    boolean hasUseKeyboardToChangePreeditMethod();
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     * @return The useKeyboardToChangePreeditMethod.
     */
    boolean getUseKeyboardToChangePreeditMethod();

    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     * @return Whether the historyLearningLevel field is set.
     */
    boolean hasHistoryLearningLevel();
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     * @return The historyLearningLevel.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel();

    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     * @return Whether the selectionShortcut field is set.
     */
    boolean hasSelectionShortcut();
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     * @return The selectionShortcut.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut();

    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> 
        getCharacterFormRulesList();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index);
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    int getCharacterFormRulesCount();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
        getCharacterFormRulesOrBuilderList();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
        int index);

    /**
     * <pre>
     * auto IME turn off feature
     * </pre>
     *
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     * @return Whether the useAutoImeTurnOff field is set.
     */
    boolean hasUseAutoImeTurnOff();
    /**
     * <pre>
     * auto IME turn off feature
     * </pre>
     *
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     * @return The useAutoImeTurnOff.
     */
    boolean getUseAutoImeTurnOff();

    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     * @return Whether the useCascadingWindow field is set.
     */
    boolean hasUseCascadingWindow();
    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     * @return The useCascadingWindow.
     */
    boolean getUseCascadingWindow();

    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     * @return Whether the shiftKeyModeSwitch field is set.
     */
    boolean hasShiftKeyModeSwitch();
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     * @return The shiftKeyModeSwitch.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch();

    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     * @return Whether the numpadCharacterForm field is set.
     */
    boolean hasNumpadCharacterForm();
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     * @return The numpadCharacterForm.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm();

    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     * @return Whether the useAutoConversion field is set.
     */
    boolean hasUseAutoConversion();
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     * @return The useAutoConversion.
     */
    boolean getUseAutoConversion();

    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     * @return Whether the autoConversionKey field is set.
     */
    boolean hasAutoConversionKey();
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     * @return The autoConversionKey.
     */
    int getAutoConversionKey();

    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     * @return Whether the yenSignCharacter field is set.
     */
    boolean hasYenSignCharacter();
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     * @return The yenSignCharacter.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter();

    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     * @return Whether the useJapaneseLayout field is set.
     */
    boolean hasUseJapaneseLayout();
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     * @return The useJapaneseLayout.
     */
    boolean getUseJapaneseLayout();

    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     * @return Whether the useKanaModifierInsensitiveConversion field is set.
     */
    boolean hasUseKanaModifierInsensitiveConversion();
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     * @return The useKanaModifierInsensitiveConversion.
     */
    boolean getUseKanaModifierInsensitiveConversion();

    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     * @return Whether the useTypingCorrection field is set.
     */
    boolean hasUseTypingCorrection();
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     * @return The useTypingCorrection.
     */
    boolean getUseTypingCorrection();

    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     * @return Whether the composingTimeoutThresholdMsec field is set.
     */
    boolean hasComposingTimeoutThresholdMsec();
    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     * @return The composingTimeoutThresholdMsec.
     */
    int getComposingTimeoutThresholdMsec();

    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @return A list containing the overlayKeymaps.
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> getOverlayKeymapsList();
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @return The count of overlayKeymaps.
     */
    int getOverlayKeymapsCount();
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The overlayKeymaps at the given index.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getOverlayKeymaps(int index);

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     * @return Whether the useDateConversion field is set.
     */
    boolean hasUseDateConversion();
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     * @return The useDateConversion.
     */
    boolean getUseDateConversion();

    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     * @return Whether the useSingleKanjiConversion field is set.
     */
    boolean hasUseSingleKanjiConversion();
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     * @return The useSingleKanjiConversion.
     */
    boolean getUseSingleKanjiConversion();

    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     * @return Whether the useSymbolConversion field is set.
     */
    boolean hasUseSymbolConversion();
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     * @return The useSymbolConversion.
     */
    boolean getUseSymbolConversion();

    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     * @return Whether the useNumberConversion field is set.
     */
    boolean hasUseNumberConversion();
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     * @return The useNumberConversion.
     */
    boolean getUseNumberConversion();

    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     * @return Whether the useEmoticonConversion field is set.
     */
    boolean hasUseEmoticonConversion();
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     * @return The useEmoticonConversion.
     */
    boolean getUseEmoticonConversion();

    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     * @return Whether the useCalculator field is set.
     */
    boolean hasUseCalculator();
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     * @return The useCalculator.
     */
    boolean getUseCalculator();

    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     * @return Whether the useT13nConversion field is set.
     */
    boolean hasUseT13NConversion();
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     * @return The useT13nConversion.
     */
    boolean getUseT13NConversion();

    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     * @return Whether the useZipCodeConversion field is set.
     */
    boolean hasUseZipCodeConversion();
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     * @return The useZipCodeConversion.
     */
    boolean getUseZipCodeConversion();

    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     * @return Whether the useSpellingCorrection field is set.
     */
    boolean hasUseSpellingCorrection();
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     * @return The useSpellingCorrection.
     */
    boolean getUseSpellingCorrection();

    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     * @return Whether the useEmojiConversion field is set.
     */
    boolean hasUseEmojiConversion();
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     * @return The useEmojiConversion.
     */
    boolean getUseEmojiConversion();

    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     * @return Whether the informationListConfig field is set.
     */
    boolean hasInformationListConfig();
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     * @return The informationListConfig.
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig();
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder getInformationListConfigOrBuilder();

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     * @return Whether the useHistorySuggest field is set.
     */
    boolean hasUseHistorySuggest();
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     * @return The useHistorySuggest.
     */
    boolean getUseHistorySuggest();

    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     * @return Whether the useDictionarySuggest field is set.
     */
    boolean hasUseDictionarySuggest();
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     * @return The useDictionarySuggest.
     */
    boolean getUseDictionarySuggest();

    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     * @return Whether the useRealtimeConversion field is set.
     */
    boolean hasUseRealtimeConversion();
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     * @return The useRealtimeConversion.
     */
    boolean getUseRealtimeConversion();

    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     * @return Whether the suggestionsSize field is set.
     */
    boolean hasSuggestionsSize();
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     * @return The suggestionsSize.
     */
    int getSuggestionsSize();

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     * @return Whether the useModeIndicator field is set.
     */
    boolean hasUseModeIndicator();
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     * @return The useModeIndicator.
     */
    boolean getUseModeIndicator();
  }
  /**
   * Protobuf type {@code mozc.config.Config}
   */
  public static final class Config extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.config.Config)
      ConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Config.newBuilder() to construct.
    private Config(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Config() {
      checkDefault_ = true;
      preeditMethod_ = 0;
      sessionKeymap_ = -1;
      customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
      customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
      punctuationMethod_ = 0;
      symbolMethod_ = 0;
      spaceCharacterForm_ = 0;
      historyLearningLevel_ = 0;
      selectionShortcut_ = 1;
      characterFormRules_ = java.util.Collections.emptyList();
      useAutoImeTurnOff_ = true;
      useCascadingWindow_ = true;
      shiftKeyModeSwitch_ = 1;
      numpadCharacterForm_ = 2;
      autoConversionKey_ = 13;
      yenSignCharacter_ = 0;
      overlayKeymaps_ = java.util.Collections.emptyList();
      useDateConversion_ = true;
      useSingleKanjiConversion_ = true;
      useSymbolConversion_ = true;
      useNumberConversion_ = true;
      useEmoticonConversion_ = true;
      useCalculator_ = true;
      useT13NConversion_ = true;
      useZipCodeConversion_ = true;
      useSpellingCorrection_ = true;
      useHistorySuggest_ = true;
      useDictionarySuggest_ = true;
      useRealtimeConversion_ = true;
      suggestionsSize_ = 3;
      useModeIndicator_ = true;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Config();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder.class);
    }

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Basic features (40-79)
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.PreeditMethod}
     */
    public enum PreeditMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>ROMAN = 0;</code>
       */
      ROMAN(0),
      /**
       * <code>KANA = 1;</code>
       */
      KANA(1),
      ;

      /**
       * <code>ROMAN = 0;</code>
       */
      public static final int ROMAN_VALUE = 0;
      /**
       * <code>KANA = 1;</code>
       */
      public static final int KANA_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PreeditMethod valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static PreeditMethod forNumber(int value) {
        switch (value) {
          case 0: return ROMAN;
          case 1: return KANA;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PreeditMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>() {
              public PreeditMethod findValueByNumber(int number) {
                return PreeditMethod.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(0);
      }

      private static final PreeditMethod[] VALUES = values();

      public static PreeditMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private PreeditMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.PreeditMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SessionKeymap}
     */
    public enum SessionKeymap
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * If NONE is selected, it will be replaced with MSIME or KOTOERI.
       * NONE is used only for a placeholder, so a configuration program
       * should not show NONE as one of selections.  NONE should be the
       * last of the items due to the limitation of the Qt GUI's
       * implementation. Note that keymap number should be correspoinding
       * to the index of QComboBox in config dialog. Since NONE is not
       * used, we set -1 here.
       * </pre>
       *
       * <code>NONE = -1;</code>
       */
      NONE(-1),
      /**
       * <code>CUSTOM = 0;</code>
       */
      CUSTOM(0),
      /**
       * <code>ATOK = 1;</code>
       */
      ATOK(1),
      /**
       * <code>MSIME = 2;</code>
       */
      MSIME(2),
      /**
       * <code>KOTOERI = 3;</code>
       */
      KOTOERI(3),
      /**
       * <code>MOBILE = 4;</code>
       */
      MOBILE(4),
      /**
       * <code>CHROMEOS = 5;</code>
       */
      CHROMEOS(5),
      /**
       * <code>OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF = 100;</code>
       */
      OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF(100),
      /**
       * <code>OVERLAY_FOR_TEST = 10000;</code>
       */
      OVERLAY_FOR_TEST(10000),
      ;

      /**
       * <pre>
       * If NONE is selected, it will be replaced with MSIME or KOTOERI.
       * NONE is used only for a placeholder, so a configuration program
       * should not show NONE as one of selections.  NONE should be the
       * last of the items due to the limitation of the Qt GUI's
       * implementation. Note that keymap number should be correspoinding
       * to the index of QComboBox in config dialog. Since NONE is not
       * used, we set -1 here.
       * </pre>
       *
       * <code>NONE = -1;</code>
       */
      public static final int NONE_VALUE = -1;
      /**
       * <code>CUSTOM = 0;</code>
       */
      public static final int CUSTOM_VALUE = 0;
      /**
       * <code>ATOK = 1;</code>
       */
      public static final int ATOK_VALUE = 1;
      /**
       * <code>MSIME = 2;</code>
       */
      public static final int MSIME_VALUE = 2;
      /**
       * <code>KOTOERI = 3;</code>
       */
      public static final int KOTOERI_VALUE = 3;
      /**
       * <code>MOBILE = 4;</code>
       */
      public static final int MOBILE_VALUE = 4;
      /**
       * <code>CHROMEOS = 5;</code>
       */
      public static final int CHROMEOS_VALUE = 5;
      /**
       * <code>OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF = 100;</code>
       */
      public static final int OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF_VALUE = 100;
      /**
       * <code>OVERLAY_FOR_TEST = 10000;</code>
       */
      public static final int OVERLAY_FOR_TEST_VALUE = 10000;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SessionKeymap valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static SessionKeymap forNumber(int value) {
        switch (value) {
          case -1: return NONE;
          case 0: return CUSTOM;
          case 1: return ATOK;
          case 2: return MSIME;
          case 3: return KOTOERI;
          case 4: return MOBILE;
          case 5: return CHROMEOS;
          case 100: return OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF;
          case 10000: return OVERLAY_FOR_TEST;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SessionKeymap>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SessionKeymap> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SessionKeymap>() {
              public SessionKeymap findValueByNumber(int number) {
                return SessionKeymap.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(1);
      }

      private static final SessionKeymap[] VALUES = values();

      public static SessionKeymap valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SessionKeymap(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SessionKeymap)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.PunctuationMethod}
     */
    public enum PunctuationMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>KUTEN_TOUTEN = 0;</code>
       */
      KUTEN_TOUTEN(0),
      /**
       * <code>COMMA_PERIOD = 1;</code>
       */
      COMMA_PERIOD(1),
      /**
       * <code>KUTEN_PERIOD = 2;</code>
       */
      KUTEN_PERIOD(2),
      /**
       * <code>COMMA_TOUTEN = 3;</code>
       */
      COMMA_TOUTEN(3),
      ;

      /**
       * <code>KUTEN_TOUTEN = 0;</code>
       */
      public static final int KUTEN_TOUTEN_VALUE = 0;
      /**
       * <code>COMMA_PERIOD = 1;</code>
       */
      public static final int COMMA_PERIOD_VALUE = 1;
      /**
       * <code>KUTEN_PERIOD = 2;</code>
       */
      public static final int KUTEN_PERIOD_VALUE = 2;
      /**
       * <code>COMMA_TOUTEN = 3;</code>
       */
      public static final int COMMA_TOUTEN_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PunctuationMethod valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static PunctuationMethod forNumber(int value) {
        switch (value) {
          case 0: return KUTEN_TOUTEN;
          case 1: return COMMA_PERIOD;
          case 2: return KUTEN_PERIOD;
          case 3: return COMMA_TOUTEN;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PunctuationMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PunctuationMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PunctuationMethod>() {
              public PunctuationMethod findValueByNumber(int number) {
                return PunctuationMethod.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(2);
      }

      private static final PunctuationMethod[] VALUES = values();

      public static PunctuationMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private PunctuationMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.PunctuationMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SymbolMethod}
     */
    public enum SymbolMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>CORNER_BRACKET_MIDDLE_DOT = 0;</code>
       */
      CORNER_BRACKET_MIDDLE_DOT(0),
      /**
       * <code>SQUARE_BRACKET_SLASH = 1;</code>
       */
      SQUARE_BRACKET_SLASH(1),
      /**
       * <code>CORNER_BRACKET_SLASH = 2;</code>
       */
      CORNER_BRACKET_SLASH(2),
      /**
       * <code>SQUARE_BRACKET_MIDDLE_DOT = 3;</code>
       */
      SQUARE_BRACKET_MIDDLE_DOT(3),
      ;

      /**
       * <code>CORNER_BRACKET_MIDDLE_DOT = 0;</code>
       */
      public static final int CORNER_BRACKET_MIDDLE_DOT_VALUE = 0;
      /**
       * <code>SQUARE_BRACKET_SLASH = 1;</code>
       */
      public static final int SQUARE_BRACKET_SLASH_VALUE = 1;
      /**
       * <code>CORNER_BRACKET_SLASH = 2;</code>
       */
      public static final int CORNER_BRACKET_SLASH_VALUE = 2;
      /**
       * <code>SQUARE_BRACKET_MIDDLE_DOT = 3;</code>
       */
      public static final int SQUARE_BRACKET_MIDDLE_DOT_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SymbolMethod valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static SymbolMethod forNumber(int value) {
        switch (value) {
          case 0: return CORNER_BRACKET_MIDDLE_DOT;
          case 1: return SQUARE_BRACKET_SLASH;
          case 2: return CORNER_BRACKET_SLASH;
          case 3: return SQUARE_BRACKET_MIDDLE_DOT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SymbolMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SymbolMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SymbolMethod>() {
              public SymbolMethod findValueByNumber(int number) {
                return SymbolMethod.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(3);
      }

      private static final SymbolMethod[] VALUES = values();

      public static SymbolMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SymbolMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SymbolMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.FundamentalCharacterForm}
     */
    public enum FundamentalCharacterForm
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * follow the input mode
       * </pre>
       *
       * <code>FUNDAMENTAL_INPUT_MODE = 0;</code>
       */
      FUNDAMENTAL_INPUT_MODE(0),
      /**
       * <pre>
       * always FullWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_FULL_WIDTH = 1;</code>
       */
      FUNDAMENTAL_FULL_WIDTH(1),
      /**
       * <pre>
       * always HalfWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_HALF_WIDTH = 2;</code>
       */
      FUNDAMENTAL_HALF_WIDTH(2),
      ;

      /**
       * <pre>
       * follow the input mode
       * </pre>
       *
       * <code>FUNDAMENTAL_INPUT_MODE = 0;</code>
       */
      public static final int FUNDAMENTAL_INPUT_MODE_VALUE = 0;
      /**
       * <pre>
       * always FullWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_FULL_WIDTH = 1;</code>
       */
      public static final int FUNDAMENTAL_FULL_WIDTH_VALUE = 1;
      /**
       * <pre>
       * always HalfWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_HALF_WIDTH = 2;</code>
       */
      public static final int FUNDAMENTAL_HALF_WIDTH_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FundamentalCharacterForm valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static FundamentalCharacterForm forNumber(int value) {
        switch (value) {
          case 0: return FUNDAMENTAL_INPUT_MODE;
          case 1: return FUNDAMENTAL_FULL_WIDTH;
          case 2: return FUNDAMENTAL_HALF_WIDTH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<FundamentalCharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          FundamentalCharacterForm> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<FundamentalCharacterForm>() {
              public FundamentalCharacterForm findValueByNumber(int number) {
                return FundamentalCharacterForm.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(4);
      }

      private static final FundamentalCharacterForm[] VALUES = values();

      public static FundamentalCharacterForm valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private FundamentalCharacterForm(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.FundamentalCharacterForm)
    }

    /**
     * <pre>
     * User history learning
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.HistoryLearningLevel}
     */
    public enum HistoryLearningLevel
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>DEFAULT_HISTORY = 0;</code>
       */
      DEFAULT_HISTORY(0),
      /**
       * <code>READ_ONLY = 1;</code>
       */
      READ_ONLY(1),
      /**
       * <code>NO_HISTORY = 2;</code>
       */
      NO_HISTORY(2),
      ;

      /**
       * <code>DEFAULT_HISTORY = 0;</code>
       */
      public static final int DEFAULT_HISTORY_VALUE = 0;
      /**
       * <code>READ_ONLY = 1;</code>
       */
      public static final int READ_ONLY_VALUE = 1;
      /**
       * <code>NO_HISTORY = 2;</code>
       */
      public static final int NO_HISTORY_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static HistoryLearningLevel valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static HistoryLearningLevel forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT_HISTORY;
          case 1: return READ_ONLY;
          case 2: return NO_HISTORY;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<HistoryLearningLevel>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          HistoryLearningLevel> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<HistoryLearningLevel>() {
              public HistoryLearningLevel findValueByNumber(int number) {
                return HistoryLearningLevel.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(5);
      }

      private static final HistoryLearningLevel[] VALUES = values();

      public static HistoryLearningLevel valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private HistoryLearningLevel(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.HistoryLearningLevel)
    }

    /**
     * <pre>
     * The style of candidate selection shortcut.
     * Note that if the current Request has SpecialRomajiTable (== the keyevent
     * is from a virtual keyboard), shortcut is no-op.
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.SelectionShortcut}
     */
    public enum SelectionShortcut
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NO_SHORTCUT = 0;</code>
       */
      NO_SHORTCUT(0),
      /**
       * <code>SHORTCUT_123456789 = 1;</code>
       */
      SHORTCUT_123456789(1),
      /**
       * <code>SHORTCUT_ASDFGHJKL = 2;</code>
       */
      SHORTCUT_ASDFGHJKL(2),
      ;

      /**
       * <code>NO_SHORTCUT = 0;</code>
       */
      public static final int NO_SHORTCUT_VALUE = 0;
      /**
       * <code>SHORTCUT_123456789 = 1;</code>
       */
      public static final int SHORTCUT_123456789_VALUE = 1;
      /**
       * <code>SHORTCUT_ASDFGHJKL = 2;</code>
       */
      public static final int SHORTCUT_ASDFGHJKL_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SelectionShortcut valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static SelectionShortcut forNumber(int value) {
        switch (value) {
          case 0: return NO_SHORTCUT;
          case 1: return SHORTCUT_123456789;
          case 2: return SHORTCUT_ASDFGHJKL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SelectionShortcut>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SelectionShortcut> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SelectionShortcut>() {
              public SelectionShortcut findValueByNumber(int number) {
                return SelectionShortcut.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(6);
      }

      private static final SelectionShortcut[] VALUES = values();

      public static SelectionShortcut valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SelectionShortcut(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SelectionShortcut)
    }

    /**
     * <pre>
     * character form (Halfwidth/Fullwidth
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.CharacterForm}
     */
    public enum CharacterForm
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>HALF_WIDTH = 0;</code>
       */
      HALF_WIDTH(0),
      /**
       * <code>FULL_WIDTH = 1;</code>
       */
      FULL_WIDTH(1),
      /**
       * <code>LAST_FORM = 2;</code>
       */
      LAST_FORM(2),
      /**
       * <code>NO_CONVERSION = 3;</code>
       */
      NO_CONVERSION(3),
      ;

      /**
       * <code>HALF_WIDTH = 0;</code>
       */
      public static final int HALF_WIDTH_VALUE = 0;
      /**
       * <code>FULL_WIDTH = 1;</code>
       */
      public static final int FULL_WIDTH_VALUE = 1;
      /**
       * <code>LAST_FORM = 2;</code>
       */
      public static final int LAST_FORM_VALUE = 2;
      /**
       * <code>NO_CONVERSION = 3;</code>
       */
      public static final int NO_CONVERSION_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CharacterForm valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static CharacterForm forNumber(int value) {
        switch (value) {
          case 0: return HALF_WIDTH;
          case 1: return FULL_WIDTH;
          case 2: return LAST_FORM;
          case 3: return NO_CONVERSION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CharacterForm> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CharacterForm>() {
              public CharacterForm findValueByNumber(int number) {
                return CharacterForm.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(7);
      }

      private static final CharacterForm[] VALUES = values();

      public static CharacterForm valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private CharacterForm(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.CharacterForm)
    }

    /**
     * <pre>
     * Shift key mode switch
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.ShiftKeyModeSwitch}
     */
    public enum ShiftKeyModeSwitch
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Case insensitive
       * </pre>
       *
       * <code>OFF = 0;</code>
       */
      OFF(0),
      /**
       * <pre>
       * MSIME, ATOK behavior
       * </pre>
       *
       * <code>ASCII_INPUT_MODE = 1;</code>
       */
      ASCII_INPUT_MODE(1),
      /**
       * <pre>
       * Kotoeri behavior
       * </pre>
       *
       * <code>KATAKANA_INPUT_MODE = 2;</code>
       */
      KATAKANA_INPUT_MODE(2),
      ;

      /**
       * <pre>
       * Case insensitive
       * </pre>
       *
       * <code>OFF = 0;</code>
       */
      public static final int OFF_VALUE = 0;
      /**
       * <pre>
       * MSIME, ATOK behavior
       * </pre>
       *
       * <code>ASCII_INPUT_MODE = 1;</code>
       */
      public static final int ASCII_INPUT_MODE_VALUE = 1;
      /**
       * <pre>
       * Kotoeri behavior
       * </pre>
       *
       * <code>KATAKANA_INPUT_MODE = 2;</code>
       */
      public static final int KATAKANA_INPUT_MODE_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ShiftKeyModeSwitch valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static ShiftKeyModeSwitch forNumber(int value) {
        switch (value) {
          case 0: return OFF;
          case 1: return ASCII_INPUT_MODE;
          case 2: return KATAKANA_INPUT_MODE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ShiftKeyModeSwitch>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ShiftKeyModeSwitch> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ShiftKeyModeSwitch>() {
              public ShiftKeyModeSwitch findValueByNumber(int number) {
                return ShiftKeyModeSwitch.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(8);
      }

      private static final ShiftKeyModeSwitch[] VALUES = values();

      public static ShiftKeyModeSwitch valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private ShiftKeyModeSwitch(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.ShiftKeyModeSwitch)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.NumpadCharacterForm}
     */
    public enum NumpadCharacterForm
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NUMPAD_INPUT_MODE = 0;</code>
       */
      NUMPAD_INPUT_MODE(0),
      /**
       * <code>NUMPAD_FULL_WIDTH = 1;</code>
       */
      NUMPAD_FULL_WIDTH(1),
      /**
       * <code>NUMPAD_HALF_WIDTH = 2;</code>
       */
      NUMPAD_HALF_WIDTH(2),
      /**
       * <code>NUMPAD_DIRECT_INPUT = 3;</code>
       */
      NUMPAD_DIRECT_INPUT(3),
      ;

      /**
       * <code>NUMPAD_INPUT_MODE = 0;</code>
       */
      public static final int NUMPAD_INPUT_MODE_VALUE = 0;
      /**
       * <code>NUMPAD_FULL_WIDTH = 1;</code>
       */
      public static final int NUMPAD_FULL_WIDTH_VALUE = 1;
      /**
       * <code>NUMPAD_HALF_WIDTH = 2;</code>
       */
      public static final int NUMPAD_HALF_WIDTH_VALUE = 2;
      /**
       * <code>NUMPAD_DIRECT_INPUT = 3;</code>
       */
      public static final int NUMPAD_DIRECT_INPUT_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static NumpadCharacterForm valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static NumpadCharacterForm forNumber(int value) {
        switch (value) {
          case 0: return NUMPAD_INPUT_MODE;
          case 1: return NUMPAD_FULL_WIDTH;
          case 2: return NUMPAD_HALF_WIDTH;
          case 3: return NUMPAD_DIRECT_INPUT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<NumpadCharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          NumpadCharacterForm> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<NumpadCharacterForm>() {
              public NumpadCharacterForm findValueByNumber(int number) {
                return NumpadCharacterForm.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(9);
      }

      private static final NumpadCharacterForm[] VALUES = values();

      public static NumpadCharacterForm valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private NumpadCharacterForm(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.NumpadCharacterForm)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.AutoConversionKey}
     */
    public enum AutoConversionKey
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>AUTO_CONVERSION_OFF = 0;</code>
       */
      AUTO_CONVERSION_OFF(0),
      /**
       * <code>AUTO_CONVERSION_KUTEN = 1;</code>
       */
      AUTO_CONVERSION_KUTEN(1),
      /**
       * <code>AUTO_CONVERSION_TOUTEN = 2;</code>
       */
      AUTO_CONVERSION_TOUTEN(2),
      /**
       * <code>AUTO_CONVERSION_QUESTION_MARK = 4;</code>
       */
      AUTO_CONVERSION_QUESTION_MARK(4),
      /**
       * <code>AUTO_CONVERSION_EXCLAMATION_MARK = 8;</code>
       */
      AUTO_CONVERSION_EXCLAMATION_MARK(8),
      ;

      /**
       * <code>AUTO_CONVERSION_OFF = 0;</code>
       */
      public static final int AUTO_CONVERSION_OFF_VALUE = 0;
      /**
       * <code>AUTO_CONVERSION_KUTEN = 1;</code>
       */
      public static final int AUTO_CONVERSION_KUTEN_VALUE = 1;
      /**
       * <code>AUTO_CONVERSION_TOUTEN = 2;</code>
       */
      public static final int AUTO_CONVERSION_TOUTEN_VALUE = 2;
      /**
       * <code>AUTO_CONVERSION_QUESTION_MARK = 4;</code>
       */
      public static final int AUTO_CONVERSION_QUESTION_MARK_VALUE = 4;
      /**
       * <code>AUTO_CONVERSION_EXCLAMATION_MARK = 8;</code>
       */
      public static final int AUTO_CONVERSION_EXCLAMATION_MARK_VALUE = 8;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static AutoConversionKey valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static AutoConversionKey forNumber(int value) {
        switch (value) {
          case 0: return AUTO_CONVERSION_OFF;
          case 1: return AUTO_CONVERSION_KUTEN;
          case 2: return AUTO_CONVERSION_TOUTEN;
          case 4: return AUTO_CONVERSION_QUESTION_MARK;
          case 8: return AUTO_CONVERSION_EXCLAMATION_MARK;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<AutoConversionKey>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          AutoConversionKey> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AutoConversionKey>() {
              public AutoConversionKey findValueByNumber(int number) {
                return AutoConversionKey.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(10);
      }

      private static final AutoConversionKey[] VALUES = values();

      public static AutoConversionKey valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private AutoConversionKey(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.AutoConversionKey)
    }

    /**
     * <pre>
     * Mac only config items: yen_sign_character and use_japanese_layout.
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.YenSignCharacter}
     */
    public enum YenSignCharacter
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>YEN_SIGN = 0;</code>
       */
      YEN_SIGN(0),
      /**
       * <code>BACKSLASH = 1;</code>
       */
      BACKSLASH(1),
      ;

      /**
       * <code>YEN_SIGN = 0;</code>
       */
      public static final int YEN_SIGN_VALUE = 0;
      /**
       * <code>BACKSLASH = 1;</code>
       */
      public static final int BACKSLASH_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static YenSignCharacter valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static YenSignCharacter forNumber(int value) {
        switch (value) {
          case 0: return YEN_SIGN;
          case 1: return BACKSLASH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<YenSignCharacter>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          YenSignCharacter> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<YenSignCharacter>() {
              public YenSignCharacter findValueByNumber(int number) {
                return YenSignCharacter.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(11);
      }

      private static final YenSignCharacter[] VALUES = values();

      public static YenSignCharacter valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private YenSignCharacter(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.YenSignCharacter)
    }

    public interface CharacterFormRuleOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.config.Config.CharacterFormRule)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional string group = 1;</code>
       * @return Whether the group field is set.
       */
      boolean hasGroup();
      /**
       * <code>optional string group = 1;</code>
       * @return The group.
       */
      java.lang.String getGroup();
      /**
       * <code>optional string group = 1;</code>
       * @return The bytes for group.
       */
      com.google.protobuf.ByteString
          getGroupBytes();

      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       * @return Whether the preeditCharacterForm field is set.
       */
      boolean hasPreeditCharacterForm();
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       * @return The preeditCharacterForm.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm();

      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       * @return Whether the conversionCharacterForm field is set.
       */
      boolean hasConversionCharacterForm();
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       * @return The conversionCharacterForm.
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm();
    }
    /**
     * Protobuf type {@code mozc.config.Config.CharacterFormRule}
     */
    public static final class CharacterFormRule extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.config.Config.CharacterFormRule)
        CharacterFormRuleOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use CharacterFormRule.newBuilder() to construct.
      private CharacterFormRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private CharacterFormRule() {
        group_ = "";
        preeditCharacterForm_ = 1;
        conversionCharacterForm_ = 1;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new CharacterFormRule();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder.class);
      }

      private int bitField0_;
      public static final int GROUP_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private volatile java.lang.Object group_ = "";
      /**
       * <code>optional string group = 1;</code>
       * @return Whether the group field is set.
       */
      @java.lang.Override
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The group.
       */
      @java.lang.Override
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       * @return The bytes for group.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int PREEDIT_CHARACTER_FORM_FIELD_NUMBER = 2;
      private int preeditCharacterForm_ = 1;
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       * @return Whether the preeditCharacterForm field is set.
       */
      @java.lang.Override public boolean hasPreeditCharacterForm() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       * @return The preeditCharacterForm.
       */
      @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.forNumber(preeditCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
      }

      public static final int CONVERSION_CHARACTER_FORM_FIELD_NUMBER = 3;
      private int conversionCharacterForm_ = 1;
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       * @return Whether the conversionCharacterForm field is set.
       */
      @java.lang.Override public boolean hasConversionCharacterForm() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       * @return The conversionCharacterForm.
       */
      @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.forNumber(conversionCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, group_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeEnum(2, preeditCharacterForm_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeEnum(3, conversionCharacterForm_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, group_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(2, preeditCharacterForm_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(3, conversionCharacterForm_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule) obj;

        if (hasGroup() != other.hasGroup()) return false;
        if (hasGroup()) {
          if (!getGroup()
              .equals(other.getGroup())) return false;
        }
        if (hasPreeditCharacterForm() != other.hasPreeditCharacterForm()) return false;
        if (hasPreeditCharacterForm()) {
          if (preeditCharacterForm_ != other.preeditCharacterForm_) return false;
        }
        if (hasConversionCharacterForm() != other.hasConversionCharacterForm()) return false;
        if (hasConversionCharacterForm()) {
          if (conversionCharacterForm_ != other.conversionCharacterForm_) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasGroup()) {
          hash = (37 * hash) + GROUP_FIELD_NUMBER;
          hash = (53 * hash) + getGroup().hashCode();
        }
        if (hasPreeditCharacterForm()) {
          hash = (37 * hash) + PREEDIT_CHARACTER_FORM_FIELD_NUMBER;
          hash = (53 * hash) + preeditCharacterForm_;
        }
        if (hasConversionCharacterForm()) {
          hash = (37 * hash) + CONVERSION_CHARACTER_FORM_FIELD_NUMBER;
          hash = (53 * hash) + conversionCharacterForm_;
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code mozc.config.Config.CharacterFormRule}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.config.Config.CharacterFormRule)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          group_ = "";
          preeditCharacterForm_ = 1;
          conversionCharacterForm_ = 1;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_descriptor;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance();
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.group_ = group_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.preeditCharacterForm_ = preeditCharacterForm_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.conversionCharacterForm_ = conversionCharacterForm_;
            to_bitField0_ |= 0x00000004;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance()) return this;
          if (other.hasGroup()) {
            group_ = other.group_;
            bitField0_ |= 0x00000001;
            onChanged();
          }
          if (other.hasPreeditCharacterForm()) {
            setPreeditCharacterForm(other.getPreeditCharacterForm());
          }
          if (other.hasConversionCharacterForm()) {
            setConversionCharacterForm(other.getConversionCharacterForm());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  group_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 16: {
                  int tmpRaw = input.readEnum();
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm tmpValue =
                      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(2, tmpRaw);
                  } else {
                    preeditCharacterForm_ = tmpRaw;
                    bitField0_ |= 0x00000002;
                  }
                  break;
                } // case 16
                case 24: {
                  int tmpRaw = input.readEnum();
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm tmpValue =
                      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(3, tmpRaw);
                  } else {
                    conversionCharacterForm_ = tmpRaw;
                    bitField0_ |= 0x00000004;
                  }
                  break;
                } // case 24
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.lang.Object group_ = "";
        /**
         * <code>optional string group = 1;</code>
         * @return Whether the group field is set.
         */
        public boolean hasGroup() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional string group = 1;</code>
         * @return The group.
         */
        public java.lang.String getGroup() {
          java.lang.Object ref = group_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              group_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <code>optional string group = 1;</code>
         * @return The bytes for group.
         */
        public com.google.protobuf.ByteString
            getGroupBytes() {
          java.lang.Object ref = group_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            group_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <code>optional string group = 1;</code>
         * @param value The group to set.
         * @return This builder for chaining.
         */
        public Builder setGroup(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          group_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <code>optional string group = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearGroup() {
          group_ = getDefaultInstance().getGroup();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <code>optional string group = 1;</code>
         * @param value The bytes for group to set.
         * @return This builder for chaining.
         */
        public Builder setGroupBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          group_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        private int preeditCharacterForm_ = 1;
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         * @return Whether the preeditCharacterForm field is set.
         */
        @java.lang.Override public boolean hasPreeditCharacterForm() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         * @return The preeditCharacterForm.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.forNumber(preeditCharacterForm_);
          return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         * @param value The preeditCharacterForm to set.
         * @return This builder for chaining.
         */
        public Builder setPreeditCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000002;
          preeditCharacterForm_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         * @return This builder for chaining.
         */
        public Builder clearPreeditCharacterForm() {
          bitField0_ = (bitField0_ & ~0x00000002);
          preeditCharacterForm_ = 1;
          onChanged();
          return this;
        }

        private int conversionCharacterForm_ = 1;
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         * @return Whether the conversionCharacterForm field is set.
         */
        @java.lang.Override public boolean hasConversionCharacterForm() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         * @return The conversionCharacterForm.
         */
        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.forNumber(conversionCharacterForm_);
          return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         * @param value The conversionCharacterForm to set.
         * @return This builder for chaining.
         */
        public Builder setConversionCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000004;
          conversionCharacterForm_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         * @return This builder for chaining.
         */
        public Builder clearConversionCharacterForm() {
          bitField0_ = (bitField0_ & ~0x00000004);
          conversionCharacterForm_ = 1;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.config.Config.CharacterFormRule)
      }

      // @@protoc_insertion_point(class_scope:mozc.config.Config.CharacterFormRule)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<CharacterFormRule>
          PARSER = new com.google.protobuf.AbstractParser<CharacterFormRule>() {
        @java.lang.Override
        public CharacterFormRule parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<CharacterFormRule> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<CharacterFormRule> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface InformationListConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.config.Config.InformationListConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       * @return Whether the useLocalUsageDictionary field is set.
       */
      boolean hasUseLocalUsageDictionary();
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       * @return The useLocalUsageDictionary.
       */
      boolean getUseLocalUsageDictionary();
    }
    /**
     * Protobuf type {@code mozc.config.Config.InformationListConfig}
     */
    public static final class InformationListConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.config.Config.InformationListConfig)
        InformationListConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use InformationListConfig.newBuilder() to construct.
      private InformationListConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private InformationListConfig() {
        useLocalUsageDictionary_ = true;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new InformationListConfig();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder.class);
      }

      private int bitField0_;
      public static final int USE_LOCAL_USAGE_DICTIONARY_FIELD_NUMBER = 1;
      private boolean useLocalUsageDictionary_ = true;
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       * @return Whether the useLocalUsageDictionary field is set.
       */
      @java.lang.Override
      public boolean hasUseLocalUsageDictionary() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       * @return The useLocalUsageDictionary.
       */
      @java.lang.Override
      public boolean getUseLocalUsageDictionary() {
        return useLocalUsageDictionary_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeBool(1, useLocalUsageDictionary_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(1, useLocalUsageDictionary_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig) obj;

        if (hasUseLocalUsageDictionary() != other.hasUseLocalUsageDictionary()) return false;
        if (hasUseLocalUsageDictionary()) {
          if (getUseLocalUsageDictionary()
              != other.getUseLocalUsageDictionary()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasUseLocalUsageDictionary()) {
          hash = (37 * hash) + USE_LOCAL_USAGE_DICTIONARY_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getUseLocalUsageDictionary());
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code mozc.config.Config.InformationListConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.config.Config.InformationListConfig)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          useLocalUsageDictionary_ = true;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_descriptor;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance();
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.useLocalUsageDictionary_ = useLocalUsageDictionary_;
            to_bitField0_ |= 0x00000001;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance()) return this;
          if (other.hasUseLocalUsageDictionary()) {
            setUseLocalUsageDictionary(other.getUseLocalUsageDictionary());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  useLocalUsageDictionary_ = input.readBool();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private boolean useLocalUsageDictionary_ = true;
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         * @return Whether the useLocalUsageDictionary field is set.
         */
        @java.lang.Override
        public boolean hasUseLocalUsageDictionary() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         * @return The useLocalUsageDictionary.
         */
        @java.lang.Override
        public boolean getUseLocalUsageDictionary() {
          return useLocalUsageDictionary_;
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         * @param value The useLocalUsageDictionary to set.
         * @return This builder for chaining.
         */
        public Builder setUseLocalUsageDictionary(boolean value) {
          
          useLocalUsageDictionary_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         * @return This builder for chaining.
         */
        public Builder clearUseLocalUsageDictionary() {
          bitField0_ = (bitField0_ & ~0x00000001);
          useLocalUsageDictionary_ = true;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.config.Config.InformationListConfig)
      }

      // @@protoc_insertion_point(class_scope:mozc.config.Config.InformationListConfig)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<InformationListConfig>
          PARSER = new com.google.protobuf.AbstractParser<InformationListConfig>() {
        @java.lang.Override
        public InformationListConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<InformationListConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<InformationListConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    private int bitField1_;
    public static final int GENERAL_CONFIG_FIELD_NUMBER = 1;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig generalConfig_;
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     * @return Whether the generalConfig field is set.
     */
    @java.lang.Override
    public boolean hasGeneralConfig() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     * @return The generalConfig.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig() {
      return generalConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance() : generalConfig_;
    }
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder getGeneralConfigOrBuilder() {
      return generalConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance() : generalConfig_;
    }

    public static final int VERBOSE_LEVEL_FIELD_NUMBER = 10;
    private int verboseLevel_ = 0;
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     * @return Whether the verboseLevel field is set.
     */
    @java.lang.Override
    public boolean hasVerboseLevel() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     * @return The verboseLevel.
     */
    @java.lang.Override
    public int getVerboseLevel() {
      return verboseLevel_;
    }

    public static final int INCOGNITO_MODE_FIELD_NUMBER = 20;
    private boolean incognitoMode_ = false;
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     * @return Whether the incognitoMode field is set.
     */
    @java.lang.Override
    public boolean hasIncognitoMode() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * Clients needs to check ConversionRequest::incognito_mode() instead
     * of Config::incognito_mode(), as the incoginto mode can also set
     * via Options.
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     * @return The incognitoMode.
     */
    @java.lang.Override
    public boolean getIncognitoMode() {
      return incognitoMode_;
    }

    public static final int CHECK_DEFAULT_FIELD_NUMBER = 22;
    private boolean checkDefault_ = true;
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     * @return Whether the checkDefault field is set.
     */
    @java.lang.Override
    public boolean hasCheckDefault() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     * @return The checkDefault.
     */
    @java.lang.Override
    public boolean getCheckDefault() {
      return checkDefault_;
    }

    public static final int PRESENTATION_MODE_FIELD_NUMBER = 23;
    private boolean presentationMode_ = false;
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     * @return Whether the presentationMode field is set.
     */
    @java.lang.Override
    public boolean hasPresentationMode() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     * @return The presentationMode.
     */
    @java.lang.Override
    public boolean getPresentationMode() {
      return presentationMode_;
    }

    public static final int PREEDIT_METHOD_FIELD_NUMBER = 40;
    private int preeditMethod_ = 0;
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     * @return Whether the preeditMethod field is set.
     */
    @java.lang.Override public boolean hasPreeditMethod() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     * @return The preeditMethod.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.forNumber(preeditMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.ROMAN : result;
    }

    public static final int SESSION_KEYMAP_FIELD_NUMBER = 41;
    private int sessionKeymap_ = -1;
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     * @return Whether the sessionKeymap field is set.
     */
    @java.lang.Override public boolean hasSessionKeymap() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     * @return The sessionKeymap.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.forNumber(sessionKeymap_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE : result;
    }

    public static final int CUSTOM_KEYMAP_TABLE_FIELD_NUMBER = 42;
    private com.google.protobuf.ByteString customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     * @return Whether the customKeymapTable field is set.
     */
    @java.lang.Override
    public boolean hasCustomKeymapTable() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     * @return The customKeymapTable.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCustomKeymapTable() {
      return customKeymapTable_;
    }

    public static final int CUSTOM_ROMAN_TABLE_FIELD_NUMBER = 43;
    private com.google.protobuf.ByteString customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     * @return Whether the customRomanTable field is set.
     */
    @java.lang.Override
    public boolean hasCustomRomanTable() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     * @return The customRomanTable.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCustomRomanTable() {
      return customRomanTable_;
    }

    public static final int PUNCTUATION_METHOD_FIELD_NUMBER = 45;
    private int punctuationMethod_ = 0;
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     * @return Whether the punctuationMethod field is set.
     */
    @java.lang.Override public boolean hasPunctuationMethod() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     * @return The punctuationMethod.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.forNumber(punctuationMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.KUTEN_TOUTEN : result;
    }

    public static final int SYMBOL_METHOD_FIELD_NUMBER = 46;
    private int symbolMethod_ = 0;
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     * @return Whether the symbolMethod field is set.
     */
    @java.lang.Override public boolean hasSymbolMethod() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     * @return The symbolMethod.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.forNumber(symbolMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.CORNER_BRACKET_MIDDLE_DOT : result;
    }

    public static final int SPACE_CHARACTER_FORM_FIELD_NUMBER = 47;
    private int spaceCharacterForm_ = 0;
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     * @return Whether the spaceCharacterForm field is set.
     */
    @java.lang.Override public boolean hasSpaceCharacterForm() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     * @return The spaceCharacterForm.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.forNumber(spaceCharacterForm_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.FUNDAMENTAL_INPUT_MODE : result;
    }

    public static final int USE_KEYBOARD_TO_CHANGE_PREEDIT_METHOD_FIELD_NUMBER = 48;
    private boolean useKeyboardToChangePreeditMethod_ = false;
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     * @return Whether the useKeyboardToChangePreeditMethod field is set.
     */
    @java.lang.Override
    public boolean hasUseKeyboardToChangePreeditMethod() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     * @return The useKeyboardToChangePreeditMethod.
     */
    @java.lang.Override
    public boolean getUseKeyboardToChangePreeditMethod() {
      return useKeyboardToChangePreeditMethod_;
    }

    public static final int HISTORY_LEARNING_LEVEL_FIELD_NUMBER = 50;
    private int historyLearningLevel_ = 0;
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     * @return Whether the historyLearningLevel field is set.
     */
    @java.lang.Override public boolean hasHistoryLearningLevel() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     * @return The historyLearningLevel.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.forNumber(historyLearningLevel_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.DEFAULT_HISTORY : result;
    }

    public static final int SELECTION_SHORTCUT_FIELD_NUMBER = 52;
    private int selectionShortcut_ = 1;
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     * @return Whether the selectionShortcut field is set.
     */
    @java.lang.Override public boolean hasSelectionShortcut() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     * @return The selectionShortcut.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.forNumber(selectionShortcut_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.SHORTCUT_123456789 : result;
    }

    public static final int CHARACTER_FORM_RULES_FIELD_NUMBER = 54;
    @SuppressWarnings("serial")
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> characterFormRules_;
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> getCharacterFormRulesList() {
      return characterFormRules_;
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
        getCharacterFormRulesOrBuilderList() {
      return characterFormRules_;
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    @java.lang.Override
    public int getCharacterFormRulesCount() {
      return characterFormRules_.size();
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index) {
      return characterFormRules_.get(index);
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
        int index) {
      return characterFormRules_.get(index);
    }

    public static final int USE_AUTO_IME_TURN_OFF_FIELD_NUMBER = 56;
    private boolean useAutoImeTurnOff_ = true;
    /**
     * <pre>
     * auto IME turn off feature
     * </pre>
     *
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     * @return Whether the useAutoImeTurnOff field is set.
     */
    @java.lang.Override
    public boolean hasUseAutoImeTurnOff() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * auto IME turn off feature
     * </pre>
     *
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     * @return The useAutoImeTurnOff.
     */
    @java.lang.Override
    public boolean getUseAutoImeTurnOff() {
      return useAutoImeTurnOff_;
    }

    public static final int USE_CASCADING_WINDOW_FIELD_NUMBER = 58;
    private boolean useCascadingWindow_ = true;
    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     * @return Whether the useCascadingWindow field is set.
     */
    @java.lang.Override
    public boolean hasUseCascadingWindow() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Toggle to use cascanding window for debugging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     * @return The useCascadingWindow.
     */
    @java.lang.Override
    public boolean getUseCascadingWindow() {
      return useCascadingWindow_;
    }

    public static final int SHIFT_KEY_MODE_SWITCH_FIELD_NUMBER = 59;
    private int shiftKeyModeSwitch_ = 1;
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     * @return Whether the shiftKeyModeSwitch field is set.
     */
    @java.lang.Override public boolean hasShiftKeyModeSwitch() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     * @return The shiftKeyModeSwitch.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.forNumber(shiftKeyModeSwitch_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.ASCII_INPUT_MODE : result;
    }

    public static final int NUMPAD_CHARACTER_FORM_FIELD_NUMBER = 60;
    private int numpadCharacterForm_ = 2;
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     * @return Whether the numpadCharacterForm field is set.
     */
    @java.lang.Override public boolean hasNumpadCharacterForm() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     * @return The numpadCharacterForm.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.forNumber(numpadCharacterForm_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.NUMPAD_HALF_WIDTH : result;
    }

    public static final int USE_AUTO_CONVERSION_FIELD_NUMBER = 61;
    private boolean useAutoConversion_ = false;
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     * @return Whether the useAutoConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseAutoConversion() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     * @return The useAutoConversion.
     */
    @java.lang.Override
    public boolean getUseAutoConversion() {
      return useAutoConversion_;
    }

    public static final int AUTO_CONVERSION_KEY_FIELD_NUMBER = 62;
    private int autoConversionKey_ = 13;
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     * @return Whether the autoConversionKey field is set.
     */
    @java.lang.Override
    public boolean hasAutoConversionKey() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     * @return The autoConversionKey.
     */
    @java.lang.Override
    public int getAutoConversionKey() {
      return autoConversionKey_;
    }

    public static final int YEN_SIGN_CHARACTER_FIELD_NUMBER = 63;
    private int yenSignCharacter_ = 0;
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     * @return Whether the yenSignCharacter field is set.
     */
    @java.lang.Override public boolean hasYenSignCharacter() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     * @return The yenSignCharacter.
     */
    @java.lang.Override public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.forNumber(yenSignCharacter_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.YEN_SIGN : result;
    }

    public static final int USE_JAPANESE_LAYOUT_FIELD_NUMBER = 64;
    private boolean useJapaneseLayout_ = false;
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     * @return Whether the useJapaneseLayout field is set.
     */
    @java.lang.Override
    public boolean hasUseJapaneseLayout() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     * @return The useJapaneseLayout.
     */
    @java.lang.Override
    public boolean getUseJapaneseLayout() {
      return useJapaneseLayout_;
    }

    public static final int USE_KANA_MODIFIER_INSENSITIVE_CONVERSION_FIELD_NUMBER = 65;
    private boolean useKanaModifierInsensitiveConversion_ = false;
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     * @return Whether the useKanaModifierInsensitiveConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseKanaModifierInsensitiveConversion() {
      return ((bitField0_ & 0x00800000) != 0);
    }
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     * @return The useKanaModifierInsensitiveConversion.
     */
    @java.lang.Override
    public boolean getUseKanaModifierInsensitiveConversion() {
      return useKanaModifierInsensitiveConversion_;
    }

    public static final int USE_TYPING_CORRECTION_FIELD_NUMBER = 66;
    private boolean useTypingCorrection_ = false;
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     * @return Whether the useTypingCorrection field is set.
     */
    @java.lang.Override
    public boolean hasUseTypingCorrection() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     * @return The useTypingCorrection.
     */
    @java.lang.Override
    public boolean getUseTypingCorrection() {
      return useTypingCorrection_;
    }

    public static final int COMPOSING_TIMEOUT_THRESHOLD_MSEC_FIELD_NUMBER = 67;
    private int composingTimeoutThresholdMsec_ = 0;
    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     * @return Whether the composingTimeoutThresholdMsec field is set.
     */
    @java.lang.Override
    public boolean hasComposingTimeoutThresholdMsec() {
      return ((bitField0_ & 0x02000000) != 0);
    }
    /**
     * <pre>
     * The duration in millisecond to determine the timeout.
     * If the duration between key inputs is more than this value,
     * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
     * If the value is 0, STOP_KEY_TOGGLING is not sent.
     * </pre>
     *
     * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
     * @return The composingTimeoutThresholdMsec.
     */
    @java.lang.Override
    public int getComposingTimeoutThresholdMsec() {
      return composingTimeoutThresholdMsec_;
    }

    public static final int OVERLAY_KEYMAPS_FIELD_NUMBER = 68;
    @SuppressWarnings("serial")
    private java.util.List<java.lang.Integer> overlayKeymaps_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> overlayKeymaps_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap>() {
              public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap convert(java.lang.Integer from) {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.forNumber(from);
                return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE : result;
              }
            };
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @return A list containing the overlayKeymaps.
     */
    @java.lang.Override
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> getOverlayKeymapsList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap>(overlayKeymaps_, overlayKeymaps_converter_);
    }
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @return The count of overlayKeymaps.
     */
    @java.lang.Override
    public int getOverlayKeymapsCount() {
      return overlayKeymaps_.size();
    }
    /**
     * <pre>
     * The keymaps which are loaded on top of `session_keymap`.
     * Overlay keymaps are prioritized over `session_keymap`.
     * They are used to partially modify the session keymap, for example
     * using Henkan key as IME_ON.
     * </pre>
     *
     * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The overlayKeymaps at the given index.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getOverlayKeymaps(int index) {
      return overlayKeymaps_converter_.convert(overlayKeymaps_.get(index));
    }
    private int overlayKeymapsMemoizedSerializedSize;

    public static final int USE_DATE_CONVERSION_FIELD_NUMBER = 80;
    private boolean useDateConversion_ = true;
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     * @return Whether the useDateConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseDateConversion() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     * @return The useDateConversion.
     */
    @java.lang.Override
    public boolean getUseDateConversion() {
      return useDateConversion_;
    }

    public static final int USE_SINGLE_KANJI_CONVERSION_FIELD_NUMBER = 81;
    private boolean useSingleKanjiConversion_ = true;
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     * @return Whether the useSingleKanjiConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseSingleKanjiConversion() {
      return ((bitField0_ & 0x08000000) != 0);
    }
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     * @return The useSingleKanjiConversion.
     */
    @java.lang.Override
    public boolean getUseSingleKanjiConversion() {
      return useSingleKanjiConversion_;
    }

    public static final int USE_SYMBOL_CONVERSION_FIELD_NUMBER = 82;
    private boolean useSymbolConversion_ = true;
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     * @return Whether the useSymbolConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseSymbolConversion() {
      return ((bitField0_ & 0x10000000) != 0);
    }
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     * @return The useSymbolConversion.
     */
    @java.lang.Override
    public boolean getUseSymbolConversion() {
      return useSymbolConversion_;
    }

    public static final int USE_NUMBER_CONVERSION_FIELD_NUMBER = 83;
    private boolean useNumberConversion_ = true;
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     * @return Whether the useNumberConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseNumberConversion() {
      return ((bitField0_ & 0x20000000) != 0);
    }
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     * @return The useNumberConversion.
     */
    @java.lang.Override
    public boolean getUseNumberConversion() {
      return useNumberConversion_;
    }

    public static final int USE_EMOTICON_CONVERSION_FIELD_NUMBER = 84;
    private boolean useEmoticonConversion_ = true;
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     * @return Whether the useEmoticonConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseEmoticonConversion() {
      return ((bitField0_ & 0x40000000) != 0);
    }
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     * @return The useEmoticonConversion.
     */
    @java.lang.Override
    public boolean getUseEmoticonConversion() {
      return useEmoticonConversion_;
    }

    public static final int USE_CALCULATOR_FIELD_NUMBER = 85;
    private boolean useCalculator_ = true;
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     * @return Whether the useCalculator field is set.
     */
    @java.lang.Override
    public boolean hasUseCalculator() {
      return ((bitField0_ & 0x80000000) != 0);
    }
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     * @return The useCalculator.
     */
    @java.lang.Override
    public boolean getUseCalculator() {
      return useCalculator_;
    }

    public static final int USE_T13N_CONVERSION_FIELD_NUMBER = 86;
    private boolean useT13NConversion_ = true;
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     * @return Whether the useT13nConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseT13NConversion() {
      return ((bitField1_ & 0x00000001) != 0);
    }
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     * @return The useT13nConversion.
     */
    @java.lang.Override
    public boolean getUseT13NConversion() {
      return useT13NConversion_;
    }

    public static final int USE_ZIP_CODE_CONVERSION_FIELD_NUMBER = 87;
    private boolean useZipCodeConversion_ = true;
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     * @return Whether the useZipCodeConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseZipCodeConversion() {
      return ((bitField1_ & 0x00000002) != 0);
    }
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     * @return The useZipCodeConversion.
     */
    @java.lang.Override
    public boolean getUseZipCodeConversion() {
      return useZipCodeConversion_;
    }

    public static final int USE_SPELLING_CORRECTION_FIELD_NUMBER = 88;
    private boolean useSpellingCorrection_ = true;
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     * @return Whether the useSpellingCorrection field is set.
     */
    @java.lang.Override
    public boolean hasUseSpellingCorrection() {
      return ((bitField1_ & 0x00000004) != 0);
    }
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     * @return The useSpellingCorrection.
     */
    @java.lang.Override
    public boolean getUseSpellingCorrection() {
      return useSpellingCorrection_;
    }

    public static final int USE_EMOJI_CONVERSION_FIELD_NUMBER = 89;
    private boolean useEmojiConversion_ = false;
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     * @return Whether the useEmojiConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseEmojiConversion() {
      return ((bitField1_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     * @return The useEmojiConversion.
     */
    @java.lang.Override
    public boolean getUseEmojiConversion() {
      return useEmojiConversion_;
    }

    public static final int INFORMATION_LIST_CONFIG_FIELD_NUMBER = 90;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig informationListConfig_;
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     * @return Whether the informationListConfig field is set.
     */
    @java.lang.Override
    public boolean hasInformationListConfig() {
      return ((bitField1_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     * @return The informationListConfig.
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig() {
      return informationListConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance() : informationListConfig_;
    }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder getInformationListConfigOrBuilder() {
      return informationListConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance() : informationListConfig_;
    }

    public static final int USE_HISTORY_SUGGEST_FIELD_NUMBER = 100;
    private boolean useHistorySuggest_ = true;
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     * @return Whether the useHistorySuggest field is set.
     */
    @java.lang.Override
    public boolean hasUseHistorySuggest() {
      return ((bitField1_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Suggest is a feature of word suggestion with prefix search.
     * When you type "", you may get "", "" (), "" ()
     * as suggested words.
     * Use history-based suggest feature.
     * If this is true, your previously typed words are prioritized.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     * @return The useHistorySuggest.
     */
    @java.lang.Override
    public boolean getUseHistorySuggest() {
      return useHistorySuggest_;
    }

    public static final int USE_DICTIONARY_SUGGEST_FIELD_NUMBER = 101;
    private boolean useDictionarySuggest_ = true;
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     * @return Whether the useDictionarySuggest field is set.
     */
    @java.lang.Override
    public boolean hasUseDictionarySuggest() {
      return ((bitField1_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * If this is true, words in the word dictionary are suggested even if
     * you haven't typed before.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     * @return The useDictionarySuggest.
     */
    @java.lang.Override
    public boolean getUseDictionarySuggest() {
      return useDictionarySuggest_;
    }

    public static final int USE_REALTIME_CONVERSION_FIELD_NUMBER = 102;
    private boolean useRealtimeConversion_ = true;
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     * @return Whether the useRealtimeConversion field is set.
     */
    @java.lang.Override
    public boolean hasUseRealtimeConversion() {
      return ((bitField1_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     * @return The useRealtimeConversion.
     */
    @java.lang.Override
    public boolean getUseRealtimeConversion() {
      return useRealtimeConversion_;
    }

    public static final int SUGGESTIONS_SIZE_FIELD_NUMBER = 110;
    private int suggestionsSize_ = 3;
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     * @return Whether the suggestionsSize field is set.
     */
    @java.lang.Override
    public boolean hasSuggestionsSize() {
      return ((bitField1_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     * @return The suggestionsSize.
     */
    @java.lang.Override
    public int getSuggestionsSize() {
      return suggestionsSize_;
    }

    public static final int USE_MODE_INDICATOR_FIELD_NUMBER = 120;
    private boolean useModeIndicator_ = true;
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     * @return Whether the useModeIndicator field is set.
     */
    @java.lang.Override
    public boolean hasUseModeIndicator() {
      return ((bitField1_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     * @return The useModeIndicator.
     */
    @java.lang.Override
    public boolean getUseModeIndicator() {
      return useModeIndicator_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getGeneralConfig());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(10, verboseLevel_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(20, incognitoMode_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(22, checkDefault_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(23, presentationMode_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeEnum(40, preeditMethod_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeEnum(41, sessionKeymap_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeBytes(42, customKeymapTable_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeBytes(43, customRomanTable_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeEnum(45, punctuationMethod_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeEnum(46, symbolMethod_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeEnum(47, spaceCharacterForm_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeBool(48, useKeyboardToChangePreeditMethod_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeEnum(50, historyLearningLevel_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeEnum(52, selectionShortcut_);
      }
      for (int i = 0; i < characterFormRules_.size(); i++) {
        output.writeMessage(54, characterFormRules_.get(i));
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeBool(56, useAutoImeTurnOff_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeBool(58, useCascadingWindow_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        output.writeEnum(59, shiftKeyModeSwitch_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        output.writeEnum(60, numpadCharacterForm_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        output.writeBool(61, useAutoConversion_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        output.writeUInt32(62, autoConversionKey_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        output.writeEnum(63, yenSignCharacter_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        output.writeBool(64, useJapaneseLayout_);
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        output.writeBool(65, useKanaModifierInsensitiveConversion_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        output.writeBool(66, useTypingCorrection_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        output.writeInt32(67, composingTimeoutThresholdMsec_);
      }
      if (getOverlayKeymapsList().size() > 0) {
        output.writeUInt32NoTag(546);
        output.writeUInt32NoTag(overlayKeymapsMemoizedSerializedSize);
      }
      for (int i = 0; i < overlayKeymaps_.size(); i++) {
        output.writeEnumNoTag(overlayKeymaps_.get(i));
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        output.writeBool(80, useDateConversion_);
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        output.writeBool(81, useSingleKanjiConversion_);
      }
      if (((bitField0_ & 0x10000000) != 0)) {
        output.writeBool(82, useSymbolConversion_);
      }
      if (((bitField0_ & 0x20000000) != 0)) {
        output.writeBool(83, useNumberConversion_);
      }
      if (((bitField0_ & 0x40000000) != 0)) {
        output.writeBool(84, useEmoticonConversion_);
      }
      if (((bitField0_ & 0x80000000) != 0)) {
        output.writeBool(85, useCalculator_);
      }
      if (((bitField1_ & 0x00000001) != 0)) {
        output.writeBool(86, useT13NConversion_);
      }
      if (((bitField1_ & 0x00000002) != 0)) {
        output.writeBool(87, useZipCodeConversion_);
      }
      if (((bitField1_ & 0x00000004) != 0)) {
        output.writeBool(88, useSpellingCorrection_);
      }
      if (((bitField1_ & 0x00000008) != 0)) {
        output.writeBool(89, useEmojiConversion_);
      }
      if (((bitField1_ & 0x00000010) != 0)) {
        output.writeMessage(90, getInformationListConfig());
      }
      if (((bitField1_ & 0x00000020) != 0)) {
        output.writeBool(100, useHistorySuggest_);
      }
      if (((bitField1_ & 0x00000040) != 0)) {
        output.writeBool(101, useDictionarySuggest_);
      }
      if (((bitField1_ & 0x00000080) != 0)) {
        output.writeBool(102, useRealtimeConversion_);
      }
      if (((bitField1_ & 0x00000100) != 0)) {
        output.writeUInt32(110, suggestionsSize_);
      }
      if (((bitField1_ & 0x00000200) != 0)) {
        output.writeBool(120, useModeIndicator_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getGeneralConfig());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(10, verboseLevel_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(20, incognitoMode_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(22, checkDefault_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(23, presentationMode_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(40, preeditMethod_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(41, sessionKeymap_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(42, customKeymapTable_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(43, customRomanTable_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(45, punctuationMethod_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(46, symbolMethod_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(47, spaceCharacterForm_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(48, useKeyboardToChangePreeditMethod_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(50, historyLearningLevel_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(52, selectionShortcut_);
      }
      for (int i = 0; i < characterFormRules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(54, characterFormRules_.get(i));
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(56, useAutoImeTurnOff_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(58, useCascadingWindow_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(59, shiftKeyModeSwitch_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(60, numpadCharacterForm_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(61, useAutoConversion_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(62, autoConversionKey_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(63, yenSignCharacter_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(64, useJapaneseLayout_);
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(65, useKanaModifierInsensitiveConversion_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(66, useTypingCorrection_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(67, composingTimeoutThresholdMsec_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < overlayKeymaps_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(overlayKeymaps_.get(i));
        }
        size += dataSize;
        if (!getOverlayKeymapsList().isEmpty()) {  size += 2;
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(dataSize);
        }overlayKeymapsMemoizedSerializedSize = dataSize;
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(80, useDateConversion_);
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(81, useSingleKanjiConversion_);
      }
      if (((bitField0_ & 0x10000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(82, useSymbolConversion_);
      }
      if (((bitField0_ & 0x20000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(83, useNumberConversion_);
      }
      if (((bitField0_ & 0x40000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(84, useEmoticonConversion_);
      }
      if (((bitField0_ & 0x80000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(85, useCalculator_);
      }
      if (((bitField1_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(86, useT13NConversion_);
      }
      if (((bitField1_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(87, useZipCodeConversion_);
      }
      if (((bitField1_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(88, useSpellingCorrection_);
      }
      if (((bitField1_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(89, useEmojiConversion_);
      }
      if (((bitField1_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(90, getInformationListConfig());
      }
      if (((bitField1_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(100, useHistorySuggest_);
      }
      if (((bitField1_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(101, useDictionarySuggest_);
      }
      if (((bitField1_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(102, useRealtimeConversion_);
      }
      if (((bitField1_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(110, suggestionsSize_);
      }
      if (((bitField1_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(120, useModeIndicator_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config) obj;

      if (hasGeneralConfig() != other.hasGeneralConfig()) return false;
      if (hasGeneralConfig()) {
        if (!getGeneralConfig()
            .equals(other.getGeneralConfig())) return false;
      }
      if (hasVerboseLevel() != other.hasVerboseLevel()) return false;
      if (hasVerboseLevel()) {
        if (getVerboseLevel()
            != other.getVerboseLevel()) return false;
      }
      if (hasIncognitoMode() != other.hasIncognitoMode()) return false;
      if (hasIncognitoMode()) {
        if (getIncognitoMode()
            != other.getIncognitoMode()) return false;
      }
      if (hasCheckDefault() != other.hasCheckDefault()) return false;
      if (hasCheckDefault()) {
        if (getCheckDefault()
            != other.getCheckDefault()) return false;
      }
      if (hasPresentationMode() != other.hasPresentationMode()) return false;
      if (hasPresentationMode()) {
        if (getPresentationMode()
            != other.getPresentationMode()) return false;
      }
      if (hasPreeditMethod() != other.hasPreeditMethod()) return false;
      if (hasPreeditMethod()) {
        if (preeditMethod_ != other.preeditMethod_) return false;
      }
      if (hasSessionKeymap() != other.hasSessionKeymap()) return false;
      if (hasSessionKeymap()) {
        if (sessionKeymap_ != other.sessionKeymap_) return false;
      }
      if (hasCustomKeymapTable() != other.hasCustomKeymapTable()) return false;
      if (hasCustomKeymapTable()) {
        if (!getCustomKeymapTable()
            .equals(other.getCustomKeymapTable())) return false;
      }
      if (hasCustomRomanTable() != other.hasCustomRomanTable()) return false;
      if (hasCustomRomanTable()) {
        if (!getCustomRomanTable()
            .equals(other.getCustomRomanTable())) return false;
      }
      if (hasPunctuationMethod() != other.hasPunctuationMethod()) return false;
      if (hasPunctuationMethod()) {
        if (punctuationMethod_ != other.punctuationMethod_) return false;
      }
      if (hasSymbolMethod() != other.hasSymbolMethod()) return false;
      if (hasSymbolMethod()) {
        if (symbolMethod_ != other.symbolMethod_) return false;
      }
      if (hasSpaceCharacterForm() != other.hasSpaceCharacterForm()) return false;
      if (hasSpaceCharacterForm()) {
        if (spaceCharacterForm_ != other.spaceCharacterForm_) return false;
      }
      if (hasUseKeyboardToChangePreeditMethod() != other.hasUseKeyboardToChangePreeditMethod()) return false;
      if (hasUseKeyboardToChangePreeditMethod()) {
        if (getUseKeyboardToChangePreeditMethod()
            != other.getUseKeyboardToChangePreeditMethod()) return false;
      }
      if (hasHistoryLearningLevel() != other.hasHistoryLearningLevel()) return false;
      if (hasHistoryLearningLevel()) {
        if (historyLearningLevel_ != other.historyLearningLevel_) return false;
      }
      if (hasSelectionShortcut() != other.hasSelectionShortcut()) return false;
      if (hasSelectionShortcut()) {
        if (selectionShortcut_ != other.selectionShortcut_) return false;
      }
      if (!getCharacterFormRulesList()
          .equals(other.getCharacterFormRulesList())) return false;
      if (hasUseAutoImeTurnOff() != other.hasUseAutoImeTurnOff()) return false;
      if (hasUseAutoImeTurnOff()) {
        if (getUseAutoImeTurnOff()
            != other.getUseAutoImeTurnOff()) return false;
      }
      if (hasUseCascadingWindow() != other.hasUseCascadingWindow()) return false;
      if (hasUseCascadingWindow()) {
        if (getUseCascadingWindow()
            != other.getUseCascadingWindow()) return false;
      }
      if (hasShiftKeyModeSwitch() != other.hasShiftKeyModeSwitch()) return false;
      if (hasShiftKeyModeSwitch()) {
        if (shiftKeyModeSwitch_ != other.shiftKeyModeSwitch_) return false;
      }
      if (hasNumpadCharacterForm() != other.hasNumpadCharacterForm()) return false;
      if (hasNumpadCharacterForm()) {
        if (numpadCharacterForm_ != other.numpadCharacterForm_) return false;
      }
      if (hasUseAutoConversion() != other.hasUseAutoConversion()) return false;
      if (hasUseAutoConversion()) {
        if (getUseAutoConversion()
            != other.getUseAutoConversion()) return false;
      }
      if (hasAutoConversionKey() != other.hasAutoConversionKey()) return false;
      if (hasAutoConversionKey()) {
        if (getAutoConversionKey()
            != other.getAutoConversionKey()) return false;
      }
      if (hasYenSignCharacter() != other.hasYenSignCharacter()) return false;
      if (hasYenSignCharacter()) {
        if (yenSignCharacter_ != other.yenSignCharacter_) return false;
      }
      if (hasUseJapaneseLayout() != other.hasUseJapaneseLayout()) return false;
      if (hasUseJapaneseLayout()) {
        if (getUseJapaneseLayout()
            != other.getUseJapaneseLayout()) return false;
      }
      if (hasUseKanaModifierInsensitiveConversion() != other.hasUseKanaModifierInsensitiveConversion()) return false;
      if (hasUseKanaModifierInsensitiveConversion()) {
        if (getUseKanaModifierInsensitiveConversion()
            != other.getUseKanaModifierInsensitiveConversion()) return false;
      }
      if (hasUseTypingCorrection() != other.hasUseTypingCorrection()) return false;
      if (hasUseTypingCorrection()) {
        if (getUseTypingCorrection()
            != other.getUseTypingCorrection()) return false;
      }
      if (hasComposingTimeoutThresholdMsec() != other.hasComposingTimeoutThresholdMsec()) return false;
      if (hasComposingTimeoutThresholdMsec()) {
        if (getComposingTimeoutThresholdMsec()
            != other.getComposingTimeoutThresholdMsec()) return false;
      }
      if (!overlayKeymaps_.equals(other.overlayKeymaps_)) return false;
      if (hasUseDateConversion() != other.hasUseDateConversion()) return false;
      if (hasUseDateConversion()) {
        if (getUseDateConversion()
            != other.getUseDateConversion()) return false;
      }
      if (hasUseSingleKanjiConversion() != other.hasUseSingleKanjiConversion()) return false;
      if (hasUseSingleKanjiConversion()) {
        if (getUseSingleKanjiConversion()
            != other.getUseSingleKanjiConversion()) return false;
      }
      if (hasUseSymbolConversion() != other.hasUseSymbolConversion()) return false;
      if (hasUseSymbolConversion()) {
        if (getUseSymbolConversion()
            != other.getUseSymbolConversion()) return false;
      }
      if (hasUseNumberConversion() != other.hasUseNumberConversion()) return false;
      if (hasUseNumberConversion()) {
        if (getUseNumberConversion()
            != other.getUseNumberConversion()) return false;
      }
      if (hasUseEmoticonConversion() != other.hasUseEmoticonConversion()) return false;
      if (hasUseEmoticonConversion()) {
        if (getUseEmoticonConversion()
            != other.getUseEmoticonConversion()) return false;
      }
      if (hasUseCalculator() != other.hasUseCalculator()) return false;
      if (hasUseCalculator()) {
        if (getUseCalculator()
            != other.getUseCalculator()) return false;
      }
      if (hasUseT13NConversion() != other.hasUseT13NConversion()) return false;
      if (hasUseT13NConversion()) {
        if (getUseT13NConversion()
            != other.getUseT13NConversion()) return false;
      }
      if (hasUseZipCodeConversion() != other.hasUseZipCodeConversion()) return false;
      if (hasUseZipCodeConversion()) {
        if (getUseZipCodeConversion()
            != other.getUseZipCodeConversion()) return false;
      }
      if (hasUseSpellingCorrection() != other.hasUseSpellingCorrection()) return false;
      if (hasUseSpellingCorrection()) {
        if (getUseSpellingCorrection()
            != other.getUseSpellingCorrection()) return false;
      }
      if (hasUseEmojiConversion() != other.hasUseEmojiConversion()) return false;
      if (hasUseEmojiConversion()) {
        if (getUseEmojiConversion()
            != other.getUseEmojiConversion()) return false;
      }
      if (hasInformationListConfig() != other.hasInformationListConfig()) return false;
      if (hasInformationListConfig()) {
        if (!getInformationListConfig()
            .equals(other.getInformationListConfig())) return false;
      }
      if (hasUseHistorySuggest() != other.hasUseHistorySuggest()) return false;
      if (hasUseHistorySuggest()) {
        if (getUseHistorySuggest()
            != other.getUseHistorySuggest()) return false;
      }
      if (hasUseDictionarySuggest() != other.hasUseDictionarySuggest()) return false;
      if (hasUseDictionarySuggest()) {
        if (getUseDictionarySuggest()
            != other.getUseDictionarySuggest()) return false;
      }
      if (hasUseRealtimeConversion() != other.hasUseRealtimeConversion()) return false;
      if (hasUseRealtimeConversion()) {
        if (getUseRealtimeConversion()
            != other.getUseRealtimeConversion()) return false;
      }
      if (hasSuggestionsSize() != other.hasSuggestionsSize()) return false;
      if (hasSuggestionsSize()) {
        if (getSuggestionsSize()
            != other.getSuggestionsSize()) return false;
      }
      if (hasUseModeIndicator() != other.hasUseModeIndicator()) return false;
      if (hasUseModeIndicator()) {
        if (getUseModeIndicator()
            != other.getUseModeIndicator()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGeneralConfig()) {
        hash = (37 * hash) + GENERAL_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getGeneralConfig().hashCode();
      }
      if (hasVerboseLevel()) {
        hash = (37 * hash) + VERBOSE_LEVEL_FIELD_NUMBER;
        hash = (53 * hash) + getVerboseLevel();
      }
      if (hasIncognitoMode()) {
        hash = (37 * hash) + INCOGNITO_MODE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIncognitoMode());
      }
      if (hasCheckDefault()) {
        hash = (37 * hash) + CHECK_DEFAULT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getCheckDefault());
      }
      if (hasPresentationMode()) {
        hash = (37 * hash) + PRESENTATION_MODE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPresentationMode());
      }
      if (hasPreeditMethod()) {
        hash = (37 * hash) + PREEDIT_METHOD_FIELD_NUMBER;
        hash = (53 * hash) + preeditMethod_;
      }
      if (hasSessionKeymap()) {
        hash = (37 * hash) + SESSION_KEYMAP_FIELD_NUMBER;
        hash = (53 * hash) + sessionKeymap_;
      }
      if (hasCustomKeymapTable()) {
        hash = (37 * hash) + CUSTOM_KEYMAP_TABLE_FIELD_NUMBER;
        hash = (53 * hash) + getCustomKeymapTable().hashCode();
      }
      if (hasCustomRomanTable()) {
        hash = (37 * hash) + CUSTOM_ROMAN_TABLE_FIELD_NUMBER;
        hash = (53 * hash) + getCustomRomanTable().hashCode();
      }
      if (hasPunctuationMethod()) {
        hash = (37 * hash) + PUNCTUATION_METHOD_FIELD_NUMBER;
        hash = (53 * hash) + punctuationMethod_;
      }
      if (hasSymbolMethod()) {
        hash = (37 * hash) + SYMBOL_METHOD_FIELD_NUMBER;
        hash = (53 * hash) + symbolMethod_;
      }
      if (hasSpaceCharacterForm()) {
        hash = (37 * hash) + SPACE_CHARACTER_FORM_FIELD_NUMBER;
        hash = (53 * hash) + spaceCharacterForm_;
      }
      if (hasUseKeyboardToChangePreeditMethod()) {
        hash = (37 * hash) + USE_KEYBOARD_TO_CHANGE_PREEDIT_METHOD_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseKeyboardToChangePreeditMethod());
      }
      if (hasHistoryLearningLevel()) {
        hash = (37 * hash) + HISTORY_LEARNING_LEVEL_FIELD_NUMBER;
        hash = (53 * hash) + historyLearningLevel_;
      }
      if (hasSelectionShortcut()) {
        hash = (37 * hash) + SELECTION_SHORTCUT_FIELD_NUMBER;
        hash = (53 * hash) + selectionShortcut_;
      }
      if (getCharacterFormRulesCount() > 0) {
        hash = (37 * hash) + CHARACTER_FORM_RULES_FIELD_NUMBER;
        hash = (53 * hash) + getCharacterFormRulesList().hashCode();
      }
      if (hasUseAutoImeTurnOff()) {
        hash = (37 * hash) + USE_AUTO_IME_TURN_OFF_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseAutoImeTurnOff());
      }
      if (hasUseCascadingWindow()) {
        hash = (37 * hash) + USE_CASCADING_WINDOW_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseCascadingWindow());
      }
      if (hasShiftKeyModeSwitch()) {
        hash = (37 * hash) + SHIFT_KEY_MODE_SWITCH_FIELD_NUMBER;
        hash = (53 * hash) + shiftKeyModeSwitch_;
      }
      if (hasNumpadCharacterForm()) {
        hash = (37 * hash) + NUMPAD_CHARACTER_FORM_FIELD_NUMBER;
        hash = (53 * hash) + numpadCharacterForm_;
      }
      if (hasUseAutoConversion()) {
        hash = (37 * hash) + USE_AUTO_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseAutoConversion());
      }
      if (hasAutoConversionKey()) {
        hash = (37 * hash) + AUTO_CONVERSION_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getAutoConversionKey();
      }
      if (hasYenSignCharacter()) {
        hash = (37 * hash) + YEN_SIGN_CHARACTER_FIELD_NUMBER;
        hash = (53 * hash) + yenSignCharacter_;
      }
      if (hasUseJapaneseLayout()) {
        hash = (37 * hash) + USE_JAPANESE_LAYOUT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseJapaneseLayout());
      }
      if (hasUseKanaModifierInsensitiveConversion()) {
        hash = (37 * hash) + USE_KANA_MODIFIER_INSENSITIVE_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseKanaModifierInsensitiveConversion());
      }
      if (hasUseTypingCorrection()) {
        hash = (37 * hash) + USE_TYPING_CORRECTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseTypingCorrection());
      }
      if (hasComposingTimeoutThresholdMsec()) {
        hash = (37 * hash) + COMPOSING_TIMEOUT_THRESHOLD_MSEC_FIELD_NUMBER;
        hash = (53 * hash) + getComposingTimeoutThresholdMsec();
      }
      if (getOverlayKeymapsCount() > 0) {
        hash = (37 * hash) + OVERLAY_KEYMAPS_FIELD_NUMBER;
        hash = (53 * hash) + overlayKeymaps_.hashCode();
      }
      if (hasUseDateConversion()) {
        hash = (37 * hash) + USE_DATE_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDateConversion());
      }
      if (hasUseSingleKanjiConversion()) {
        hash = (37 * hash) + USE_SINGLE_KANJI_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseSingleKanjiConversion());
      }
      if (hasUseSymbolConversion()) {
        hash = (37 * hash) + USE_SYMBOL_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseSymbolConversion());
      }
      if (hasUseNumberConversion()) {
        hash = (37 * hash) + USE_NUMBER_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseNumberConversion());
      }
      if (hasUseEmoticonConversion()) {
        hash = (37 * hash) + USE_EMOTICON_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseEmoticonConversion());
      }
      if (hasUseCalculator()) {
        hash = (37 * hash) + USE_CALCULATOR_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseCalculator());
      }
      if (hasUseT13NConversion()) {
        hash = (37 * hash) + USE_T13N_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseT13NConversion());
      }
      if (hasUseZipCodeConversion()) {
        hash = (37 * hash) + USE_ZIP_CODE_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseZipCodeConversion());
      }
      if (hasUseSpellingCorrection()) {
        hash = (37 * hash) + USE_SPELLING_CORRECTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseSpellingCorrection());
      }
      if (hasUseEmojiConversion()) {
        hash = (37 * hash) + USE_EMOJI_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseEmojiConversion());
      }
      if (hasInformationListConfig()) {
        hash = (37 * hash) + INFORMATION_LIST_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getInformationListConfig().hashCode();
      }
      if (hasUseHistorySuggest()) {
        hash = (37 * hash) + USE_HISTORY_SUGGEST_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseHistorySuggest());
      }
      if (hasUseDictionarySuggest()) {
        hash = (37 * hash) + USE_DICTIONARY_SUGGEST_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDictionarySuggest());
      }
      if (hasUseRealtimeConversion()) {
        hash = (37 * hash) + USE_REALTIME_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseRealtimeConversion());
      }
      if (hasSuggestionsSize()) {
        hash = (37 * hash) + SUGGESTIONS_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getSuggestionsSize();
      }
      if (hasUseModeIndicator()) {
        hash = (37 * hash) + USE_MODE_INDICATOR_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseModeIndicator());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.config.Config}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.config.Config)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getGeneralConfigFieldBuilder();
          getCharacterFormRulesFieldBuilder();
          getInformationListConfigFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        bitField1_ = 0;
        generalConfig_ = null;
        if (generalConfigBuilder_ != null) {
          generalConfigBuilder_.dispose();
          generalConfigBuilder_ = null;
        }
        verboseLevel_ = 0;
        incognitoMode_ = false;
        checkDefault_ = true;
        presentationMode_ = false;
        preeditMethod_ = 0;
        sessionKeymap_ = -1;
        customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
        customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
        punctuationMethod_ = 0;
        symbolMethod_ = 0;
        spaceCharacterForm_ = 0;
        useKeyboardToChangePreeditMethod_ = false;
        historyLearningLevel_ = 0;
        selectionShortcut_ = 1;
        if (characterFormRulesBuilder_ == null) {
          characterFormRules_ = java.util.Collections.emptyList();
        } else {
          characterFormRules_ = null;
          characterFormRulesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00008000);
        useAutoImeTurnOff_ = true;
        useCascadingWindow_ = true;
        shiftKeyModeSwitch_ = 1;
        numpadCharacterForm_ = 2;
        useAutoConversion_ = false;
        autoConversionKey_ = 13;
        yenSignCharacter_ = 0;
        useJapaneseLayout_ = false;
        useKanaModifierInsensitiveConversion_ = false;
        useTypingCorrection_ = false;
        composingTimeoutThresholdMsec_ = 0;
        overlayKeymaps_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x08000000);
        useDateConversion_ = true;
        useSingleKanjiConversion_ = true;
        useSymbolConversion_ = true;
        useNumberConversion_ = true;
        useEmoticonConversion_ = true;
        useCalculator_ = true;
        useT13NConversion_ = true;
        useZipCodeConversion_ = true;
        useSpellingCorrection_ = true;
        useEmojiConversion_ = false;
        informationListConfig_ = null;
        if (informationListConfigBuilder_ != null) {
          informationListConfigBuilder_.dispose();
          informationListConfigBuilder_ = null;
        }
        useHistorySuggest_ = true;
        useDictionarySuggest_ = true;
        useRealtimeConversion_ = true;
        suggestionsSize_ = 3;
        useModeIndicator_ = true;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_descriptor;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance();
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        if (bitField1_ != 0) { buildPartial1(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config result) {
        if (characterFormRulesBuilder_ == null) {
          if (((bitField0_ & 0x00008000) != 0)) {
            characterFormRules_ = java.util.Collections.unmodifiableList(characterFormRules_);
            bitField0_ = (bitField0_ & ~0x00008000);
          }
          result.characterFormRules_ = characterFormRules_;
        } else {
          result.characterFormRules_ = characterFormRulesBuilder_.build();
        }
        if (((bitField0_ & 0x08000000) != 0)) {
          overlayKeymaps_ = java.util.Collections.unmodifiableList(overlayKeymaps_);
          bitField0_ = (bitField0_ & ~0x08000000);
        }
        result.overlayKeymaps_ = overlayKeymaps_;
      }

      private void buildPartial0(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.generalConfig_ = generalConfigBuilder_ == null
              ? generalConfig_
              : generalConfigBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.verboseLevel_ = verboseLevel_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.incognitoMode_ = incognitoMode_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.checkDefault_ = checkDefault_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.presentationMode_ = presentationMode_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.preeditMethod_ = preeditMethod_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.sessionKeymap_ = sessionKeymap_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.customKeymapTable_ = customKeymapTable_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.customRomanTable_ = customRomanTable_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.punctuationMethod_ = punctuationMethod_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.symbolMethod_ = symbolMethod_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.spaceCharacterForm_ = spaceCharacterForm_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.useKeyboardToChangePreeditMethod_ = useKeyboardToChangePreeditMethod_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.historyLearningLevel_ = historyLearningLevel_;
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.selectionShortcut_ = selectionShortcut_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.useAutoImeTurnOff_ = useAutoImeTurnOff_;
          to_bitField0_ |= 0x00008000;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.useCascadingWindow_ = useCascadingWindow_;
          to_bitField0_ |= 0x00010000;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.shiftKeyModeSwitch_ = shiftKeyModeSwitch_;
          to_bitField0_ |= 0x00020000;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          result.numpadCharacterForm_ = numpadCharacterForm_;
          to_bitField0_ |= 0x00040000;
        }
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.useAutoConversion_ = useAutoConversion_;
          to_bitField0_ |= 0x00080000;
        }
        if (((from_bitField0_ & 0x00200000) != 0)) {
          result.autoConversionKey_ = autoConversionKey_;
          to_bitField0_ |= 0x00100000;
        }
        if (((from_bitField0_ & 0x00400000) != 0)) {
          result.yenSignCharacter_ = yenSignCharacter_;
          to_bitField0_ |= 0x00200000;
        }
        if (((from_bitField0_ & 0x00800000) != 0)) {
          result.useJapaneseLayout_ = useJapaneseLayout_;
          to_bitField0_ |= 0x00400000;
        }
        if (((from_bitField0_ & 0x01000000) != 0)) {
          result.useKanaModifierInsensitiveConversion_ = useKanaModifierInsensitiveConversion_;
          to_bitField0_ |= 0x00800000;
        }
        if (((from_bitField0_ & 0x02000000) != 0)) {
          result.useTypingCorrection_ = useTypingCorrection_;
          to_bitField0_ |= 0x01000000;
        }
        if (((from_bitField0_ & 0x04000000) != 0)) {
          result.composingTimeoutThresholdMsec_ = composingTimeoutThresholdMsec_;
          to_bitField0_ |= 0x02000000;
        }
        if (((from_bitField0_ & 0x10000000) != 0)) {
          result.useDateConversion_ = useDateConversion_;
          to_bitField0_ |= 0x04000000;
        }
        if (((from_bitField0_ & 0x20000000) != 0)) {
          result.useSingleKanjiConversion_ = useSingleKanjiConversion_;
          to_bitField0_ |= 0x08000000;
        }
        if (((from_bitField0_ & 0x40000000) != 0)) {
          result.useSymbolConversion_ = useSymbolConversion_;
          to_bitField0_ |= 0x10000000;
        }
        if (((from_bitField0_ & 0x80000000) != 0)) {
          result.useNumberConversion_ = useNumberConversion_;
          to_bitField0_ |= 0x20000000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      private void buildPartial1(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config result) {
        int from_bitField1_ = bitField1_;
        int to_bitField0_ = 0;
        if (((from_bitField1_ & 0x00000001) != 0)) {
          result.useEmoticonConversion_ = useEmoticonConversion_;
          to_bitField0_ |= 0x40000000;
        }
        if (((from_bitField1_ & 0x00000002) != 0)) {
          result.useCalculator_ = useCalculator_;
          to_bitField0_ |= 0x80000000;
        }
        int to_bitField1_ = 0;
        if (((from_bitField1_ & 0x00000004) != 0)) {
          result.useT13NConversion_ = useT13NConversion_;
          to_bitField1_ |= 0x00000001;
        }
        if (((from_bitField1_ & 0x00000008) != 0)) {
          result.useZipCodeConversion_ = useZipCodeConversion_;
          to_bitField1_ |= 0x00000002;
        }
        if (((from_bitField1_ & 0x00000010) != 0)) {
          result.useSpellingCorrection_ = useSpellingCorrection_;
          to_bitField1_ |= 0x00000004;
        }
        if (((from_bitField1_ & 0x00000020) != 0)) {
          result.useEmojiConversion_ = useEmojiConversion_;
          to_bitField1_ |= 0x00000008;
        }
        if (((from_bitField1_ & 0x00000040) != 0)) {
          result.informationListConfig_ = informationListConfigBuilder_ == null
              ? informationListConfig_
              : informationListConfigBuilder_.build();
          to_bitField1_ |= 0x00000010;
        }
        if (((from_bitField1_ & 0x00000080) != 0)) {
          result.useHistorySuggest_ = useHistorySuggest_;
          to_bitField1_ |= 0x00000020;
        }
        if (((from_bitField1_ & 0x00000100) != 0)) {
          result.useDictionarySuggest_ = useDictionarySuggest_;
          to_bitField1_ |= 0x00000040;
        }
        if (((from_bitField1_ & 0x00000200) != 0)) {
          result.useRealtimeConversion_ = useRealtimeConversion_;
          to_bitField1_ |= 0x00000080;
        }
        if (((from_bitField1_ & 0x00000400) != 0)) {
          result.suggestionsSize_ = suggestionsSize_;
          to_bitField1_ |= 0x00000100;
        }
        if (((from_bitField1_ & 0x00000800) != 0)) {
          result.useModeIndicator_ = useModeIndicator_;
          to_bitField1_ |= 0x00000200;
        }
        result.bitField0_ |= to_bitField0_;
        result.bitField1_ |= to_bitField1_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance()) return this;
        if (other.hasGeneralConfig()) {
          mergeGeneralConfig(other.getGeneralConfig());
        }
        if (other.hasVerboseLevel()) {
          setVerboseLevel(other.getVerboseLevel());
        }
        if (other.hasIncognitoMode()) {
          setIncognitoMode(other.getIncognitoMode());
        }
        if (other.hasCheckDefault()) {
          setCheckDefault(other.getCheckDefault());
        }
        if (other.hasPresentationMode()) {
          setPresentationMode(other.getPresentationMode());
        }
        if (other.hasPreeditMethod()) {
          setPreeditMethod(other.getPreeditMethod());
        }
        if (other.hasSessionKeymap()) {
          setSessionKeymap(other.getSessionKeymap());
        }
        if (other.hasCustomKeymapTable()) {
          setCustomKeymapTable(other.getCustomKeymapTable());
        }
        if (other.hasCustomRomanTable()) {
          setCustomRomanTable(other.getCustomRomanTable());
        }
        if (other.hasPunctuationMethod()) {
          setPunctuationMethod(other.getPunctuationMethod());
        }
        if (other.hasSymbolMethod()) {
          setSymbolMethod(other.getSymbolMethod());
        }
        if (other.hasSpaceCharacterForm()) {
          setSpaceCharacterForm(other.getSpaceCharacterForm());
        }
        if (other.hasUseKeyboardToChangePreeditMethod()) {
          setUseKeyboardToChangePreeditMethod(other.getUseKeyboardToChangePreeditMethod());
        }
        if (other.hasHistoryLearningLevel()) {
          setHistoryLearningLevel(other.getHistoryLearningLevel());
        }
        if (other.hasSelectionShortcut()) {
          setSelectionShortcut(other.getSelectionShortcut());
        }
        if (characterFormRulesBuilder_ == null) {
          if (!other.characterFormRules_.isEmpty()) {
            if (characterFormRules_.isEmpty()) {
              characterFormRules_ = other.characterFormRules_;
              bitField0_ = (bitField0_ & ~0x00008000);
            } else {
              ensureCharacterFormRulesIsMutable();
              characterFormRules_.addAll(other.characterFormRules_);
            }
            onChanged();
          }
        } else {
          if (!other.characterFormRules_.isEmpty()) {
            if (characterFormRulesBuilder_.isEmpty()) {
              characterFormRulesBuilder_.dispose();
              characterFormRulesBuilder_ = null;
              characterFormRules_ = other.characterFormRules_;
              bitField0_ = (bitField0_ & ~0x00008000);
              characterFormRulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCharacterFormRulesFieldBuilder() : null;
            } else {
              characterFormRulesBuilder_.addAllMessages(other.characterFormRules_);
            }
          }
        }
        if (other.hasUseAutoImeTurnOff()) {
          setUseAutoImeTurnOff(other.getUseAutoImeTurnOff());
        }
        if (other.hasUseCascadingWindow()) {
          setUseCascadingWindow(other.getUseCascadingWindow());
        }
        if (other.hasShiftKeyModeSwitch()) {
          setShiftKeyModeSwitch(other.getShiftKeyModeSwitch());
        }
        if (other.hasNumpadCharacterForm()) {
          setNumpadCharacterForm(other.getNumpadCharacterForm());
        }
        if (other.hasUseAutoConversion()) {
          setUseAutoConversion(other.getUseAutoConversion());
        }
        if (other.hasAutoConversionKey()) {
          setAutoConversionKey(other.getAutoConversionKey());
        }
        if (other.hasYenSignCharacter()) {
          setYenSignCharacter(other.getYenSignCharacter());
        }
        if (other.hasUseJapaneseLayout()) {
          setUseJapaneseLayout(other.getUseJapaneseLayout());
        }
        if (other.hasUseKanaModifierInsensitiveConversion()) {
          setUseKanaModifierInsensitiveConversion(other.getUseKanaModifierInsensitiveConversion());
        }
        if (other.hasUseTypingCorrection()) {
          setUseTypingCorrection(other.getUseTypingCorrection());
        }
        if (other.hasComposingTimeoutThresholdMsec()) {
          setComposingTimeoutThresholdMsec(other.getComposingTimeoutThresholdMsec());
        }
        if (!other.overlayKeymaps_.isEmpty()) {
          if (overlayKeymaps_.isEmpty()) {
            overlayKeymaps_ = other.overlayKeymaps_;
            bitField0_ = (bitField0_ & ~0x08000000);
          } else {
            ensureOverlayKeymapsIsMutable();
            overlayKeymaps_.addAll(other.overlayKeymaps_);
          }
          onChanged();
        }
        if (other.hasUseDateConversion()) {
          setUseDateConversion(other.getUseDateConversion());
        }
        if (other.hasUseSingleKanjiConversion()) {
          setUseSingleKanjiConversion(other.getUseSingleKanjiConversion());
        }
        if (other.hasUseSymbolConversion()) {
          setUseSymbolConversion(other.getUseSymbolConversion());
        }
        if (other.hasUseNumberConversion()) {
          setUseNumberConversion(other.getUseNumberConversion());
        }
        if (other.hasUseEmoticonConversion()) {
          setUseEmoticonConversion(other.getUseEmoticonConversion());
        }
        if (other.hasUseCalculator()) {
          setUseCalculator(other.getUseCalculator());
        }
        if (other.hasUseT13NConversion()) {
          setUseT13NConversion(other.getUseT13NConversion());
        }
        if (other.hasUseZipCodeConversion()) {
          setUseZipCodeConversion(other.getUseZipCodeConversion());
        }
        if (other.hasUseSpellingCorrection()) {
          setUseSpellingCorrection(other.getUseSpellingCorrection());
        }
        if (other.hasUseEmojiConversion()) {
          setUseEmojiConversion(other.getUseEmojiConversion());
        }
        if (other.hasInformationListConfig()) {
          mergeInformationListConfig(other.getInformationListConfig());
        }
        if (other.hasUseHistorySuggest()) {
          setUseHistorySuggest(other.getUseHistorySuggest());
        }
        if (other.hasUseDictionarySuggest()) {
          setUseDictionarySuggest(other.getUseDictionarySuggest());
        }
        if (other.hasUseRealtimeConversion()) {
          setUseRealtimeConversion(other.getUseRealtimeConversion());
        }
        if (other.hasSuggestionsSize()) {
          setSuggestionsSize(other.getSuggestionsSize());
        }
        if (other.hasUseModeIndicator()) {
          setUseModeIndicator(other.getUseModeIndicator());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getGeneralConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 80: {
                verboseLevel_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 80
              case 160: {
                incognitoMode_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 160
              case 176: {
                checkDefault_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 176
              case 184: {
                presentationMode_ = input.readBool();
                bitField0_ |= 0x00000010;
                break;
              } // case 184
              case 320: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(40, tmpRaw);
                } else {
                  preeditMethod_ = tmpRaw;
                  bitField0_ |= 0x00000020;
                }
                break;
              } // case 320
              case 328: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(41, tmpRaw);
                } else {
                  sessionKeymap_ = tmpRaw;
                  bitField0_ |= 0x00000040;
                }
                break;
              } // case 328
              case 338: {
                customKeymapTable_ = input.readBytes();
                bitField0_ |= 0x00000080;
                break;
              } // case 338
              case 346: {
                customRomanTable_ = input.readBytes();
                bitField0_ |= 0x00000100;
                break;
              } // case 346
              case 360: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(45, tmpRaw);
                } else {
                  punctuationMethod_ = tmpRaw;
                  bitField0_ |= 0x00000200;
                }
                break;
              } // case 360
              case 368: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(46, tmpRaw);
                } else {
                  symbolMethod_ = tmpRaw;
                  bitField0_ |= 0x00000400;
                }
                break;
              } // case 368
              case 376: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(47, tmpRaw);
                } else {
                  spaceCharacterForm_ = tmpRaw;
                  bitField0_ |= 0x00000800;
                }
                break;
              } // case 376
              case 384: {
                useKeyboardToChangePreeditMethod_ = input.readBool();
                bitField0_ |= 0x00001000;
                break;
              } // case 384
              case 400: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(50, tmpRaw);
                } else {
                  historyLearningLevel_ = tmpRaw;
                  bitField0_ |= 0x00002000;
                }
                break;
              } // case 400
              case 416: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(52, tmpRaw);
                } else {
                  selectionShortcut_ = tmpRaw;
                  bitField0_ |= 0x00004000;
                }
                break;
              } // case 416
              case 434: {
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule m =
                    input.readMessage(
                        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.PARSER,
                        extensionRegistry);
                if (characterFormRulesBuilder_ == null) {
                  ensureCharacterFormRulesIsMutable();
                  characterFormRules_.add(m);
                } else {
                  characterFormRulesBuilder_.addMessage(m);
                }
                break;
              } // case 434
              case 448: {
                useAutoImeTurnOff_ = input.readBool();
                bitField0_ |= 0x00010000;
                break;
              } // case 448
              case 464: {
                useCascadingWindow_ = input.readBool();
                bitField0_ |= 0x00020000;
                break;
              } // case 464
              case 472: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(59, tmpRaw);
                } else {
                  shiftKeyModeSwitch_ = tmpRaw;
                  bitField0_ |= 0x00040000;
                }
                break;
              } // case 472
              case 480: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(60, tmpRaw);
                } else {
                  numpadCharacterForm_ = tmpRaw;
                  bitField0_ |= 0x00080000;
                }
                break;
              } // case 480
              case 488: {
                useAutoConversion_ = input.readBool();
                bitField0_ |= 0x00100000;
                break;
              } // case 488
              case 496: {
                autoConversionKey_ = input.readUInt32();
                bitField0_ |= 0x00200000;
                break;
              } // case 496
              case 504: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(63, tmpRaw);
                } else {
                  yenSignCharacter_ = tmpRaw;
                  bitField0_ |= 0x00400000;
                }
                break;
              } // case 504
              case 512: {
                useJapaneseLayout_ = input.readBool();
                bitField0_ |= 0x00800000;
                break;
              } // case 512
              case 520: {
                useKanaModifierInsensitiveConversion_ = input.readBool();
                bitField0_ |= 0x01000000;
                break;
              } // case 520
              case 528: {
                useTypingCorrection_ = input.readBool();
                bitField0_ |= 0x02000000;
                break;
              } // case 528
              case 536: {
                composingTimeoutThresholdMsec_ = input.readInt32();
                bitField0_ |= 0x04000000;
                break;
              } // case 536
              case 544: {
                int tmpRaw = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap tmpValue =
                    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(68, tmpRaw);
                } else {
                  ensureOverlayKeymapsIsMutable();
                  overlayKeymaps_.add(tmpRaw);
                }
                break;
              } // case 544
              case 546: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap tmpValue =
                      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(68, tmpRaw);
                  } else {
                    ensureOverlayKeymapsIsMutable();
                    overlayKeymaps_.add(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 546
              case 640: {
                useDateConversion_ = input.readBool();
                bitField0_ |= 0x10000000;
                break;
              } // case 640
              case 648: {
                useSingleKanjiConversion_ = input.readBool();
                bitField0_ |= 0x20000000;
                break;
              } // case 648
              case 656: {
                useSymbolConversion_ = input.readBool();
                bitField0_ |= 0x40000000;
                break;
              } // case 656
              case 664: {
                useNumberConversion_ = input.readBool();
                bitField0_ |= 0x80000000;
                break;
              } // case 664
              case 672: {
                useEmoticonConversion_ = input.readBool();
                bitField1_ |= 0x00000001;
                break;
              } // case 672
              case 680: {
                useCalculator_ = input.readBool();
                bitField1_ |= 0x00000002;
                break;
              } // case 680
              case 688: {
                useT13NConversion_ = input.readBool();
                bitField1_ |= 0x00000004;
                break;
              } // case 688
              case 696: {
                useZipCodeConversion_ = input.readBool();
                bitField1_ |= 0x00000008;
                break;
              } // case 696
              case 704: {
                useSpellingCorrection_ = input.readBool();
                bitField1_ |= 0x00000010;
                break;
              } // case 704
              case 712: {
                useEmojiConversion_ = input.readBool();
                bitField1_ |= 0x00000020;
                break;
              } // case 712
              case 722: {
                input.readMessage(
                    getInformationListConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField1_ |= 0x00000040;
                break;
              } // case 722
              case 800: {
                useHistorySuggest_ = input.readBool();
                bitField1_ |= 0x00000080;
                break;
              } // case 800
              case 808: {
                useDictionarySuggest_ = input.readBool();
                bitField1_ |= 0x00000100;
                break;
              } // case 808
              case 816: {
                useRealtimeConversion_ = input.readBool();
                bitField1_ |= 0x00000200;
                break;
              } // case 816
              case 880: {
                suggestionsSize_ = input.readUInt32();
                bitField1_ |= 0x00000400;
                break;
              } // case 880
              case 960: {
                useModeIndicator_ = input.readBool();
                bitField1_ |= 0x00000800;
                break;
              } // case 960
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;
      private int bitField1_;

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig generalConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder> generalConfigBuilder_;
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       * @return Whether the generalConfig field is set.
       */
      public boolean hasGeneralConfig() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       * @return The generalConfig.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig() {
        if (generalConfigBuilder_ == null) {
          return generalConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance() : generalConfig_;
        } else {
          return generalConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder setGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
        if (generalConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          generalConfig_ = value;
        } else {
          generalConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder setGeneralConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder builderForValue) {
        if (generalConfigBuilder_ == null) {
          generalConfig_ = builderForValue.build();
        } else {
          generalConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder mergeGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
        if (generalConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            generalConfig_ != null &&
            generalConfig_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance()) {
            getGeneralConfigBuilder().mergeFrom(value);
          } else {
            generalConfig_ = value;
          }
        } else {
          generalConfigBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder clearGeneralConfig() {
        bitField0_ = (bitField0_ & ~0x00000001);
        generalConfig_ = null;
        if (generalConfigBuilder_ != null) {
          generalConfigBuilder_.dispose();
          generalConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder getGeneralConfigBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getGeneralConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder getGeneralConfigOrBuilder() {
        if (generalConfigBuilder_ != null) {
          return generalConfigBuilder_.getMessageOrBuilder();
        } else {
          return generalConfig_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance() : generalConfig_;
        }
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder> 
          getGeneralConfigFieldBuilder() {
        if (generalConfigBuilder_ == null) {
          generalConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder>(
                  getGeneralConfig(),
                  getParentForChildren(),
                  isClean());
          generalConfig_ = null;
        }
        return generalConfigBuilder_;
      }

      private int verboseLevel_ ;
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       * @return Whether the verboseLevel field is set.
       */
      @java.lang.Override
      public boolean hasVerboseLevel() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       * @return The verboseLevel.
       */
      @java.lang.Override
      public int getVerboseLevel() {
        return verboseLevel_;
      }
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       * @param value The verboseLevel to set.
       * @return This builder for chaining.
       */
      public Builder setVerboseLevel(int value) {
        
        verboseLevel_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearVerboseLevel() {
        bitField0_ = (bitField0_ & ~0x00000002);
        verboseLevel_ = 0;
        onChanged();
        return this;
      }

      private boolean incognitoMode_ ;
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * Clients needs to check ConversionRequest::incognito_mode() instead
       * of Config::incognito_mode(), as the incoginto mode can also set
       * via Options.
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       * @return Whether the incognitoMode field is set.
       */
      @java.lang.Override
      public boolean hasIncognitoMode() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * Clients needs to check ConversionRequest::incognito_mode() instead
       * of Config::incognito_mode(), as the incoginto mode can also set
       * via Options.
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       * @return The incognitoMode.
       */
      @java.lang.Override
      public boolean getIncognitoMode() {
        return incognitoMode_;
      }
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * Clients needs to check ConversionRequest::incognito_mode() instead
       * of Config::incognito_mode(), as the incoginto mode can also set
       * via Options.
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       * @param value The incognitoMode to set.
       * @return This builder for chaining.
       */
      public Builder setIncognitoMode(boolean value) {
        
        incognitoMode_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * Clients needs to check ConversionRequest::incognito_mode() instead
       * of Config::incognito_mode(), as the incoginto mode can also set
       * via Options.
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIncognitoMode() {
        bitField0_ = (bitField0_ & ~0x00000004);
        incognitoMode_ = false;
        onChanged();
        return this;
      }

      private boolean checkDefault_ = true;
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       * @return Whether the checkDefault field is set.
       */
      @java.lang.Override
      public boolean hasCheckDefault() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       * @return The checkDefault.
       */
      @java.lang.Override
      public boolean getCheckDefault() {
        return checkDefault_;
      }
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       * @param value The checkDefault to set.
       * @return This builder for chaining.
       */
      public Builder setCheckDefault(boolean value) {
        
        checkDefault_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearCheckDefault() {
        bitField0_ = (bitField0_ & ~0x00000008);
        checkDefault_ = true;
        onChanged();
        return this;
      }

      private boolean presentationMode_ ;
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       * @return Whether the presentationMode field is set.
       */
      @java.lang.Override
      public boolean hasPresentationMode() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       * @return The presentationMode.
       */
      @java.lang.Override
      public boolean getPresentationMode() {
        return presentationMode_;
      }
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       * @param value The presentationMode to set.
       * @return This builder for chaining.
       */
      public Builder setPresentationMode(boolean value) {
        
        presentationMode_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearPresentationMode() {
        bitField0_ = (bitField0_ & ~0x00000010);
        presentationMode_ = false;
        onChanged();
        return this;
      }

      private int preeditMethod_ = 0;
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       * @return Whether the preeditMethod field is set.
       */
      @java.lang.Override public boolean hasPreeditMethod() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       * @return The preeditMethod.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.forNumber(preeditMethod_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.ROMAN : result;
      }
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       * @param value The preeditMethod to set.
       * @return This builder for chaining.
       */
      public Builder setPreeditMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        preeditMethod_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       * @return This builder for chaining.
       */
      public Builder clearPreeditMethod() {
        bitField0_ = (bitField0_ & ~0x00000020);
        preeditMethod_ = 0;
        onChanged();
        return this;
      }

      private int sessionKeymap_ = -1;
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       * @return Whether the sessionKeymap field is set.
       */
      @java.lang.Override public boolean hasSessionKeymap() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       * @return The sessionKeymap.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.forNumber(sessionKeymap_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE : result;
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       * @param value The sessionKeymap to set.
       * @return This builder for chaining.
       */
      public Builder setSessionKeymap(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000040;
        sessionKeymap_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       * @return This builder for chaining.
       */
      public Builder clearSessionKeymap() {
        bitField0_ = (bitField0_ & ~0x00000040);
        sessionKeymap_ = -1;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       * @return Whether the customKeymapTable field is set.
       */
      @java.lang.Override
      public boolean hasCustomKeymapTable() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       * @return The customKeymapTable.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCustomKeymapTable() {
        return customKeymapTable_;
      }
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       * @param value The customKeymapTable to set.
       * @return This builder for chaining.
       */
      public Builder setCustomKeymapTable(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        customKeymapTable_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       * @return This builder for chaining.
       */
      public Builder clearCustomKeymapTable() {
        bitField0_ = (bitField0_ & ~0x00000080);
        customKeymapTable_ = getDefaultInstance().getCustomKeymapTable();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       * @return Whether the customRomanTable field is set.
       */
      @java.lang.Override
      public boolean hasCustomRomanTable() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       * @return The customRomanTable.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCustomRomanTable() {
        return customRomanTable_;
      }
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       * @param value The customRomanTable to set.
       * @return This builder for chaining.
       */
      public Builder setCustomRomanTable(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        customRomanTable_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       * @return This builder for chaining.
       */
      public Builder clearCustomRomanTable() {
        bitField0_ = (bitField0_ & ~0x00000100);
        customRomanTable_ = getDefaultInstance().getCustomRomanTable();
        onChanged();
        return this;
      }

      private int punctuationMethod_ = 0;
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       * @return Whether the punctuationMethod field is set.
       */
      @java.lang.Override public boolean hasPunctuationMethod() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       * @return The punctuationMethod.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.forNumber(punctuationMethod_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.KUTEN_TOUTEN : result;
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       * @param value The punctuationMethod to set.
       * @return This builder for chaining.
       */
      public Builder setPunctuationMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000200;
        punctuationMethod_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       * @return This builder for chaining.
       */
      public Builder clearPunctuationMethod() {
        bitField0_ = (bitField0_ & ~0x00000200);
        punctuationMethod_ = 0;
        onChanged();
        return this;
      }

      private int symbolMethod_ = 0;
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       * @return Whether the symbolMethod field is set.
       */
      @java.lang.Override public boolean hasSymbolMethod() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       * @return The symbolMethod.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.forNumber(symbolMethod_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.CORNER_BRACKET_MIDDLE_DOT : result;
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       * @param value The symbolMethod to set.
       * @return This builder for chaining.
       */
      public Builder setSymbolMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000400;
        symbolMethod_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       * @return This builder for chaining.
       */
      public Builder clearSymbolMethod() {
        bitField0_ = (bitField0_ & ~0x00000400);
        symbolMethod_ = 0;
        onChanged();
        return this;
      }

      private int spaceCharacterForm_ = 0;
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       * @return Whether the spaceCharacterForm field is set.
       */
      @java.lang.Override public boolean hasSpaceCharacterForm() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       * @return The spaceCharacterForm.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.forNumber(spaceCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.FUNDAMENTAL_INPUT_MODE : result;
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       * @param value The spaceCharacterForm to set.
       * @return This builder for chaining.
       */
      public Builder setSpaceCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000800;
        spaceCharacterForm_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       * @return This builder for chaining.
       */
      public Builder clearSpaceCharacterForm() {
        bitField0_ = (bitField0_ & ~0x00000800);
        spaceCharacterForm_ = 0;
        onChanged();
        return this;
      }

      private boolean useKeyboardToChangePreeditMethod_ ;
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       * @return Whether the useKeyboardToChangePreeditMethod field is set.
       */
      @java.lang.Override
      public boolean hasUseKeyboardToChangePreeditMethod() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       * @return The useKeyboardToChangePreeditMethod.
       */
      @java.lang.Override
      public boolean getUseKeyboardToChangePreeditMethod() {
        return useKeyboardToChangePreeditMethod_;
      }
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       * @param value The useKeyboardToChangePreeditMethod to set.
       * @return This builder for chaining.
       */
      public Builder setUseKeyboardToChangePreeditMethod(boolean value) {
        
        useKeyboardToChangePreeditMethod_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseKeyboardToChangePreeditMethod() {
        bitField0_ = (bitField0_ & ~0x00001000);
        useKeyboardToChangePreeditMethod_ = false;
        onChanged();
        return this;
      }

      private int historyLearningLevel_ = 0;
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       * @return Whether the historyLearningLevel field is set.
       */
      @java.lang.Override public boolean hasHistoryLearningLevel() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       * @return The historyLearningLevel.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.forNumber(historyLearningLevel_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.DEFAULT_HISTORY : result;
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       * @param value The historyLearningLevel to set.
       * @return This builder for chaining.
       */
      public Builder setHistoryLearningLevel(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00002000;
        historyLearningLevel_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       * @return This builder for chaining.
       */
      public Builder clearHistoryLearningLevel() {
        bitField0_ = (bitField0_ & ~0x00002000);
        historyLearningLevel_ = 0;
        onChanged();
        return this;
      }

      private int selectionShortcut_ = 1;
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       * @return Whether the selectionShortcut field is set.
       */
      @java.lang.Override public boolean hasSelectionShortcut() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       * @return The selectionShortcut.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.forNumber(selectionShortcut_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.SHORTCUT_123456789 : result;
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       * @param value The selectionShortcut to set.
       * @return This builder for chaining.
       */
      public Builder setSelectionShortcut(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00004000;
        selectionShortcut_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       * @return This builder for chaining.
       */
      public Builder clearSelectionShortcut() {
        bitField0_ = (bitField0_ & ~0x00004000);
        selectionShortcut_ = 1;
        onChanged();
        return this;
      }

      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> characterFormRules_ =
        java.util.Collections.emptyList();
      private void ensureCharacterFormRulesIsMutable() {
        if (!((bitField0_ & 0x00008000) != 0)) {
          characterFormRules_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule>(characterFormRules_);
          bitField0_ |= 0x00008000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> characterFormRulesBuilder_;

      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> getCharacterFormRulesList() {
        if (characterFormRulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(characterFormRules_);
        } else {
          return characterFormRulesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public int getCharacterFormRulesCount() {
        if (characterFormRulesBuilder_ == null) {
          return characterFormRules_.size();
        } else {
          return characterFormRulesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index) {
        if (characterFormRulesBuilder_ == null) {
          return characterFormRules_.get(index);
        } else {
          return characterFormRulesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder setCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        if (characterFormRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.set(index, value);
          onChanged();
        } else {
          characterFormRulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder setCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.set(index, builderForValue.build());
          onChanged();
        } else {
          characterFormRulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        if (characterFormRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(value);
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        if (characterFormRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(index, value);
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(builderForValue.build());
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(index, builderForValue.build());
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addAllCharacterFormRules(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> values) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, characterFormRules_);
          onChanged();
        } else {
          characterFormRulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder clearCharacterFormRules() {
        if (characterFormRulesBuilder_ == null) {
          characterFormRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00008000);
          onChanged();
        } else {
          characterFormRulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder removeCharacterFormRules(int index) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.remove(index);
          onChanged();
        } else {
          characterFormRulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder getCharacterFormRulesBuilder(
          int index) {
        return getCharacterFormRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
          int index) {
        if (characterFormRulesBuilder_ == null) {
          return characterFormRules_.get(index);  } else {
          return characterFormRulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
           getCharacterFormRulesOrBuilderList() {
        if (characterFormRulesBuilder_ != null) {
          return characterFormRulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(characterFormRules_);
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder addCharacterFormRulesBuilder() {
        return getCharacterFormRulesFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder addCharacterFormRulesBuilder(
          int index) {
        return getCharacterFormRulesFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder> 
           getCharacterFormRulesBuilderList() {
        return getCharacterFormRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
          getCharacterFormRulesFieldBuilder() {
        if (characterFormRulesBuilder_ == null) {
          characterFormRulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder>(
                  characterFormRules_,
                  ((bitField0_ & 0x00008000) != 0),
                  getParentForChildren(),
                  isClean());
          characterFormRules_ = null;
        }
        return characterFormRulesBuilder_;
      }

      private boolean useAutoImeTurnOff_ = true;
      /**
       * <pre>
       * auto IME turn off feature
       * </pre>
       *
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       * @return Whether the useAutoImeTurnOff field is set.
       */
      @java.lang.Override
      public boolean hasUseAutoImeTurnOff() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * auto IME turn off feature
       * </pre>
       *
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       * @return The useAutoImeTurnOff.
       */
      @java.lang.Override
      public boolean getUseAutoImeTurnOff() {
        return useAutoImeTurnOff_;
      }
      /**
       * <pre>
       * auto IME turn off feature
       * </pre>
       *
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       * @param value The useAutoImeTurnOff to set.
       * @return This builder for chaining.
       */
      public Builder setUseAutoImeTurnOff(boolean value) {
        
        useAutoImeTurnOff_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * auto IME turn off feature
       * </pre>
       *
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseAutoImeTurnOff() {
        bitField0_ = (bitField0_ & ~0x00010000);
        useAutoImeTurnOff_ = true;
        onChanged();
        return this;
      }

      private boolean useCascadingWindow_ = true;
      /**
       * <pre>
       * Toggle to use cascanding window for debugging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       * @return Whether the useCascadingWindow field is set.
       */
      @java.lang.Override
      public boolean hasUseCascadingWindow() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * Toggle to use cascanding window for debugging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       * @return The useCascadingWindow.
       */
      @java.lang.Override
      public boolean getUseCascadingWindow() {
        return useCascadingWindow_;
      }
      /**
       * <pre>
       * Toggle to use cascanding window for debugging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       * @param value The useCascadingWindow to set.
       * @return This builder for chaining.
       */
      public Builder setUseCascadingWindow(boolean value) {
        
        useCascadingWindow_ = value;
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Toggle to use cascanding window for debugging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseCascadingWindow() {
        bitField0_ = (bitField0_ & ~0x00020000);
        useCascadingWindow_ = true;
        onChanged();
        return this;
      }

      private int shiftKeyModeSwitch_ = 1;
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       * @return Whether the shiftKeyModeSwitch field is set.
       */
      @java.lang.Override public boolean hasShiftKeyModeSwitch() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       * @return The shiftKeyModeSwitch.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.forNumber(shiftKeyModeSwitch_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.ASCII_INPUT_MODE : result;
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       * @param value The shiftKeyModeSwitch to set.
       * @return This builder for chaining.
       */
      public Builder setShiftKeyModeSwitch(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00040000;
        shiftKeyModeSwitch_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       * @return This builder for chaining.
       */
      public Builder clearShiftKeyModeSwitch() {
        bitField0_ = (bitField0_ & ~0x00040000);
        shiftKeyModeSwitch_ = 1;
        onChanged();
        return this;
      }

      private int numpadCharacterForm_ = 2;
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       * @return Whether the numpadCharacterForm field is set.
       */
      @java.lang.Override public boolean hasNumpadCharacterForm() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       * @return The numpadCharacterForm.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.forNumber(numpadCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.NUMPAD_HALF_WIDTH : result;
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       * @param value The numpadCharacterForm to set.
       * @return This builder for chaining.
       */
      public Builder setNumpadCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00080000;
        numpadCharacterForm_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumpadCharacterForm() {
        bitField0_ = (bitField0_ & ~0x00080000);
        numpadCharacterForm_ = 2;
        onChanged();
        return this;
      }

      private boolean useAutoConversion_ ;
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       * @return Whether the useAutoConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseAutoConversion() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       * @return The useAutoConversion.
       */
      @java.lang.Override
      public boolean getUseAutoConversion() {
        return useAutoConversion_;
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       * @param value The useAutoConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseAutoConversion(boolean value) {
        
        useAutoConversion_ = value;
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseAutoConversion() {
        bitField0_ = (bitField0_ & ~0x00100000);
        useAutoConversion_ = false;
        onChanged();
        return this;
      }

      private int autoConversionKey_ = 13;
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       * @return Whether the autoConversionKey field is set.
       */
      @java.lang.Override
      public boolean hasAutoConversionKey() {
        return ((bitField0_ & 0x00200000) != 0);
      }
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       * @return The autoConversionKey.
       */
      @java.lang.Override
      public int getAutoConversionKey() {
        return autoConversionKey_;
      }
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       * @param value The autoConversionKey to set.
       * @return This builder for chaining.
       */
      public Builder setAutoConversionKey(int value) {
        
        autoConversionKey_ = value;
        bitField0_ |= 0x00200000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       * @return This builder for chaining.
       */
      public Builder clearAutoConversionKey() {
        bitField0_ = (bitField0_ & ~0x00200000);
        autoConversionKey_ = 13;
        onChanged();
        return this;
      }

      private int yenSignCharacter_ = 0;
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       * @return Whether the yenSignCharacter field is set.
       */
      @java.lang.Override public boolean hasYenSignCharacter() {
        return ((bitField0_ & 0x00400000) != 0);
      }
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       * @return The yenSignCharacter.
       */
      @java.lang.Override
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.forNumber(yenSignCharacter_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.YEN_SIGN : result;
      }
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       * @param value The yenSignCharacter to set.
       * @return This builder for chaining.
       */
      public Builder setYenSignCharacter(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00400000;
        yenSignCharacter_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       * @return This builder for chaining.
       */
      public Builder clearYenSignCharacter() {
        bitField0_ = (bitField0_ & ~0x00400000);
        yenSignCharacter_ = 0;
        onChanged();
        return this;
      }

      private boolean useJapaneseLayout_ ;
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       * @return Whether the useJapaneseLayout field is set.
       */
      @java.lang.Override
      public boolean hasUseJapaneseLayout() {
        return ((bitField0_ & 0x00800000) != 0);
      }
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       * @return The useJapaneseLayout.
       */
      @java.lang.Override
      public boolean getUseJapaneseLayout() {
        return useJapaneseLayout_;
      }
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       * @param value The useJapaneseLayout to set.
       * @return This builder for chaining.
       */
      public Builder setUseJapaneseLayout(boolean value) {
        
        useJapaneseLayout_ = value;
        bitField0_ |= 0x00800000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseJapaneseLayout() {
        bitField0_ = (bitField0_ & ~0x00800000);
        useJapaneseLayout_ = false;
        onChanged();
        return this;
      }

      private boolean useKanaModifierInsensitiveConversion_ ;
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       * @return Whether the useKanaModifierInsensitiveConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseKanaModifierInsensitiveConversion() {
        return ((bitField0_ & 0x01000000) != 0);
      }
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       * @return The useKanaModifierInsensitiveConversion.
       */
      @java.lang.Override
      public boolean getUseKanaModifierInsensitiveConversion() {
        return useKanaModifierInsensitiveConversion_;
      }
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       * @param value The useKanaModifierInsensitiveConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseKanaModifierInsensitiveConversion(boolean value) {
        
        useKanaModifierInsensitiveConversion_ = value;
        bitField0_ |= 0x01000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseKanaModifierInsensitiveConversion() {
        bitField0_ = (bitField0_ & ~0x01000000);
        useKanaModifierInsensitiveConversion_ = false;
        onChanged();
        return this;
      }

      private boolean useTypingCorrection_ ;
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       * @return Whether the useTypingCorrection field is set.
       */
      @java.lang.Override
      public boolean hasUseTypingCorrection() {
        return ((bitField0_ & 0x02000000) != 0);
      }
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       * @return The useTypingCorrection.
       */
      @java.lang.Override
      public boolean getUseTypingCorrection() {
        return useTypingCorrection_;
      }
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       * @param value The useTypingCorrection to set.
       * @return This builder for chaining.
       */
      public Builder setUseTypingCorrection(boolean value) {
        
        useTypingCorrection_ = value;
        bitField0_ |= 0x02000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseTypingCorrection() {
        bitField0_ = (bitField0_ & ~0x02000000);
        useTypingCorrection_ = false;
        onChanged();
        return this;
      }

      private int composingTimeoutThresholdMsec_ ;
      /**
       * <pre>
       * The duration in millisecond to determine the timeout.
       * If the duration between key inputs is more than this value,
       * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
       * If the value is 0, STOP_KEY_TOGGLING is not sent.
       * </pre>
       *
       * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
       * @return Whether the composingTimeoutThresholdMsec field is set.
       */
      @java.lang.Override
      public boolean hasComposingTimeoutThresholdMsec() {
        return ((bitField0_ & 0x04000000) != 0);
      }
      /**
       * <pre>
       * The duration in millisecond to determine the timeout.
       * If the duration between key inputs is more than this value,
       * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
       * If the value is 0, STOP_KEY_TOGGLING is not sent.
       * </pre>
       *
       * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
       * @return The composingTimeoutThresholdMsec.
       */
      @java.lang.Override
      public int getComposingTimeoutThresholdMsec() {
        return composingTimeoutThresholdMsec_;
      }
      /**
       * <pre>
       * The duration in millisecond to determine the timeout.
       * If the duration between key inputs is more than this value,
       * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
       * If the value is 0, STOP_KEY_TOGGLING is not sent.
       * </pre>
       *
       * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
       * @param value The composingTimeoutThresholdMsec to set.
       * @return This builder for chaining.
       */
      public Builder setComposingTimeoutThresholdMsec(int value) {
        
        composingTimeoutThresholdMsec_ = value;
        bitField0_ |= 0x04000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The duration in millisecond to determine the timeout.
       * If the duration between key inputs is more than this value,
       * a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
       * If the value is 0, STOP_KEY_TOGGLING is not sent.
       * </pre>
       *
       * <code>optional int32 composing_timeout_threshold_msec = 67 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearComposingTimeoutThresholdMsec() {
        bitField0_ = (bitField0_ & ~0x04000000);
        composingTimeoutThresholdMsec_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> overlayKeymaps_ =
        java.util.Collections.emptyList();
      private void ensureOverlayKeymapsIsMutable() {
        if (!((bitField0_ & 0x08000000) != 0)) {
          overlayKeymaps_ = new java.util.ArrayList<java.lang.Integer>(overlayKeymaps_);
          bitField0_ |= 0x08000000;
        }
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @return A list containing the overlayKeymaps.
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> getOverlayKeymapsList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap>(overlayKeymaps_, overlayKeymaps_converter_);
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @return The count of overlayKeymaps.
       */
      public int getOverlayKeymapsCount() {
        return overlayKeymaps_.size();
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The overlayKeymaps at the given index.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getOverlayKeymaps(int index) {
        return overlayKeymaps_converter_.convert(overlayKeymaps_.get(index));
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The overlayKeymaps to set.
       * @return This builder for chaining.
       */
      public Builder setOverlayKeymaps(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureOverlayKeymapsIsMutable();
        overlayKeymaps_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @param value The overlayKeymaps to add.
       * @return This builder for chaining.
       */
      public Builder addOverlayKeymaps(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureOverlayKeymapsIsMutable();
        overlayKeymaps_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @param values The overlayKeymaps to add.
       * @return This builder for chaining.
       */
      public Builder addAllOverlayKeymaps(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap> values) {
        ensureOverlayKeymapsIsMutable();
        for (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value : values) {
          overlayKeymaps_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The keymaps which are loaded on top of `session_keymap`.
       * Overlay keymaps are prioritized over `session_keymap`.
       * They are used to partially modify the session keymap, for example
       * using Henkan key as IME_ON.
       * </pre>
       *
       * <code>repeated .mozc.config.Config.SessionKeymap overlay_keymaps = 68 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearOverlayKeymaps() {
        overlayKeymaps_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x08000000);
        onChanged();
        return this;
      }

      private boolean useDateConversion_ = true;
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       * @return Whether the useDateConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseDateConversion() {
        return ((bitField0_ & 0x10000000) != 0);
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       * @return The useDateConversion.
       */
      @java.lang.Override
      public boolean getUseDateConversion() {
        return useDateConversion_;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       * @param value The useDateConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseDateConversion(boolean value) {
        
        useDateConversion_ = value;
        bitField0_ |= 0x10000000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseDateConversion() {
        bitField0_ = (bitField0_ & ~0x10000000);
        useDateConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useSingleKanjiConversion_ = true;
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       * @return Whether the useSingleKanjiConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseSingleKanjiConversion() {
        return ((bitField0_ & 0x20000000) != 0);
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       * @return The useSingleKanjiConversion.
       */
      @java.lang.Override
      public boolean getUseSingleKanjiConversion() {
        return useSingleKanjiConversion_;
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       * @param value The useSingleKanjiConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseSingleKanjiConversion(boolean value) {
        
        useSingleKanjiConversion_ = value;
        bitField0_ |= 0x20000000;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseSingleKanjiConversion() {
        bitField0_ = (bitField0_ & ~0x20000000);
        useSingleKanjiConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useSymbolConversion_ = true;
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       * @return Whether the useSymbolConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseSymbolConversion() {
        return ((bitField0_ & 0x40000000) != 0);
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       * @return The useSymbolConversion.
       */
      @java.lang.Override
      public boolean getUseSymbolConversion() {
        return useSymbolConversion_;
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       * @param value The useSymbolConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseSymbolConversion(boolean value) {
        
        useSymbolConversion_ = value;
        bitField0_ |= 0x40000000;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseSymbolConversion() {
        bitField0_ = (bitField0_ & ~0x40000000);
        useSymbolConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useNumberConversion_ = true;
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       * @return Whether the useNumberConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseNumberConversion() {
        return ((bitField0_ & 0x80000000) != 0);
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       * @return The useNumberConversion.
       */
      @java.lang.Override
      public boolean getUseNumberConversion() {
        return useNumberConversion_;
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       * @param value The useNumberConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseNumberConversion(boolean value) {
        
        useNumberConversion_ = value;
        bitField0_ |= 0x80000000;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseNumberConversion() {
        bitField0_ = (bitField0_ & ~0x80000000);
        useNumberConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useEmoticonConversion_ = true;
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       * @return Whether the useEmoticonConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseEmoticonConversion() {
        return ((bitField1_ & 0x00000001) != 0);
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       * @return The useEmoticonConversion.
       */
      @java.lang.Override
      public boolean getUseEmoticonConversion() {
        return useEmoticonConversion_;
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       * @param value The useEmoticonConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseEmoticonConversion(boolean value) {
        
        useEmoticonConversion_ = value;
        bitField1_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseEmoticonConversion() {
        bitField1_ = (bitField1_ & ~0x00000001);
        useEmoticonConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useCalculator_ = true;
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       * @return Whether the useCalculator field is set.
       */
      @java.lang.Override
      public boolean hasUseCalculator() {
        return ((bitField1_ & 0x00000002) != 0);
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       * @return The useCalculator.
       */
      @java.lang.Override
      public boolean getUseCalculator() {
        return useCalculator_;
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       * @param value The useCalculator to set.
       * @return This builder for chaining.
       */
      public Builder setUseCalculator(boolean value) {
        
        useCalculator_ = value;
        bitField1_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseCalculator() {
        bitField1_ = (bitField1_ & ~0x00000002);
        useCalculator_ = true;
        onChanged();
        return this;
      }

      private boolean useT13NConversion_ = true;
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       * @return Whether the useT13nConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseT13NConversion() {
        return ((bitField1_ & 0x00000004) != 0);
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       * @return The useT13nConversion.
       */
      @java.lang.Override
      public boolean getUseT13NConversion() {
        return useT13NConversion_;
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       * @param value The useT13nConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseT13NConversion(boolean value) {
        
        useT13NConversion_ = value;
        bitField1_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseT13NConversion() {
        bitField1_ = (bitField1_ & ~0x00000004);
        useT13NConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useZipCodeConversion_ = true;
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       * @return Whether the useZipCodeConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseZipCodeConversion() {
        return ((bitField1_ & 0x00000008) != 0);
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       * @return The useZipCodeConversion.
       */
      @java.lang.Override
      public boolean getUseZipCodeConversion() {
        return useZipCodeConversion_;
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       * @param value The useZipCodeConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseZipCodeConversion(boolean value) {
        
        useZipCodeConversion_ = value;
        bitField1_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseZipCodeConversion() {
        bitField1_ = (bitField1_ & ~0x00000008);
        useZipCodeConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useSpellingCorrection_ = true;
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       * @return Whether the useSpellingCorrection field is set.
       */
      @java.lang.Override
      public boolean hasUseSpellingCorrection() {
        return ((bitField1_ & 0x00000010) != 0);
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       * @return The useSpellingCorrection.
       */
      @java.lang.Override
      public boolean getUseSpellingCorrection() {
        return useSpellingCorrection_;
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       * @param value The useSpellingCorrection to set.
       * @return This builder for chaining.
       */
      public Builder setUseSpellingCorrection(boolean value) {
        
        useSpellingCorrection_ = value;
        bitField1_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseSpellingCorrection() {
        bitField1_ = (bitField1_ & ~0x00000010);
        useSpellingCorrection_ = true;
        onChanged();
        return this;
      }

      private boolean useEmojiConversion_ ;
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       * @return Whether the useEmojiConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseEmojiConversion() {
        return ((bitField1_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       * @return The useEmojiConversion.
       */
      @java.lang.Override
      public boolean getUseEmojiConversion() {
        return useEmojiConversion_;
      }
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       * @param value The useEmojiConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseEmojiConversion(boolean value) {
        
        useEmojiConversion_ = value;
        bitField1_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseEmojiConversion() {
        bitField1_ = (bitField1_ & ~0x00000020);
        useEmojiConversion_ = false;
        onChanged();
        return this;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig informationListConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder> informationListConfigBuilder_;
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       * @return Whether the informationListConfig field is set.
       */
      public boolean hasInformationListConfig() {
        return ((bitField1_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       * @return The informationListConfig.
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig() {
        if (informationListConfigBuilder_ == null) {
          return informationListConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance() : informationListConfig_;
        } else {
          return informationListConfigBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder setInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
        if (informationListConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          informationListConfig_ = value;
        } else {
          informationListConfigBuilder_.setMessage(value);
        }
        bitField1_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder setInformationListConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder builderForValue) {
        if (informationListConfigBuilder_ == null) {
          informationListConfig_ = builderForValue.build();
        } else {
          informationListConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField1_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder mergeInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
        if (informationListConfigBuilder_ == null) {
          if (((bitField1_ & 0x00000040) != 0) &&
            informationListConfig_ != null &&
            informationListConfig_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance()) {
            getInformationListConfigBuilder().mergeFrom(value);
          } else {
            informationListConfig_ = value;
          }
        } else {
          informationListConfigBuilder_.mergeFrom(value);
        }
        bitField1_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder clearInformationListConfig() {
        bitField1_ = (bitField1_ & ~0x00000040);
        informationListConfig_ = null;
        if (informationListConfigBuilder_ != null) {
          informationListConfigBuilder_.dispose();
          informationListConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder getInformationListConfigBuilder() {
        bitField1_ |= 0x00000040;
        onChanged();
        return getInformationListConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder getInformationListConfigOrBuilder() {
        if (informationListConfigBuilder_ != null) {
          return informationListConfigBuilder_.getMessageOrBuilder();
        } else {
          return informationListConfig_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance() : informationListConfig_;
        }
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder> 
          getInformationListConfigFieldBuilder() {
        if (informationListConfigBuilder_ == null) {
          informationListConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder>(
                  getInformationListConfig(),
                  getParentForChildren(),
                  isClean());
          informationListConfig_ = null;
        }
        return informationListConfigBuilder_;
      }

      private boolean useHistorySuggest_ = true;
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Suggest is a feature of word suggestion with prefix search.
       * When you type "", you may get "", "" (), "" ()
       * as suggested words.
       * Use history-based suggest feature.
       * If this is true, your previously typed words are prioritized.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       * @return Whether the useHistorySuggest field is set.
       */
      @java.lang.Override
      public boolean hasUseHistorySuggest() {
        return ((bitField1_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Suggest is a feature of word suggestion with prefix search.
       * When you type "", you may get "", "" (), "" ()
       * as suggested words.
       * Use history-based suggest feature.
       * If this is true, your previously typed words are prioritized.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       * @return The useHistorySuggest.
       */
      @java.lang.Override
      public boolean getUseHistorySuggest() {
        return useHistorySuggest_;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Suggest is a feature of word suggestion with prefix search.
       * When you type "", you may get "", "" (), "" ()
       * as suggested words.
       * Use history-based suggest feature.
       * If this is true, your previously typed words are prioritized.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       * @param value The useHistorySuggest to set.
       * @return This builder for chaining.
       */
      public Builder setUseHistorySuggest(boolean value) {
        
        useHistorySuggest_ = value;
        bitField1_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Suggest is a feature of word suggestion with prefix search.
       * When you type "", you may get "", "" (), "" ()
       * as suggested words.
       * Use history-based suggest feature.
       * If this is true, your previously typed words are prioritized.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseHistorySuggest() {
        bitField1_ = (bitField1_ & ~0x00000080);
        useHistorySuggest_ = true;
        onChanged();
        return this;
      }

      private boolean useDictionarySuggest_ = true;
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * If this is true, words in the word dictionary are suggested even if
       * you haven't typed before.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       * @return Whether the useDictionarySuggest field is set.
       */
      @java.lang.Override
      public boolean hasUseDictionarySuggest() {
        return ((bitField1_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * If this is true, words in the word dictionary are suggested even if
       * you haven't typed before.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       * @return The useDictionarySuggest.
       */
      @java.lang.Override
      public boolean getUseDictionarySuggest() {
        return useDictionarySuggest_;
      }
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * If this is true, words in the word dictionary are suggested even if
       * you haven't typed before.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       * @param value The useDictionarySuggest to set.
       * @return This builder for chaining.
       */
      public Builder setUseDictionarySuggest(boolean value) {
        
        useDictionarySuggest_ = value;
        bitField1_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * If this is true, words in the word dictionary are suggested even if
       * you haven't typed before.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseDictionarySuggest() {
        bitField1_ = (bitField1_ & ~0x00000100);
        useDictionarySuggest_ = true;
        onChanged();
        return this;
      }

      private boolean useRealtimeConversion_ = true;
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       * @return Whether the useRealtimeConversion field is set.
       */
      @java.lang.Override
      public boolean hasUseRealtimeConversion() {
        return ((bitField1_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       * @return The useRealtimeConversion.
       */
      @java.lang.Override
      public boolean getUseRealtimeConversion() {
        return useRealtimeConversion_;
      }
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       * @param value The useRealtimeConversion to set.
       * @return This builder for chaining.
       */
      public Builder setUseRealtimeConversion(boolean value) {
        
        useRealtimeConversion_ = value;
        bitField1_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseRealtimeConversion() {
        bitField1_ = (bitField1_ & ~0x00000200);
        useRealtimeConversion_ = true;
        onChanged();
        return this;
      }

      private int suggestionsSize_ = 3;
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       * @return Whether the suggestionsSize field is set.
       */
      @java.lang.Override
      public boolean hasSuggestionsSize() {
        return ((bitField1_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       * @return The suggestionsSize.
       */
      @java.lang.Override
      public int getSuggestionsSize() {
        return suggestionsSize_;
      }
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       * @param value The suggestionsSize to set.
       * @return This builder for chaining.
       */
      public Builder setSuggestionsSize(int value) {
        
        suggestionsSize_ = value;
        bitField1_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       * @return This builder for chaining.
       */
      public Builder clearSuggestionsSize() {
        bitField1_ = (bitField1_ & ~0x00000400);
        suggestionsSize_ = 3;
        onChanged();
        return this;
      }

      private boolean useModeIndicator_ = true;
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       * @return Whether the useModeIndicator field is set.
       */
      @java.lang.Override
      public boolean hasUseModeIndicator() {
        return ((bitField1_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       * @return The useModeIndicator.
       */
      @java.lang.Override
      public boolean getUseModeIndicator() {
        return useModeIndicator_;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       * @param value The useModeIndicator to set.
       * @return This builder for chaining.
       */
      public Builder setUseModeIndicator(boolean value) {
        
        useModeIndicator_ = value;
        bitField1_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseModeIndicator() {
        bitField1_ = (bitField1_ & ~0x00000800);
        useModeIndicator_ = true;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.config.Config)
    }

    // @@protoc_insertion_point(class_scope:mozc.config.Config)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Config>
        PARSER = new com.google.protobuf.AbstractParser<Config>() {
      @java.lang.Override
      public Config parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Config> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Config> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_GeneralConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_config_GeneralConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_Config_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_config_Config_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_Config_CharacterFormRule_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_Config_InformationListConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\025protocol/config.proto\022\013mozc.config\"\311\001\n" +
      "\rGeneralConfig\022\031\n\016config_version\030\001 \001(\r:\001" +
      "0\022.\n\035last_modified_product_version\030\002 \001(\t" +
      ":\0070.0.0.0\022!\n\022last_modified_time\030\003 \001(\004:\0010" +
      "B\0020\001\022\022\n\010platform\030\004 \001(\t:\000\022\023\n\tui_locale\030\005 " +
      "\001(\t:\000\022!\n\022upload_usage_stats\030\006 \001(\010:\005false" +
      "\"\307\036\n\006Config\0222\n\016general_config\030\001 \001(\0132\032.mo" +
      "zc.config.GeneralConfig\022\030\n\rverbose_level" +
      "\030\n \001(\005:\0010\022\035\n\016incognito_mode\030\024 \001(\010:\005false" +
      "\022\033\n\rcheck_default\030\026 \001(\010:\004true\022 \n\021present" +
      "ation_mode\030\027 \001(\010:\005false\022@\n\016preedit_metho" +
      "d\030( \001(\0162!.mozc.config.Config.PreeditMeth" +
      "od:\005ROMAN\022?\n\016session_keymap\030) \001(\0162!.mozc" +
      ".config.Config.SessionKeymap:\004NONE\022\033\n\023cu" +
      "stom_keymap_table\030* \001(\014\022\032\n\022custom_roman_" +
      "table\030+ \001(\014\022O\n\022punctuation_method\030- \001(\0162" +
      "%.mozc.config.Config.PunctuationMethod:\014" +
      "KUTEN_TOUTEN\022R\n\rsymbol_method\030. \001(\0162 .mo" +
      "zc.config.Config.SymbolMethod:\031CORNER_BR" +
      "ACKET_MIDDLE_DOT\022b\n\024space_character_form" +
      "\030/ \001(\0162,.mozc.config.Config.FundamentalC" +
      "haracterForm:\026FUNDAMENTAL_INPUT_MODE\0224\n%" +
      "use_keyboard_to_change_preedit_method\0300 " +
      "\001(\010:\005false\022Y\n\026history_learning_level\0302 \001" +
      "(\0162(.mozc.config.Config.HistoryLearningL" +
      "evel:\017DEFAULT_HISTORY\022U\n\022selection_short" +
      "cut\0304 \001(\0162%.mozc.config.Config.Selection" +
      "Shortcut:\022SHORTCUT_123456789\022C\n\024characte" +
      "r_form_rules\0306 \003(\0132%.mozc.config.Config." +
      "CharacterFormRule\022#\n\025use_auto_ime_turn_o" +
      "ff\0308 \001(\010:\004true\022\"\n\024use_cascading_window\030:" +
      " \001(\010:\004true\022W\n\025shift_key_mode_switch\030; \001(" +
      "\0162&.mozc.config.Config.ShiftKeyModeSwitc" +
      "h:\020ASCII_INPUT_MODE\022Y\n\025numpad_character_" +
      "form\030< \001(\0162\'.mozc.config.Config.NumpadCh" +
      "aracterForm:\021NUMPAD_HALF_WIDTH\022\"\n\023use_au" +
      "to_conversion\030= \001(\010:\005false\022\037\n\023auto_conve" +
      "rsion_key\030> \001(\r:\00213\022J\n\022yen_sign_characte" +
      "r\030? \001(\0162$.mozc.config.Config.YenSignChar" +
      "acter:\010YEN_SIGN\022\"\n\023use_japanese_layout\030@" +
      " \001(\010:\005false\0227\n(use_kana_modifier_insensi" +
      "tive_conversion\030A \001(\010:\005false\022$\n\025use_typi" +
      "ng_correction\030B \001(\010:\005false\022+\n composing_" +
      "timeout_threshold_msec\030C \001(\005:\0010\022>\n\017overl" +
      "ay_keymaps\030D \003(\0162!.mozc.config.Config.Se" +
      "ssionKeymapB\002\020\001\022!\n\023use_date_conversion\030P" +
      " \001(\010:\004true\022)\n\033use_single_kanji_conversio" +
      "n\030Q \001(\010:\004true\022#\n\025use_symbol_conversion\030R" +
      " \001(\010:\004true\022#\n\025use_number_conversion\030S \001(" +
      "\010:\004true\022%\n\027use_emoticon_conversion\030T \001(\010" +
      ":\004true\022\034\n\016use_calculator\030U \001(\010:\004true\022!\n\023" +
      "use_t13n_conversion\030V \001(\010:\004true\022%\n\027use_z" +
      "ip_code_conversion\030W \001(\010:\004true\022%\n\027use_sp" +
      "elling_correction\030X \001(\010:\004true\022#\n\024use_emo" +
      "ji_conversion\030Y \001(\010:\005false\022J\n\027informatio" +
      "n_list_config\030Z \001(\0132).mozc.config.Config" +
      ".InformationListConfig\022!\n\023use_history_su" +
      "ggest\030d \001(\010:\004true\022$\n\026use_dictionary_sugg" +
      "est\030e \001(\010:\004true\022%\n\027use_realtime_conversi" +
      "on\030f \001(\010:\004true\022\033\n\020suggestions_size\030n \001(\r" +
      ":\0013\022 \n\022use_mode_indicator\030x \001(\010:\004true\032\303\001" +
      "\n\021CharacterFormRule\022\r\n\005group\030\001 \001(\t\022M\n\026pr" +
      "eedit_character_form\030\002 \001(\0162!.mozc.config" +
      ".Config.CharacterForm:\nFULL_WIDTH\022P\n\031con" +
      "version_character_form\030\003 \001(\0162!.mozc.conf" +
      "ig.Config.CharacterForm:\nFULL_WIDTH\032|\n\025I" +
      "nformationListConfig\022(\n\032use_local_usage_" +
      "dictionary\030\001 \001(\010:\004trueJ\004\010\002\020\003J\004\010\n\020\013R\030use_" +
      "web_usage_dictionaryR\023web_service_entrie" +
      "s\"$\n\rPreeditMethod\022\t\n\005ROMAN\020\000\022\010\n\004KANA\020\001\"" +
      "\254\001\n\rSessionKeymap\022\021\n\004NONE\020\377\377\377\377\377\377\377\377\377\001\022\n\n\006" +
      "CUSTOM\020\000\022\010\n\004ATOK\020\001\022\t\n\005MSIME\020\002\022\013\n\007KOTOERI" +
      "\020\003\022\n\n\006MOBILE\020\004\022\014\n\010CHROMEOS\020\005\022)\n%OVERLAY_" +
      "HENKAN_MUHENKAN_TO_IME_ON_OFF\020d\022\025\n\020OVERL" +
      "AY_FOR_TEST\020\220N\"[\n\021PunctuationMethod\022\020\n\014K" +
      "UTEN_TOUTEN\020\000\022\020\n\014COMMA_PERIOD\020\001\022\020\n\014KUTEN" +
      "_PERIOD\020\002\022\020\n\014COMMA_TOUTEN\020\003\"\200\001\n\014SymbolMe" +
      "thod\022\035\n\031CORNER_BRACKET_MIDDLE_DOT\020\000\022\030\n\024S" +
      "QUARE_BRACKET_SLASH\020\001\022\030\n\024CORNER_BRACKET_" +
      "SLASH\020\002\022\035\n\031SQUARE_BRACKET_MIDDLE_DOT\020\003\"n" +
      "\n\030FundamentalCharacterForm\022\032\n\026FUNDAMENTA" +
      "L_INPUT_MODE\020\000\022\032\n\026FUNDAMENTAL_FULL_WIDTH" +
      "\020\001\022\032\n\026FUNDAMENTAL_HALF_WIDTH\020\002\"J\n\024Histor" +
      "yLearningLevel\022\023\n\017DEFAULT_HISTORY\020\000\022\r\n\tR" +
      "EAD_ONLY\020\001\022\016\n\nNO_HISTORY\020\002\"T\n\021SelectionS" +
      "hortcut\022\017\n\013NO_SHORTCUT\020\000\022\026\n\022SHORTCUT_123" +
      "456789\020\001\022\026\n\022SHORTCUT_ASDFGHJKL\020\002\"Q\n\rChar" +
      "acterForm\022\016\n\nHALF_WIDTH\020\000\022\016\n\nFULL_WIDTH\020" +
      "\001\022\r\n\tLAST_FORM\020\002\022\021\n\rNO_CONVERSION\020\003\"L\n\022S" +
      "hiftKeyModeSwitch\022\007\n\003OFF\020\000\022\024\n\020ASCII_INPU" +
      "T_MODE\020\001\022\027\n\023KATAKANA_INPUT_MODE\020\002\"s\n\023Num" +
      "padCharacterForm\022\025\n\021NUMPAD_INPUT_MODE\020\000\022" +
      "\025\n\021NUMPAD_FULL_WIDTH\020\001\022\025\n\021NUMPAD_HALF_WI" +
      "DTH\020\002\022\027\n\023NUMPAD_DIRECT_INPUT\020\003\"\254\001\n\021AutoC" +
      "onversionKey\022\027\n\023AUTO_CONVERSION_OFF\020\000\022\031\n" +
      "\025AUTO_CONVERSION_KUTEN\020\001\022\032\n\026AUTO_CONVERS" +
      "ION_TOUTEN\020\002\022!\n\035AUTO_CONVERSION_QUESTION" +
      "_MARK\020\004\022$\n AUTO_CONVERSION_EXCLAMATION_M" +
      "ARK\020\010\"/\n\020YenSignCharacter\022\014\n\010YEN_SIGN\020\000\022" +
      "\r\n\tBACKSLASH\020\001J\004\010\002\020\nJ\004\010\013\020\014J\004\010\025\020\026J\006\010\254\002\020\255\002" +
      "J\006\010\255\002\020\256\002J\006\010\344\007\020\345\007J\006\010\346\007\020\347\007J\006\010\347\007\020\350\007R\020log_al" +
      "l_commandsR\022upload_usage_statsR\013sync_con" +
      "figR\027allow_cloud_handwritingR\rpinyin_con" +
      "figR\rhangul_configR\016chewing_configB=\n.or" +
      "g.mozc.android.inputmethod.japanese.prot" +
      "obufB\013ProtoConfig"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_mozc_config_GeneralConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_mozc_config_GeneralConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_config_GeneralConfig_descriptor,
        new java.lang.String[] { "ConfigVersion", "LastModifiedProductVersion", "LastModifiedTime", "Platform", "UiLocale", "UploadUsageStats", });
    internal_static_mozc_config_Config_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_mozc_config_Config_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_config_Config_descriptor,
        new java.lang.String[] { "GeneralConfig", "VerboseLevel", "IncognitoMode", "CheckDefault", "PresentationMode", "PreeditMethod", "SessionKeymap", "CustomKeymapTable", "CustomRomanTable", "PunctuationMethod", "SymbolMethod", "SpaceCharacterForm", "UseKeyboardToChangePreeditMethod", "HistoryLearningLevel", "SelectionShortcut", "CharacterFormRules", "UseAutoImeTurnOff", "UseCascadingWindow", "ShiftKeyModeSwitch", "NumpadCharacterForm", "UseAutoConversion", "AutoConversionKey", "YenSignCharacter", "UseJapaneseLayout", "UseKanaModifierInsensitiveConversion", "UseTypingCorrection", "ComposingTimeoutThresholdMsec", "OverlayKeymaps", "UseDateConversion", "UseSingleKanjiConversion", "UseSymbolConversion", "UseNumberConversion", "UseEmoticonConversion", "UseCalculator", "UseT13NConversion", "UseZipCodeConversion", "UseSpellingCorrection", "UseEmojiConversion", "InformationListConfig", "UseHistorySuggest", "UseDictionarySuggest", "UseRealtimeConversion", "SuggestionsSize", "UseModeIndicator", });
    internal_static_mozc_config_Config_CharacterFormRule_descriptor =
      internal_static_mozc_config_Config_descriptor.getNestedTypes().get(0);
    internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_config_Config_CharacterFormRule_descriptor,
        new java.lang.String[] { "Group", "PreeditCharacterForm", "ConversionCharacterForm", });
    internal_static_mozc_config_Config_InformationListConfig_descriptor =
      internal_static_mozc_config_Config_descriptor.getNestedTypes().get(1);
    internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_config_Config_InformationListConfig_descriptor,
        new java.lang.String[] { "UseLocalUsageDictionary", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
